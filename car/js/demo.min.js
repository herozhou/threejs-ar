! function e(t, n, i) {
    function r(a, s) {
        if (!n[a]) {
            if (!t[a]) {
                var l = "function" == typeof require && require;
                if (!s && l) return l(a, !0);
                if (o) return o(a, !0);
                var c = new Error("Cannot find module '" + a + "'");
                throw c.code = "MODULE_NOT_FOUND", c
            }
            var h = n[a] = {
                exports: {}
            };
            t[a][0].call(h.exports, function(e) {
                var n = t[a][1][e];
                return r(n ? n : e)
            }, h, h.exports, e, t, n, i)
        }
        return n[a].exports
    }
    for (var o = "function" == typeof require && require, a = 0; a < i.length; a++) r(i[a]);
    return r
}({
    1: [
        function(e, t, n) {
            function i() {
                r(function() {
                    return new o({
                        scene: new a,
                        width: window.innerWidth,
                        height: window.innerHeight,
                        enableCompositing: !1
                    })
                }, {
                    models: ["camera_auto", "camera_transition", "exterior", "interior", "door", "tire", "rim", "screw", "logo", "headlights", "tunnel"],
                    textureBundles: ["car", "env"]
                })
            }
            var r = e("28"),
                o = e("10"),
                a = e("48");
            window.isPhonegap ? document.addEventListener("deviceready", i, !1) : i()
        }, {
            10: 10,
            28: 28,
            48: 48
        }
    ],
    2: [
        function(e, t, n) {
            (function(t) {
                ! function(i) {
                    var r = "object" == typeof self && self.self === self && self || "object" == typeof t && t.global === t && t;
                    if ("function" == typeof define && define.amd) define(["underscore", "jquery", "exports"], function(e, t, n) {
                        r.Backbone = i(r, n, e, t)
                    });
                    else if ("undefined" != typeof n) {
                        var o, a = e("7");
                        try {
                            o = e("4")
                        } catch (s) {}
                        i(r, n, a, o)
                    } else r.Backbone = i(r, {}, r._, r.jQuery || r.Zepto || r.ender || r.$)
                }(function(e, t, n, i) {
                    var r = e.Backbone,
                        o = Array.prototype.slice;
                    t.VERSION = "1.3.3", t.$ = i, t.noConflict = function() {
                        return e.Backbone = r, this
                    }, t.emulateHTTP = !1, t.emulateJSON = !1;
                    var a = function(e, t, i) {
                            switch (e) {
                                case 1:
                                    return function() {
                                        return n[t](this[i])
                                    };
                                case 2:
                                    return function(e) {
                                        return n[t](this[i], e)
                                    };
                                case 3:
                                    return function(e, r) {
                                        return n[t](this[i], l(e, this), r)
                                    };
                                case 4:
                                    return function(e, r, o) {
                                        return n[t](this[i], l(e, this), r, o)
                                    };
                                default:
                                    return function() {
                                        var e = o.call(arguments);
                                        return e.unshift(this[i]), n[t].apply(n, e)
                                    }
                            }
                        },
                        s = function(e, t, i) {
                            n.each(t, function(t, r) {
                                n[r] && (e.prototype[r] = a(t, r, i))
                            })
                        },
                        l = function(e, t) {
                            return n.isFunction(e) ? e : n.isObject(e) && !t._isModel(e) ? c(e) : n.isString(e) ? function(t) {
                                return t.get(e)
                            } : e
                        },
                        c = function(e) {
                            var t = n.matches(e);
                            return function(e) {
                                return t(e.attributes)
                            }
                        },
                        h = t.Events = {},
                        u = /\s+/,
                        f = function(e, t, i, r, o) {
                            var a, s = 0;
                            if (i && "object" == typeof i) {
                                void 0 !== r && "context" in o && void 0 === o.context && (o.context = r);
                                for (a = n.keys(i); s < a.length; s++) t = f(e, t, a[s], i[a[s]], o)
                            } else if (i && u.test(i))
                                for (a = i.split(u); s < a.length; s++) t = e(t, a[s], r, o);
                            else t = e(t, i, r, o);
                            return t
                        };
                    h.on = function(e, t, n) {
                        return d(this, e, t, n)
                    };
                    var d = function(e, t, n, i, r) {
                        if (e._events = f(p, e._events || {}, t, n, {
                                context: i,
                                ctx: e,
                                listening: r
                            }), r) {
                            var o = e._listeners || (e._listeners = {});
                            o[r.id] = r
                        }
                        return e
                    };
                    h.listenTo = function(e, t, i) {
                        if (!e) return this;
                        var r = e._listenId || (e._listenId = n.uniqueId("l")),
                            o = this._listeningTo || (this._listeningTo = {}),
                            a = o[r];
                        if (!a) {
                            var s = this._listenId || (this._listenId = n.uniqueId("l"));
                            a = o[r] = {
                                obj: e,
                                objId: r,
                                id: s,
                                listeningTo: o,
                                count: 0
                            }
                        }
                        return d(e, t, i, this, a), this
                    };
                    var p = function(e, t, n, i) {
                        if (n) {
                            var r = e[t] || (e[t] = []),
                                o = i.context,
                                a = i.ctx,
                                s = i.listening;
                            s && s.count++, r.push({
                                callback: n,
                                context: o,
                                ctx: o || a,
                                listening: s
                            })
                        }
                        return e
                    };
                    h.off = function(e, t, n) {
                        return this._events ? (this._events = f(m, this._events, e, t, {
                            context: n,
                            listeners: this._listeners
                        }), this) : this
                    }, h.stopListening = function(e, t, i) {
                        var r = this._listeningTo;
                        if (!r) return this;
                        for (var o = e ? [e._listenId] : n.keys(r), a = 0; a < o.length; a++) {
                            var s = r[o[a]];
                            if (!s) break;
                            s.obj.off(t, i, this)
                        }
                        return this
                    };
                    var m = function(e, t, i, r) {
                        if (e) {
                            var o, a = 0,
                                s = r.context,
                                l = r.listeners;
                            if (t || i || s) {
                                for (var c = t ? [t] : n.keys(e); a < c.length; a++) {
                                    t = c[a];
                                    var h = e[t];
                                    if (!h) break;
                                    for (var u = [], f = 0; f < h.length; f++) {
                                        var d = h[f];
                                        i && i !== d.callback && i !== d.callback._callback || s && s !== d.context ? u.push(d) : (o = d.listening, o && 0 === --o.count && (delete l[o.id], delete o.listeningTo[o.objId]))
                                    }
                                    u.length ? e[t] = u : delete e[t]
                                }
                                return e
                            }
                            for (var p = n.keys(l); a < p.length; a++) o = l[p[a]], delete l[o.id], delete o.listeningTo[o.objId]
                        }
                    };
                    h.once = function(e, t, i) {
                        var r = f(v, {}, e, t, n.bind(this.off, this));
                        return "string" == typeof e && null == i && (t = void 0), this.on(r, t, i)
                    }, h.listenToOnce = function(e, t, i) {
                        var r = f(v, {}, t, i, n.bind(this.stopListening, this, e));
                        return this.listenTo(e, r)
                    };
                    var v = function(e, t, i, r) {
                        if (i) {
                            var o = e[t] = n.once(function() {
                                r(t, o), i.apply(this, arguments)
                            });
                            o._callback = i
                        }
                        return e
                    };
                    h.trigger = function(e) {
                        if (!this._events) return this;
                        for (var t = Math.max(0, arguments.length - 1), n = Array(t), i = 0; t > i; i++) n[i] = arguments[i + 1];
                        return f(g, this._events, e, void 0, n), this
                    };
                    var g = function(e, t, n, i) {
                            if (e) {
                                var r = e[t],
                                    o = e.all;
                                r && o && (o = o.slice()), r && y(r, i), o && y(o, [t].concat(i))
                            }
                            return e
                        },
                        y = function(e, t) {
                            var n, i = -1,
                                r = e.length,
                                o = t[0],
                                a = t[1],
                                s = t[2];
                            switch (t.length) {
                                case 0:
                                    for (; ++i < r;)(n = e[i]).callback.call(n.ctx);
                                    return;
                                case 1:
                                    for (; ++i < r;)(n = e[i]).callback.call(n.ctx, o);
                                    return;
                                case 2:
                                    for (; ++i < r;)(n = e[i]).callback.call(n.ctx, o, a);
                                    return;
                                case 3:
                                    for (; ++i < r;)(n = e[i]).callback.call(n.ctx, o, a, s);
                                    return;
                                default:
                                    for (; ++i < r;)(n = e[i]).callback.apply(n.ctx, t);
                                    return
                            }
                        };
                    h.bind = h.on, h.unbind = h.off, n.extend(t, h);
                    var x = t.Model = function(e, t) {
                        var i = e || {};
                        t || (t = {}), this.cid = n.uniqueId(this.cidPrefix), this.attributes = {}, t.collection && (this.collection = t.collection), t.parse && (i = this.parse(i, t) || {});
                        var r = n.result(this, "defaults");
                        i = n.defaults(n.extend({}, r, i), r), this.set(i, t), this.changed = {}, this.initialize.apply(this, arguments)
                    };
                    n.extend(x.prototype, h, {
                        changed: null,
                        validationError: null,
                        idAttribute: "id",
                        cidPrefix: "c",
                        initialize: function() {},
                        toJSON: function(e) {
                            return n.clone(this.attributes)
                        },
                        sync: function() {
                            return t.sync.apply(this, arguments)
                        },
                        get: function(e) {
                            return this.attributes[e]
                        },
                        escape: function(e) {
                            return n.escape(this.get(e))
                        },
                        has: function(e) {
                            return null != this.get(e)
                        },
                        matches: function(e) {
                            return !!n.iteratee(e, this)(this.attributes)
                        },
                        set: function(e, t, i) {
                            if (null == e) return this;
                            var r;
                            if ("object" == typeof e ? (r = e, i = t) : (r = {})[e] = t, i || (i = {}), !this._validate(r, i)) return !1;
                            var o = i.unset,
                                a = i.silent,
                                s = [],
                                l = this._changing;
                            this._changing = !0, l || (this._previousAttributes = n.clone(this.attributes), this.changed = {});
                            var c = this.attributes,
                                h = this.changed,
                                u = this._previousAttributes;
                            for (var f in r) t = r[f], n.isEqual(c[f], t) || s.push(f), n.isEqual(u[f], t) ? delete h[f] : h[f] = t, o ? delete c[f] : c[f] = t;
                            if (this.idAttribute in r && (this.id = this.get(this.idAttribute)), !a) {
                                s.length && (this._pending = i);
                                for (var d = 0; d < s.length; d++) this.trigger("change:" + s[d], this, c[s[d]], i)
                            }
                            if (l) return this;
                            if (!a)
                                for (; this._pending;) i = this._pending, this._pending = !1, this.trigger("change", this, i);
                            return this._pending = !1, this._changing = !1, this
                        },
                        unset: function(e, t) {
                            return this.set(e, void 0, n.extend({}, t, {
                                unset: !0
                            }))
                        },
                        clear: function(e) {
                            var t = {};
                            for (var i in this.attributes) t[i] = void 0;
                            return this.set(t, n.extend({}, e, {
                                unset: !0
                            }))
                        },
                        hasChanged: function(e) {
                            return null == e ? !n.isEmpty(this.changed) : n.has(this.changed, e)
                        },
                        changedAttributes: function(e) {
                            if (!e) return this.hasChanged() ? n.clone(this.changed) : !1;
                            var t = this._changing ? this._previousAttributes : this.attributes,
                                i = {};
                            for (var r in e) {
                                var o = e[r];
                                n.isEqual(t[r], o) || (i[r] = o)
                            }
                            return n.size(i) ? i : !1
                        },
                        previous: function(e) {
                            return null != e && this._previousAttributes ? this._previousAttributes[e] : null
                        },
                        previousAttributes: function() {
                            return n.clone(this._previousAttributes)
                        },
                        fetch: function(e) {
                            e = n.extend({
                                parse: !0
                            }, e);
                            var t = this,
                                i = e.success;
                            return e.success = function(n) {
                                var r = e.parse ? t.parse(n, e) : n;
                                return t.set(r, e) ? (i && i.call(e.context, t, n, e), void t.trigger("sync", t, n, e)) : !1
                            }, z(this, e), this.sync("read", this, e)
                        },
                        save: function(e, t, i) {
                            var r;
                            null == e || "object" == typeof e ? (r = e, i = t) : (r = {})[e] = t, i = n.extend({
                                validate: !0,
                                parse: !0
                            }, i);
                            var o = i.wait;
                            if (r && !o) {
                                if (!this.set(r, i)) return !1
                            } else if (!this._validate(r, i)) return !1;
                            var a = this,
                                s = i.success,
                                l = this.attributes;
                            i.success = function(e) {
                                a.attributes = l;
                                var t = i.parse ? a.parse(e, i) : e;
                                return o && (t = n.extend({}, r, t)), t && !a.set(t, i) ? !1 : (s && s.call(i.context, a, e, i), void a.trigger("sync", a, e, i))
                            }, z(this, i), r && o && (this.attributes = n.extend({}, l, r));
                            var c = this.isNew() ? "create" : i.patch ? "patch" : "update";
                            "patch" !== c || i.attrs || (i.attrs = r);
                            var h = this.sync(c, this, i);
                            return this.attributes = l, h
                        },
                        destroy: function(e) {
                            e = e ? n.clone(e) : {};
                            var t = this,
                                i = e.success,
                                r = e.wait,
                                o = function() {
                                    t.stopListening(), t.trigger("destroy", t, t.collection, e)
                                };
                            e.success = function(n) {
                                r && o(), i && i.call(e.context, t, n, e), t.isNew() || t.trigger("sync", t, n, e)
                            };
                            var a = !1;
                            return this.isNew() ? n.defer(e.success) : (z(this, e), a = this.sync("delete", this, e)), r || o(), a
                        },
                        url: function() {
                            var e = n.result(this, "urlRoot") || n.result(this.collection, "url") || V();
                            if (this.isNew()) return e;
                            var t = this.get(this.idAttribute);
                            return e.replace(/[^\/]$/, "$&/") + encodeURIComponent(t)
                        },
                        parse: function(e, t) {
                            return e
                        },
                        clone: function() {
                            return new this.constructor(this.attributes)
                        },
                        isNew: function() {
                            return !this.has(this.idAttribute)
                        },
                        isValid: function(e) {
                            return this._validate({}, n.extend({}, e, {
                                validate: !0
                            }))
                        },
                        _validate: function(e, t) {
                            if (!t.validate || !this.validate) return !0;
                            e = n.extend({}, this.attributes, e);
                            var i = this.validationError = this.validate(e, t) || null;
                            return i ? (this.trigger("invalid", this, i, n.extend(t, {
                                validationError: i
                            })), !1) : !0
                        }
                    });
                    var w = {
                        keys: 1,
                        values: 1,
                        pairs: 1,
                        invert: 1,
                        pick: 0,
                        omit: 0,
                        chain: 1,
                        isEmpty: 1
                    };
                    s(x, w, "attributes");
                    var _ = t.Collection = function(e, t) {
                            t || (t = {}), t.model && (this.model = t.model), void 0 !== t.comparator && (this.comparator = t.comparator), this._reset(), this.initialize.apply(this, arguments), e && this.reset(e, n.extend({
                                silent: !0
                            }, t))
                        },
                        b = {
                            add: !0,
                            remove: !0,
                            merge: !0
                        },
                        E = {
                            add: !0,
                            remove: !1
                        },
                        M = function(e, t, n) {
                            n = Math.min(Math.max(n, 0), e.length);
                            var i, r = Array(e.length - n),
                                o = t.length;
                            for (i = 0; i < r.length; i++) r[i] = e[i + n];
                            for (i = 0; o > i; i++) e[i + n] = t[i];
                            for (i = 0; i < r.length; i++) e[i + o + n] = r[i]
                        };
                    n.extend(_.prototype, h, {
                        model: x,
                        initialize: function() {},
                        toJSON: function(e) {
                            return this.map(function(t) {
                                return t.toJSON(e)
                            })
                        },
                        sync: function() {
                            return t.sync.apply(this, arguments)
                        },
                        add: function(e, t) {
                            return this.set(e, n.extend({
                                merge: !1
                            }, t, E))
                        },
                        remove: function(e, t) {
                            t = n.extend({}, t);
                            var i = !n.isArray(e);
                            e = i ? [e] : e.slice();
                            var r = this._removeModels(e, t);
                            return !t.silent && r.length && (t.changes = {
                                added: [],
                                merged: [],
                                removed: r
                            }, this.trigger("update", this, t)), i ? r[0] : r
                        },
                        set: function(e, t) {
                            if (null != e) {
                                t = n.extend({}, b, t), t.parse && !this._isModel(e) && (e = this.parse(e, t) || []);
                                var i = !n.isArray(e);
                                e = i ? [e] : e.slice();
                                var r = t.at;
                                null != r && (r = +r), r > this.length && (r = this.length), 0 > r && (r += this.length + 1);
                                var o, a, s = [],
                                    l = [],
                                    c = [],
                                    h = [],
                                    u = {},
                                    f = t.add,
                                    d = t.merge,
                                    p = t.remove,
                                    m = !1,
                                    v = this.comparator && null == r && t.sort !== !1,
                                    g = n.isString(this.comparator) ? this.comparator : null;
                                for (a = 0; a < e.length; a++) {
                                    o = e[a];
                                    var y = this.get(o);
                                    if (y) {
                                        if (d && o !== y) {
                                            var x = this._isModel(o) ? o.attributes : o;
                                            t.parse && (x = y.parse(x, t)), y.set(x, t), c.push(y), v && !m && (m = y.hasChanged(g))
                                        }
                                        u[y.cid] || (u[y.cid] = !0, s.push(y)), e[a] = y
                                    } else f && (o = e[a] = this._prepareModel(o, t), o && (l.push(o), this._addReference(o, t), u[o.cid] = !0, s.push(o)))
                                }
                                if (p) {
                                    for (a = 0; a < this.length; a++) o = this.models[a], u[o.cid] || h.push(o);
                                    h.length && this._removeModels(h, t)
                                }
                                var w = !1,
                                    _ = !v && f && p;
                                if (s.length && _ ? (w = this.length !== s.length || n.some(this.models, function(e, t) {
                                        return e !== s[t]
                                    }), this.models.length = 0, M(this.models, s, 0), this.length = this.models.length) : l.length && (v && (m = !0), M(this.models, l, null == r ? this.length : r), this.length = this.models.length), m && this.sort({
                                        silent: !0
                                    }), !t.silent) {
                                    for (a = 0; a < l.length; a++) null != r && (t.index = r + a), o = l[a], o.trigger("add", o, this, t);
                                    (m || w) && this.trigger("sort", this, t), (l.length || h.length || c.length) && (t.changes = {
                                        added: l,
                                        removed: h,
                                        merged: c
                                    }, this.trigger("update", this, t))
                                }
                                return i ? e[0] : e
                            }
                        },
                        reset: function(e, t) {
                            t = t ? n.clone(t) : {};
                            for (var i = 0; i < this.models.length; i++) this._removeReference(this.models[i], t);
                            return t.previousModels = this.models, this._reset(), e = this.add(e, n.extend({
                                silent: !0
                            }, t)), t.silent || this.trigger("reset", this, t), e
                        },
                        push: function(e, t) {
                            return this.add(e, n.extend({
                                at: this.length
                            }, t))
                        },
                        pop: function(e) {
                            var t = this.at(this.length - 1);
                            return this.remove(t, e)
                        },
                        unshift: function(e, t) {
                            return this.add(e, n.extend({
                                at: 0
                            }, t))
                        },
                        shift: function(e) {
                            var t = this.at(0);
                            return this.remove(t, e)
                        },
                        slice: function() {
                            return o.apply(this.models, arguments)
                        },
                        get: function(e) {
                            return null != e ? this._byId[e] || this._byId[this.modelId(e.attributes || e)] || e.cid && this._byId[e.cid] : void 0
                        },
                        has: function(e) {
                            return null != this.get(e)
                        },
                        at: function(e) {
                            return 0 > e && (e += this.length), this.models[e]
                        },
                        where: function(e, t) {
                            return this[t ? "find" : "filter"](e)
                        },
                        findWhere: function(e) {
                            return this.where(e, !0)
                        },
                        sort: function(e) {
                            var t = this.comparator;
                            if (!t) throw new Error("Cannot sort a set without a comparator");
                            e || (e = {});
                            var i = t.length;
                            return n.isFunction(t) && (t = n.bind(t, this)), 1 === i || n.isString(t) ? this.models = this.sortBy(t) : this.models.sort(t), e.silent || this.trigger("sort", this, e), this
                        },
                        pluck: function(e) {
                            return this.map(e + "")
                        },
                        fetch: function(e) {
                            e = n.extend({
                                parse: !0
                            }, e);
                            var t = e.success,
                                i = this;
                            return e.success = function(n) {
                                var r = e.reset ? "reset" : "set";
                                i[r](n, e), t && t.call(e.context, i, n, e), i.trigger("sync", i, n, e)
                            }, z(this, e), this.sync("read", this, e)
                        },
                        create: function(e, t) {
                            t = t ? n.clone(t) : {};
                            var i = t.wait;
                            if (e = this._prepareModel(e, t), !e) return !1;
                            i || this.add(e, t);
                            var r = this,
                                o = t.success;
                            return t.success = function(e, t, n) {
                                i && r.add(e, n), o && o.call(n.context, e, t, n)
                            }, e.save(null, t), e
                        },
                        parse: function(e, t) {
                            return e
                        },
                        clone: function() {
                            return new this.constructor(this.models, {
                                model: this.model,
                                comparator: this.comparator
                            })
                        },
                        modelId: function(e) {
                            return e[this.model.prototype.idAttribute || "id"]
                        },
                        _reset: function() {
                            this.length = 0, this.models = [], this._byId = {}
                        },
                        _prepareModel: function(e, t) {
                            if (this._isModel(e)) return e.collection || (e.collection = this), e;
                            t = t ? n.clone(t) : {}, t.collection = this;
                            var i = new this.model(e, t);
                            return i.validationError ? (this.trigger("invalid", this, i.validationError, t), !1) : i
                        },
                        _removeModels: function(e, t) {
                            for (var n = [], i = 0; i < e.length; i++) {
                                var r = this.get(e[i]);
                                if (r) {
                                    var o = this.indexOf(r);
                                    this.models.splice(o, 1), this.length--, delete this._byId[r.cid];
                                    var a = this.modelId(r.attributes);
                                    null != a && delete this._byId[a], t.silent || (t.index = o, r.trigger("remove", r, this, t)), n.push(r), this._removeReference(r, t)
                                }
                            }
                            return n
                        },
                        _isModel: function(e) {
                            return e instanceof x
                        },
                        _addReference: function(e, t) {
                            this._byId[e.cid] = e;
                            var n = this.modelId(e.attributes);
                            null != n && (this._byId[n] = e), e.on("all", this._onModelEvent, this)
                        },
                        _removeReference: function(e, t) {
                            delete this._byId[e.cid];
                            var n = this.modelId(e.attributes);
                            null != n && delete this._byId[n], this === e.collection && delete e.collection, e.off("all", this._onModelEvent, this)
                        },
                        _onModelEvent: function(e, t, n, i) {
                            if (t) {
                                if (("add" === e || "remove" === e) && n !== this) return;
                                if ("destroy" === e && this.remove(t, i), "change" === e) {
                                    var r = this.modelId(t.previousAttributes()),
                                        o = this.modelId(t.attributes);
                                    r !== o && (null != r && delete this._byId[r], null != o && (this._byId[o] = t))
                                }
                            }
                            this.trigger.apply(this, arguments)
                        }
                    });
                    var S = {
                        forEach: 3,
                        each: 3,
                        map: 3,
                        collect: 3,
                        reduce: 0,
                        foldl: 0,
                        inject: 0,
                        reduceRight: 0,
                        foldr: 0,
                        find: 3,
                        detect: 3,
                        filter: 3,
                        select: 3,
                        reject: 3,
                        every: 3,
                        all: 3,
                        some: 3,
                        any: 3,
                        include: 3,
                        includes: 3,
                        contains: 3,
                        invoke: 0,
                        max: 3,
                        min: 3,
                        toArray: 1,
                        size: 1,
                        first: 3,
                        head: 3,
                        take: 3,
                        initial: 3,
                        rest: 3,
                        tail: 3,
                        drop: 3,
                        last: 3,
                        without: 0,
                        difference: 0,
                        indexOf: 3,
                        shuffle: 1,
                        lastIndexOf: 3,
                        isEmpty: 1,
                        chain: 1,
                        sample: 3,
                        partition: 3,
                        groupBy: 3,
                        countBy: 3,
                        sortBy: 3,
                        indexBy: 3,
                        findIndex: 3,
                        findLastIndex: 3
                    };
                    s(_, S, "models");
                    var T = t.View = function(e) {
                            this.cid = n.uniqueId("view"), n.extend(this, n.pick(e, A)), this._ensureElement(), this.initialize.apply(this, arguments)
                        },
                        C = /^(\S+)\s*(.*)$/,
                        A = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
                    n.extend(T.prototype, h, {
                        tagName: "div",
                        $: function(e) {
                            return this.$el.find(e)
                        },
                        initialize: function() {},
                        render: function() {
                            return this
                        },
                        remove: function() {
                            return this._removeElement(), this.stopListening(), this
                        },
                        _removeElement: function() {
                            this.$el.remove()
                        },
                        setElement: function(e) {
                            return this.undelegateEvents(), this._setElement(e), this.delegateEvents(), this
                        },
                        _setElement: function(e) {
                            this.$el = e instanceof t.$ ? e : t.$(e), this.el = this.$el[0]
                        },
                        delegateEvents: function(e) {
                            if (e || (e = n.result(this, "events")), !e) return this;
                            this.undelegateEvents();
                            for (var t in e) {
                                var i = e[t];
                                if (n.isFunction(i) || (i = this[i]), i) {
                                    var r = t.match(C);
                                    this.delegate(r[1], r[2], n.bind(i, this))
                                }
                            }
                            return this
                        },
                        delegate: function(e, t, n) {
                            return this.$el.on(e + ".delegateEvents" + this.cid, t, n), this
                        },
                        undelegateEvents: function() {
                            return this.$el && this.$el.off(".delegateEvents" + this.cid), this
                        },
                        undelegate: function(e, t, n) {
                            return this.$el.off(e + ".delegateEvents" + this.cid, t, n), this
                        },
                        _createElement: function(e) {
                            return document.createElement(e)
                        },
                        _ensureElement: function() {
                            if (this.el) this.setElement(n.result(this, "el"));
                            else {
                                var e = n.extend({}, n.result(this, "attributes"));
                                this.id && (e.id = n.result(this, "id")), this.className && (e["class"] = n.result(this, "className")), this.setElement(this._createElement(n.result(this, "tagName"))), this._setAttributes(e)
                            }
                        },
                        _setAttributes: function(e) {
                            this.$el.attr(e)
                        }
                    }), t.sync = function(e, i, r) {
                        var o = P[e];
                        n.defaults(r || (r = {}), {
                            emulateHTTP: t.emulateHTTP,
                            emulateJSON: t.emulateJSON
                        });
                        var a = {
                            type: o,
                            dataType: "json"
                        };
                        if (r.url || (a.url = n.result(i, "url") || V()), null != r.data || !i || "create" !== e && "update" !== e && "patch" !== e || (a.contentType = "application/json", a.data = JSON.stringify(r.attrs || i.toJSON(r))), r.emulateJSON && (a.contentType = "application/x-www-form-urlencoded", a.data = a.data ? {
                                model: a.data
                            } : {}), r.emulateHTTP && ("PUT" === o || "DELETE" === o || "PATCH" === o)) {
                            a.type = "POST", r.emulateJSON && (a.data._method = o);
                            var s = r.beforeSend;
                            r.beforeSend = function(e) {
                                return e.setRequestHeader("X-HTTP-Method-Override", o), s ? s.apply(this, arguments) : void 0
                            }
                        }
                        "GET" === a.type || r.emulateJSON || (a.processData = !1);
                        var l = r.error;
                        r.error = function(e, t, n) {
                            r.textStatus = t, r.errorThrown = n, l && l.call(r.context, e, t, n)
                        };
                        var c = r.xhr = t.ajax(n.extend(a, r));
                        return i.trigger("request", i, c, r), c
                    };
                    var P = {
                        create: "POST",
                        update: "PUT",
                        patch: "PATCH",
                        "delete": "DELETE",
                        read: "GET"
                    };
                    t.ajax = function() {
                        return t.$.ajax.apply(t.$, arguments)
                    };
                    var D = t.Router = function(e) {
                            e || (e = {}), e.routes && (this.routes = e.routes), this._bindRoutes(), this.initialize.apply(this, arguments)
                        },
                        L = /\((.*?)\)/g,
                        R = /(\(\?)?:\w+/g,
                        O = /\*\w+/g,
                        N = /[\-{}\[\]+?.,\\\^$|#\s]/g;
                    n.extend(D.prototype, h, {
                        initialize: function() {},
                        route: function(e, i, r) {
                            n.isRegExp(e) || (e = this._routeToRegExp(e)), n.isFunction(i) && (r = i, i = ""), r || (r = this[i]);
                            var o = this;
                            return t.history.route(e, function(n) {
                                var a = o._extractParameters(e, n);
                                o.execute(r, a, i) !== !1 && (o.trigger.apply(o, ["route:" + i].concat(a)), o.trigger("route", i, a), t.history.trigger("route", o, i, a))
                            }), this
                        },
                        execute: function(e, t, n) {
                            e && e.apply(this, t)
                        },
                        navigate: function(e, n) {
                            return t.history.navigate(e, n), this
                        },
                        _bindRoutes: function() {
                            if (this.routes) {
                                this.routes = n.result(this, "routes");
                                for (var e, t = n.keys(this.routes); null != (e = t.pop());) this.route(e, this.routes[e])
                            }
                        },
                        _routeToRegExp: function(e) {
                            return e = e.replace(N, "\\$&").replace(L, "(?:$1)?").replace(R, function(e, t) {
                                return t ? e : "([^/?]+)"
                            }).replace(O, "([^?]*?)"), new RegExp("^" + e + "(?:\\?([\\s\\S]*))?$")
                        },
                        _extractParameters: function(e, t) {
                            var i = e.exec(t).slice(1);
                            return n.map(i, function(e, t) {
                                return t === i.length - 1 ? e || null : e ? decodeURIComponent(e) : null
                            })
                        }
                    });
                    var U = t.History = function() {
                            this.handlers = [], this.checkUrl = n.bind(this.checkUrl, this), "undefined" != typeof window && (this.location = window.location, this.history = window.history)
                        },
                        F = /^[#\/]|\s+$/g,
                        k = /^\/+|\/+$/g,
                        H = /#.*$/;
                    U.started = !1, n.extend(U.prototype, h, {
                        interval: 50,
                        atRoot: function() {
                            var e = this.location.pathname.replace(/[^\/]$/, "$&/");
                            return e === this.root && !this.getSearch()
                        },
                        matchRoot: function() {
                            var e = this.decodeFragment(this.location.pathname),
                                t = e.slice(0, this.root.length - 1) + "/";
                            return t === this.root
                        },
                        decodeFragment: function(e) {
                            return decodeURI(e.replace(/%25/g, "%2525"))
                        },
                        getSearch: function() {
                            var e = this.location.href.replace(/#.*/, "").match(/\?.+/);
                            return e ? e[0] : ""
                        },
                        getHash: function(e) {
                            var t = (e || this).location.href.match(/#(.*)$/);
                            return t ? t[1] : ""
                        },
                        getPath: function() {
                            var e = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
                            return "/" === e.charAt(0) ? e.slice(1) : e
                        },
                        getFragment: function(e) {
                            return null == e && (e = this._usePushState || !this._wantsHashChange ? this.getPath() : this.getHash()), e.replace(F, "")
                        },
                        start: function(e) {
                            if (U.started) throw new Error("Backbone.history has already been started");
                            if (U.started = !0, this.options = n.extend({
                                    root: "/"
                                }, this.options, e), this.root = this.options.root, this._wantsHashChange = this.options.hashChange !== !1, this._hasHashChange = "onhashchange" in window && (void 0 === document.documentMode || document.documentMode > 7), this._useHashChange = this._wantsHashChange && this._hasHashChange, this._wantsPushState = !!this.options.pushState, this._hasPushState = !(!this.history || !this.history.pushState), this._usePushState = this._wantsPushState && this._hasPushState, this.fragment = this.getFragment(), this.root = ("/" + this.root + "/").replace(k, "/"), this._wantsHashChange && this._wantsPushState) {
                                if (!this._hasPushState && !this.atRoot()) {
                                    var t = this.root.slice(0, -1) || "/";
                                    return this.location.replace(t + "#" + this.getPath()), !0
                                }
                                this._hasPushState && this.atRoot() && this.navigate(this.getHash(), {
                                    replace: !0
                                })
                            }
                            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                                this.iframe = document.createElement("iframe"), this.iframe.src = "javascript:0", this.iframe.style.display = "none", this.iframe.tabIndex = -1;
                                var i = document.body,
                                    r = i.insertBefore(this.iframe, i.firstChild).contentWindow;
                                r.document.open(), r.document.close(), r.location.hash = "#" + this.fragment
                            }
                            var o = window.addEventListener || function(e, t) {
                                    return attachEvent("on" + e, t)
                                };
                            return this._usePushState ? o("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe ? o("hashchange", this.checkUrl, !1) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), this.options.silent ? void 0 : this.loadUrl()
                        },
                        stop: function() {
                            var e = window.removeEventListener || function(e, t) {
                                    return detachEvent("on" + e, t)
                                };
                            this._usePushState ? e("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe && e("hashchange", this.checkUrl, !1), this.iframe && (document.body.removeChild(this.iframe), this.iframe = null), this._checkUrlInterval && clearInterval(this._checkUrlInterval), U.started = !1
                        },
                        route: function(e, t) {
                            this.handlers.unshift({
                                route: e,
                                callback: t
                            })
                        },
                        checkUrl: function(e) {
                            var t = this.getFragment();
                            return t === this.fragment && this.iframe && (t = this.getHash(this.iframe.contentWindow)), t === this.fragment ? !1 : (this.iframe && this.navigate(t), void this.loadUrl())
                        },
                        loadUrl: function(e) {
                            return this.matchRoot() ? (e = this.fragment = this.getFragment(e), n.some(this.handlers, function(t) {
                                return t.route.test(e) ? (t.callback(e), !0) : void 0
                            })) : !1
                        },
                        navigate: function(e, t) {
                            if (!U.started) return !1;
                            t && t !== !0 || (t = {
                                trigger: !!t
                            }), e = this.getFragment(e || "");
                            var n = this.root;
                            "" !== e && "?" !== e.charAt(0) || (n = n.slice(0, -1) || "/");
                            var i = n + e;
                            if (e = this.decodeFragment(e.replace(H, "")), this.fragment !== e) {
                                if (this.fragment = e, this._usePushState) this.history[t.replace ? "replaceState" : "pushState"]({}, document.title, i);
                                else {
                                    if (!this._wantsHashChange) return this.location.assign(i);
                                    if (this._updateHash(this.location, e, t.replace), this.iframe && e !== this.getHash(this.iframe.contentWindow)) {
                                        var r = this.iframe.contentWindow;
                                        t.replace || (r.document.open(), r.document.close()), this._updateHash(r.location, e, t.replace)
                                    }
                                }
                                return t.trigger ? this.loadUrl(e) : void 0
                            }
                        },
                        _updateHash: function(e, t, n) {
                            if (n) {
                                var i = e.href.replace(/(javascript:|#).*$/, "");
                                e.replace(i + "#" + t)
                            } else e.hash = "#" + t
                        }
                    }), t.history = new U;
                    var I = function(e, t) {
                        var i, r = this;
                        return i = e && n.has(e, "constructor") ? e.constructor : function() {
                            return r.apply(this, arguments)
                        }, n.extend(i, r, t), i.prototype = n.create(r.prototype, e), i.prototype.constructor = i, i.__super__ = r.prototype, i
                    };
                    x.extend = _.extend = D.extend = T.extend = U.extend = I;
                    var V = function() {
                            throw new Error('A "url" property or function must be specified')
                        },
                        z = function(e, t) {
                            var n = t.error;
                            t.error = function(i) {
                                n && n.call(t.context, e, i, t), e.trigger("error", e, i, t)
                            }
                        };
                    return t
                })
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {
            4: 4,
            7: 7
        }
    ],
    3: [
        function(e, t, n) {
            ! function(e, n, i, r) {
                "use strict";

                function o(e, t, n) {
                    return setTimeout(h(e, n), t)
                }

                function a(e, t, n) {
                    return Array.isArray(e) ? (s(e, n[t], n), !0) : !1
                }

                function s(e, t, n) {
                    var i;
                    if (e)
                        if (e.forEach) e.forEach(t, n);
                        else if (e.length !== r)
                            for (i = 0; i < e.length;) t.call(n, e[i], i, e), i++;
                        else
                            for (i in e) e.hasOwnProperty(i) && t.call(n, e[i], i, e)
                }

                function l(t, n, i) {
                    var r = "DEPRECATED METHOD: " + n + "\n" + i + " AT \n";
                    return function() {
                        var n = new Error("get-stack-trace"),
                            i = n && n.stack ? n.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                            o = e.console && (e.console.warn || e.console.log);
                        return o && o.call(e.console, r, i), t.apply(this, arguments)
                    }
                }

                function c(e, t, n) {
                    var i, r = t.prototype;
                    i = e.prototype = Object.create(r), i.constructor = e, i._super = r, n && fe(i, n)
                }

                function h(e, t) {
                    return function() {
                        return e.apply(t, arguments)
                    }
                }

                function u(e, t) {
                    return typeof e == me ? e.apply(t ? t[0] || r : r, t) : e
                }

                function f(e, t) {
                    return e === r ? t : e
                }

                function d(e, t, n) {
                    s(g(t), function(t) {
                        e.addEventListener(t, n, !1)
                    })
                }

                function p(e, t, n) {
                    s(g(t), function(t) {
                        e.removeEventListener(t, n, !1)
                    })
                }

                function m(e, t) {
                    for (; e;) {
                        if (e == t) return !0;
                        e = e.parentNode
                    }
                    return !1
                }

                function v(e, t) {
                    return e.indexOf(t) > -1
                }

                function g(e) {
                    return e.trim().split(/\s+/g)
                }

                function y(e, t, n) {
                    if (e.indexOf && !n) return e.indexOf(t);
                    for (var i = 0; i < e.length;) {
                        if (n && e[i][n] == t || !n && e[i] === t) return i;
                        i++
                    }
                    return -1
                }

                function x(e) {
                    return Array.prototype.slice.call(e, 0)
                }

                function w(e, t, n) {
                    for (var i = [], r = [], o = 0; o < e.length;) {
                        var a = t ? e[o][t] : e[o];
                        y(r, a) < 0 && i.push(e[o]), r[o] = a, o++
                    }
                    return n && (i = t ? i.sort(function(e, n) {
                        return e[t] > n[t]
                    }) : i.sort()), i
                }

                function _(e, t) {
                    for (var n, i, o = t[0].toUpperCase() + t.slice(1), a = 0; a < de.length;) {
                        if (n = de[a], i = n ? n + o : t, i in e) return i;
                        a++
                    }
                    return r
                }

                function b() {
                    return _e++
                }

                function E(t) {
                    var n = t.ownerDocument || t;
                    return n.defaultView || n.parentWindow || e
                }

                function M(e, t) {
                    var n = this;
                    this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function(t) {
                        u(e.options.enable, [e]) && n.handler(t)
                    }, this.init()
                }

                function S(e) {
                    var t, n = e.options.inputClass;
                    return new(t = n ? n : Me ? I : Se ? B : Ee ? G : H)(e, T)
                }

                function T(e, t, n) {
                    var i = n.pointers.length,
                        r = n.changedPointers.length,
                        o = t & Le && i - r === 0,
                        a = t & (Oe | Ne) && i - r === 0;
                    n.isFirst = !!o, n.isFinal = !!a, o && (e.session = {}), n.eventType = t, C(e, n), e.emit("hammer.input", n), e.recognize(n), e.session.prevInput = n
                }

                function C(e, t) {
                    var n = e.session,
                        i = t.pointers,
                        r = i.length;
                    n.firstInput || (n.firstInput = D(t)), r > 1 && !n.firstMultiple ? n.firstMultiple = D(t) : 1 === r && (n.firstMultiple = !1);
                    var o = n.firstInput,
                        a = n.firstMultiple,
                        s = a ? a.center : o.center,
                        l = t.center = L(i);
                    t.timeStamp = ye(), t.deltaTime = t.timeStamp - o.timeStamp, t.angle = U(s, l), t.distance = N(s, l), A(n, t), t.offsetDirection = O(t.deltaX, t.deltaY);
                    var c = R(t.deltaTime, t.deltaX, t.deltaY);
                    t.overallVelocityX = c.x, t.overallVelocityY = c.y, t.overallVelocity = ge(c.x) > ge(c.y) ? c.x : c.y, t.scale = a ? k(a.pointers, i) : 1, t.rotation = a ? F(a.pointers, i) : 0, t.maxPointers = n.prevInput ? t.pointers.length > n.prevInput.maxPointers ? t.pointers.length : n.prevInput.maxPointers : t.pointers.length, P(n, t);
                    var h = e.element;
                    m(t.srcEvent.target, h) && (h = t.srcEvent.target), t.target = h
                }

                function A(e, t) {
                    var n = t.center,
                        i = e.offsetDelta || {},
                        r = e.prevDelta || {},
                        o = e.prevInput || {};
                    t.eventType !== Le && o.eventType !== Oe || (r = e.prevDelta = {
                        x: o.deltaX || 0,
                        y: o.deltaY || 0
                    }, i = e.offsetDelta = {
                        x: n.x,
                        y: n.y
                    }), t.deltaX = r.x + (n.x - i.x), t.deltaY = r.y + (n.y - i.y)
                }

                function P(e, t) {
                    var n, i, o, a, s = e.lastInterval || t,
                        l = t.timeStamp - s.timeStamp;
                    if (t.eventType != Ne && (l > De || s.velocity === r)) {
                        var c = t.deltaX - s.deltaX,
                            h = t.deltaY - s.deltaY,
                            u = R(l, c, h);
                        i = u.x, o = u.y, n = ge(u.x) > ge(u.y) ? u.x : u.y, a = O(c, h), e.lastInterval = t
                    } else n = s.velocity, i = s.velocityX, o = s.velocityY, a = s.direction;
                    t.velocity = n, t.velocityX = i, t.velocityY = o, t.direction = a
                }

                function D(e) {
                    for (var t = [], n = 0; n < e.pointers.length;) t[n] = {
                        clientX: ve(e.pointers[n].clientX),
                        clientY: ve(e.pointers[n].clientY)
                    }, n++;
                    return {
                        timeStamp: ye(),
                        pointers: t,
                        center: L(t),
                        deltaX: e.deltaX,
                        deltaY: e.deltaY
                    }
                }

                function L(e) {
                    var t = e.length;
                    if (1 === t) return {
                        x: ve(e[0].clientX),
                        y: ve(e[0].clientY)
                    };
                    for (var n = 0, i = 0, r = 0; t > r;) n += e[r].clientX, i += e[r].clientY, r++;
                    return {
                        x: ve(n / t),
                        y: ve(i / t)
                    }
                }

                function R(e, t, n) {
                    return {
                        x: t / e || 0,
                        y: n / e || 0
                    }
                }

                function O(e, t) {
                    return e === t ? Ue : ge(e) >= ge(t) ? 0 > e ? Fe : ke : 0 > t ? He : Ie
                }

                function N(e, t, n) {
                    n || (n = je);
                    var i = t[n[0]] - e[n[0]],
                        r = t[n[1]] - e[n[1]];
                    return Math.sqrt(i * i + r * r)
                }

                function U(e, t, n) {
                    n || (n = je);
                    var i = t[n[0]] - e[n[0]],
                        r = t[n[1]] - e[n[1]];
                    return 180 * Math.atan2(r, i) / Math.PI
                }

                function F(e, t) {
                    return U(t[1], t[0], Ge) + U(e[1], e[0], Ge)
                }

                function k(e, t) {
                    return N(t[0], t[1], Ge) / N(e[0], e[1], Ge)
                }

                function H() {
                    this.evEl = Xe, this.evWin = qe, this.pressed = !1, M.apply(this, arguments)
                }

                function I() {
                    this.evEl = $e, this.evWin = Je, M.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
                }

                function V() {
                    this.evTarget = Qe, this.evWin = et, this.started = !1, M.apply(this, arguments)
                }

                function z(e, t) {
                    var n = x(e.touches),
                        i = x(e.changedTouches);
                    return t & (Oe | Ne) && (n = w(n.concat(i), "identifier", !0)), [n, i]
                }

                function B() {
                    this.evTarget = nt, this.targetIds = {}, M.apply(this, arguments)
                }

                function j(e, t) {
                    var n = x(e.touches),
                        i = this.targetIds;
                    if (t & (Le | Re) && 1 === n.length) return i[n[0].identifier] = !0, [n, n];
                    var r, o, a = x(e.changedTouches),
                        s = [],
                        l = this.target;
                    if (o = n.filter(function(e) {
                            return m(e.target, l)
                        }), t === Le)
                        for (r = 0; r < o.length;) i[o[r].identifier] = !0, r++;
                    for (r = 0; r < a.length;) i[a[r].identifier] && s.push(a[r]), t & (Oe | Ne) && delete i[a[r].identifier], r++;
                    return s.length ? [w(o.concat(s), "identifier", !0), s] : void 0
                }

                function G() {
                    M.apply(this, arguments);
                    var e = h(this.handler, this);
                    this.touch = new B(this.manager, e), this.mouse = new H(this.manager, e), this.primaryTouch = null, this.lastTouches = []
                }

                function W(e, t) {
                    e & Le ? (this.primaryTouch = t.changedPointers[0].identifier, X.call(this, t)) : e & (Oe | Ne) && X.call(this, t)
                }

                function X(e) {
                    var t = e.changedPointers[0];
                    if (t.identifier === this.primaryTouch) {
                        var n = {
                            x: t.clientX,
                            y: t.clientY
                        };
                        this.lastTouches.push(n);
                        var i = this.lastTouches,
                            r = function() {
                                var e = i.indexOf(n);
                                e > -1 && i.splice(e, 1)
                            };
                        setTimeout(r, it)
                    }
                }

                function q(e) {
                    for (var t = e.srcEvent.clientX, n = e.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) {
                        var r = this.lastTouches[i],
                            o = Math.abs(t - r.x),
                            a = Math.abs(n - r.y);
                        if (rt >= o && rt >= a) return !0
                    }
                    return !1
                }

                function K(e, t) {
                    this.manager = e, this.set(t)
                }

                function Y(e) {
                    if (v(e, ht)) return ht;
                    var t = v(e, ut),
                        n = v(e, ft);
                    return t && n ? ht : t || n ? t ? ut : ft : v(e, ct) ? ct : lt
                }

                function $() {
                    if (!at) return !1;
                    var t = {},
                        n = e.CSS && e.CSS.supports;
                    return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(i) {
                        t[i] = n ? e.CSS.supports("touch-action", i) : !0
                    }), t
                }

                function J(e) {
                    this.options = fe({}, this.defaults, e || {}), this.id = b(), this.manager = null, this.options.enable = f(this.options.enable, !0), this.state = pt, this.simultaneous = {}, this.requireFail = []
                }

                function Z(e) {
                    return e & xt ? "cancel" : e & gt ? "end" : e & vt ? "move" : e & mt ? "start" : ""
                }

                function Q(e) {
                    return e == Ie ? "down" : e == He ? "up" : e == Fe ? "left" : e == ke ? "right" : ""
                }

                function ee(e, t) {
                    var n = t.manager;
                    return n ? n.get(e) : e
                }

                function te() {
                    J.apply(this, arguments)
                }

                function ne() {
                    te.apply(this, arguments), this.pX = null, this.pY = null
                }

                function ie() {
                    te.apply(this, arguments)
                }

                function re() {
                    J.apply(this, arguments), this._timer = null, this._input = null
                }

                function oe() {
                    te.apply(this, arguments)
                }

                function ae() {
                    te.apply(this, arguments)
                }

                function se() {
                    J.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
                }

                function le(e, t) {
                    return t = t || {}, t.recognizers = f(t.recognizers, le.defaults.preset), new ce(e, t)
                }

                function ce(e, t) {
                    this.options = fe({}, le.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = S(this), this.touchAction = new K(this, this.options.touchAction), he(this, !0), s(this.options.recognizers, function(e) {
                        var t = this.add(new e[0](e[1]));
                        e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3])
                    }, this)
                }

                function he(e, t) {
                    var n = e.element;
                    if (n.style) {
                        var i;
                        s(e.options.cssProps, function(r, o) {
                            i = _(n.style, o), t ? (e.oldCssProps[i] = n.style[i], n.style[i] = r) : n.style[i] = e.oldCssProps[i] || ""
                        }), t || (e.oldCssProps = {})
                    }
                }

                function ue(e, t) {
                    var i = n.createEvent("Event");
                    i.initEvent(e, !0, !0), i.gesture = t, t.target.dispatchEvent(i)
                }
                var fe, de = ["", "webkit", "Moz", "MS", "ms", "o"],
                    pe = n.createElement("div"),
                    me = "function",
                    ve = Math.round,
                    ge = Math.abs,
                    ye = Date.now;
                fe = "function" != typeof Object.assign ? function(e) {
                    if (e === r || null === e) throw new TypeError("Cannot convert undefined or null to object");
                    for (var t = Object(e), n = 1; n < arguments.length; n++) {
                        var i = arguments[n];
                        if (i !== r && null !== i)
                            for (var o in i) i.hasOwnProperty(o) && (t[o] = i[o])
                    }
                    return t
                } : Object.assign;
                var xe = l(function(e, t, n) {
                        for (var i = Object.keys(t), o = 0; o < i.length;)(!n || n && e[i[o]] === r) && (e[i[o]] = t[i[o]]),
                            o++;
                        return e
                    }, "extend", "Use `assign`."),
                    we = l(function(e, t) {
                        return xe(e, t, !0)
                    }, "merge", "Use `assign`."),
                    _e = 1,
                    be = /mobile|tablet|ip(ad|hone|od)|android/i,
                    Ee = "ontouchstart" in e,
                    Me = _(e, "PointerEvent") !== r,
                    Se = Ee && be.test(navigator.userAgent),
                    Te = "touch",
                    Ce = "pen",
                    Ae = "mouse",
                    Pe = "kinect",
                    De = 25,
                    Le = 1,
                    Re = 2,
                    Oe = 4,
                    Ne = 8,
                    Ue = 1,
                    Fe = 2,
                    ke = 4,
                    He = 8,
                    Ie = 16,
                    Ve = Fe | ke,
                    ze = He | Ie,
                    Be = Ve | ze,
                    je = ["x", "y"],
                    Ge = ["clientX", "clientY"];
                M.prototype = {
                    handler: function() {},
                    init: function() {
                        this.evEl && d(this.element, this.evEl, this.domHandler), this.evTarget && d(this.target, this.evTarget, this.domHandler), this.evWin && d(E(this.element), this.evWin, this.domHandler)
                    },
                    destroy: function() {
                        this.evEl && p(this.element, this.evEl, this.domHandler), this.evTarget && p(this.target, this.evTarget, this.domHandler), this.evWin && p(E(this.element), this.evWin, this.domHandler)
                    }
                };
                var We = {
                        mousedown: Le,
                        mousemove: Re,
                        mouseup: Oe
                    },
                    Xe = "mousedown",
                    qe = "mousemove mouseup";
                c(H, M, {
                    handler: function(e) {
                        var t = We[e.type];
                        t & Le && 0 === e.button && (this.pressed = !0), t & Re && 1 !== e.which && (t = Oe), this.pressed && (t & Oe && (this.pressed = !1), this.callback(this.manager, t, {
                            pointers: [e],
                            changedPointers: [e],
                            pointerType: Ae,
                            srcEvent: e
                        }))
                    }
                });
                var Ke = {
                        pointerdown: Le,
                        pointermove: Re,
                        pointerup: Oe,
                        pointercancel: Ne,
                        pointerout: Ne
                    },
                    Ye = {
                        2: Te,
                        3: Ce,
                        4: Ae,
                        5: Pe
                    },
                    $e = "pointerdown",
                    Je = "pointermove pointerup pointercancel";
                e.MSPointerEvent && !e.PointerEvent && ($e = "MSPointerDown", Je = "MSPointerMove MSPointerUp MSPointerCancel"), c(I, M, {
                    handler: function(e) {
                        var t = this.store,
                            n = !1,
                            i = e.type.toLowerCase().replace("ms", ""),
                            r = Ke[i],
                            o = Ye[e.pointerType] || e.pointerType,
                            a = o == Te,
                            s = y(t, e.pointerId, "pointerId");
                        r & Le && (0 === e.button || a) ? 0 > s && (t.push(e), s = t.length - 1) : r & (Oe | Ne) && (n = !0), 0 > s || (t[s] = e, this.callback(this.manager, r, {
                            pointers: t,
                            changedPointers: [e],
                            pointerType: o,
                            srcEvent: e
                        }), n && t.splice(s, 1))
                    }
                });
                var Ze = {
                        touchstart: Le,
                        touchmove: Re,
                        touchend: Oe,
                        touchcancel: Ne
                    },
                    Qe = "touchstart",
                    et = "touchstart touchmove touchend touchcancel";
                c(V, M, {
                    handler: function(e) {
                        var t = Ze[e.type];
                        if (t === Le && (this.started = !0), this.started) {
                            var n = z.call(this, e, t);
                            t & (Oe | Ne) && n[0].length - n[1].length === 0 && (this.started = !1), this.callback(this.manager, t, {
                                pointers: n[0],
                                changedPointers: n[1],
                                pointerType: Te,
                                srcEvent: e
                            })
                        }
                    }
                });
                var tt = {
                        touchstart: Le,
                        touchmove: Re,
                        touchend: Oe,
                        touchcancel: Ne
                    },
                    nt = "touchstart touchmove touchend touchcancel";
                c(B, M, {
                    handler: function(e) {
                        var t = tt[e.type],
                            n = j.call(this, e, t);
                        n && this.callback(this.manager, t, {
                            pointers: n[0],
                            changedPointers: n[1],
                            pointerType: Te,
                            srcEvent: e
                        })
                    }
                });
                var it = 2500,
                    rt = 25;
                c(G, M, {
                    handler: function(e, t, n) {
                        var i = n.pointerType == Te,
                            r = n.pointerType == Ae;
                        if (!(r && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) {
                            if (i) W.call(this, t, n);
                            else if (r && q.call(this, n)) return;
                            this.callback(e, t, n)
                        }
                    },
                    destroy: function() {
                        this.touch.destroy(), this.mouse.destroy()
                    }
                });
                var ot = _(pe.style, "touchAction"),
                    at = ot !== r,
                    st = "compute",
                    lt = "auto",
                    ct = "manipulation",
                    ht = "none",
                    ut = "pan-x",
                    ft = "pan-y",
                    dt = $();
                K.prototype = {
                    set: function(e) {
                        e == st && (e = this.compute()), at && this.manager.element.style && dt[e] && (this.manager.element.style[ot] = e), this.actions = e.toLowerCase().trim()
                    },
                    update: function() {
                        this.set(this.manager.options.touchAction)
                    },
                    compute: function() {
                        var e = [];
                        return s(this.manager.recognizers, function(t) {
                            u(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
                        }), Y(e.join(" "))
                    },
                    preventDefaults: function(e) {
                        var t = e.srcEvent,
                            n = e.offsetDirection;
                        if (this.manager.session.prevented) return void t.preventDefault();
                        var i = this.actions,
                            r = v(i, ht) && !dt[ht],
                            o = v(i, ft) && !dt[ft],
                            a = v(i, ut) && !dt[ut];
                        if (r) {
                            var s = 1 === e.pointers.length,
                                l = e.distance < 2,
                                c = e.deltaTime < 250;
                            if (s && l && c) return
                        }
                        return a && o ? void 0 : r || o && n & Ve || a && n & ze ? this.preventSrc(t) : void 0
                    },
                    preventSrc: function(e) {
                        this.manager.session.prevented = !0, e.preventDefault()
                    }
                };
                var pt = 1,
                    mt = 2,
                    vt = 4,
                    gt = 8,
                    yt = gt,
                    xt = 16,
                    wt = 32;
                J.prototype = {
                    defaults: {},
                    set: function(e) {
                        return fe(this.options, e), this.manager && this.manager.touchAction.update(), this
                    },
                    recognizeWith: function(e) {
                        if (a(e, "recognizeWith", this)) return this;
                        var t = this.simultaneous;
                        return e = ee(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this
                    },
                    dropRecognizeWith: function(e) {
                        return a(e, "dropRecognizeWith", this) ? this : (e = ee(e, this), delete this.simultaneous[e.id], this)
                    },
                    requireFailure: function(e) {
                        if (a(e, "requireFailure", this)) return this;
                        var t = this.requireFail;
                        return e = ee(e, this), -1 === y(t, e) && (t.push(e), e.requireFailure(this)), this
                    },
                    dropRequireFailure: function(e) {
                        if (a(e, "dropRequireFailure", this)) return this;
                        e = ee(e, this);
                        var t = y(this.requireFail, e);
                        return t > -1 && this.requireFail.splice(t, 1), this
                    },
                    hasRequireFailures: function() {
                        return this.requireFail.length > 0
                    },
                    canRecognizeWith: function(e) {
                        return !!this.simultaneous[e.id]
                    },
                    emit: function(e) {
                        function t(t) {
                            n.manager.emit(t, e)
                        }
                        var n = this,
                            i = this.state;
                        gt > i && t(n.options.event + Z(i)), t(n.options.event), e.additionalEvent && t(e.additionalEvent), i >= gt && t(n.options.event + Z(i))
                    },
                    tryEmit: function(e) {
                        return this.canEmit() ? this.emit(e) : void(this.state = wt)
                    },
                    canEmit: function() {
                        for (var e = 0; e < this.requireFail.length;) {
                            if (!(this.requireFail[e].state & (wt | pt))) return !1;
                            e++
                        }
                        return !0
                    },
                    recognize: function(e) {
                        var t = fe({}, e);
                        return u(this.options.enable, [this, t]) ? (this.state & (yt | xt | wt) && (this.state = pt), this.state = this.process(t), void(this.state & (mt | vt | gt | xt) && this.tryEmit(t))) : (this.reset(), void(this.state = wt))
                    },
                    process: function(e) {},
                    getTouchAction: function() {},
                    reset: function() {}
                }, c(te, J, {
                    defaults: {
                        pointers: 1
                    },
                    attrTest: function(e) {
                        var t = this.options.pointers;
                        return 0 === t || e.pointers.length === t
                    },
                    process: function(e) {
                        var t = this.state,
                            n = e.eventType,
                            i = t & (mt | vt),
                            r = this.attrTest(e);
                        return i && (n & Ne || !r) ? t | xt : i || r ? n & Oe ? t | gt : t & mt ? t | vt : mt : wt
                    }
                }), c(ne, te, {
                    defaults: {
                        event: "pan",
                        threshold: 10,
                        pointers: 1,
                        direction: Be
                    },
                    getTouchAction: function() {
                        var e = this.options.direction,
                            t = [];
                        return e & Ve && t.push(ft), e & ze && t.push(ut), t
                    },
                    directionTest: function(e) {
                        var t = this.options,
                            n = !0,
                            i = e.distance,
                            r = e.direction,
                            o = e.deltaX,
                            a = e.deltaY;
                        return r & t.direction || (t.direction & Ve ? (r = 0 === o ? Ue : 0 > o ? Fe : ke, n = o != this.pX, i = Math.abs(e.deltaX)) : (r = 0 === a ? Ue : 0 > a ? He : Ie, n = a != this.pY, i = Math.abs(e.deltaY))), e.direction = r, n && i > t.threshold && r & t.direction
                    },
                    attrTest: function(e) {
                        return te.prototype.attrTest.call(this, e) && (this.state & mt || !(this.state & mt) && this.directionTest(e))
                    },
                    emit: function(e) {
                        this.pX = e.deltaX, this.pY = e.deltaY;
                        var t = Q(e.direction);
                        t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e)
                    }
                }), c(ie, te, {
                    defaults: {
                        event: "pinch",
                        threshold: 0,
                        pointers: 2
                    },
                    getTouchAction: function() {
                        return [ht]
                    },
                    attrTest: function(e) {
                        return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & mt)
                    },
                    emit: function(e) {
                        if (1 !== e.scale) {
                            var t = e.scale < 1 ? "in" : "out";
                            e.additionalEvent = this.options.event + t
                        }
                        this._super.emit.call(this, e)
                    }
                }), c(re, J, {
                    defaults: {
                        event: "press",
                        pointers: 1,
                        time: 251,
                        threshold: 9
                    },
                    getTouchAction: function() {
                        return [lt]
                    },
                    process: function(e) {
                        var t = this.options,
                            n = e.pointers.length === t.pointers,
                            i = e.distance < t.threshold,
                            r = e.deltaTime > t.time;
                        if (this._input = e, !i || !n || e.eventType & (Oe | Ne) && !r) this.reset();
                        else if (e.eventType & Le) this.reset(), this._timer = o(function() {
                            this.state = yt, this.tryEmit()
                        }, t.time, this);
                        else if (e.eventType & Oe) return yt;
                        return wt
                    },
                    reset: function() {
                        clearTimeout(this._timer)
                    },
                    emit: function(e) {
                        this.state === yt && (e && e.eventType & Oe ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = ye(), this.manager.emit(this.options.event, this._input)))
                    }
                }), c(oe, te, {
                    defaults: {
                        event: "rotate",
                        threshold: 0,
                        pointers: 2
                    },
                    getTouchAction: function() {
                        return [ht]
                    },
                    attrTest: function(e) {
                        return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & mt)
                    }
                }), c(ae, te, {
                    defaults: {
                        event: "swipe",
                        threshold: 10,
                        velocity: .3,
                        direction: Ve | ze,
                        pointers: 1
                    },
                    getTouchAction: function() {
                        return ne.prototype.getTouchAction.call(this)
                    },
                    attrTest: function(e) {
                        var t, n = this.options.direction;
                        return n & (Ve | ze) ? t = e.overallVelocity : n & Ve ? t = e.overallVelocityX : n & ze && (t = e.overallVelocityY), this._super.attrTest.call(this, e) && n & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && ge(t) > this.options.velocity && e.eventType & Oe
                    },
                    emit: function(e) {
                        var t = Q(e.offsetDirection);
                        t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e)
                    }
                }), c(se, J, {
                    defaults: {
                        event: "tap",
                        pointers: 1,
                        taps: 1,
                        interval: 300,
                        time: 250,
                        threshold: 9,
                        posThreshold: 10
                    },
                    getTouchAction: function() {
                        return [ct]
                    },
                    process: function(e) {
                        var t = this.options,
                            n = e.pointers.length === t.pointers,
                            i = e.distance < t.threshold,
                            r = e.deltaTime < t.time;
                        if (this.reset(), e.eventType & Le && 0 === this.count) return this.failTimeout();
                        if (i && r && n) {
                            if (e.eventType != Oe) return this.failTimeout();
                            var a = this.pTime ? e.timeStamp - this.pTime < t.interval : !0,
                                s = !this.pCenter || N(this.pCenter, e.center) < t.posThreshold;
                            this.pTime = e.timeStamp, this.pCenter = e.center, s && a ? this.count += 1 : this.count = 1, this._input = e;
                            var l = this.count % t.taps;
                            if (0 === l) return this.hasRequireFailures() ? (this._timer = o(function() {
                                this.state = yt, this.tryEmit()
                            }, t.interval, this), mt) : yt
                        }
                        return wt
                    },
                    failTimeout: function() {
                        return this._timer = o(function() {
                            this.state = wt
                        }, this.options.interval, this), wt
                    },
                    reset: function() {
                        clearTimeout(this._timer)
                    },
                    emit: function() {
                        this.state == yt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                    }
                }), le.VERSION = "2.0.7", le.defaults = {
                    domEvents: !1,
                    touchAction: st,
                    enable: !0,
                    inputTarget: null,
                    inputClass: null,
                    preset: [
                        [oe, {
                            enable: !1
                        }],
                        [ie, {
                            enable: !1
                        },
                            ["rotate"]
                        ],
                        [ae, {
                            direction: Ve
                        }],
                        [ne, {
                            direction: Ve
                        },
                            ["swipe"]
                        ],
                        [se],
                        [se, {
                            event: "doubletap",
                            taps: 2
                        },
                            ["tap"]
                        ],
                        [re]
                    ],
                    cssProps: {
                        userSelect: "none",
                        touchSelect: "none",
                        touchCallout: "none",
                        contentZooming: "none",
                        userDrag: "none",
                        tapHighlightColor: "rgba(0,0,0,0)"
                    }
                };
                var _t = 1,
                    bt = 2;
                ce.prototype = {
                    set: function(e) {
                        return fe(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this
                    },
                    stop: function(e) {
                        this.session.stopped = e ? bt : _t
                    },
                    recognize: function(e) {
                        var t = this.session;
                        if (!t.stopped) {
                            this.touchAction.preventDefaults(e);
                            var n, i = this.recognizers,
                                r = t.curRecognizer;
                            (!r || r && r.state & yt) && (r = t.curRecognizer = null);
                            for (var o = 0; o < i.length;) n = i[o], t.stopped === bt || r && n != r && !n.canRecognizeWith(r) ? n.reset() : n.recognize(e), !r && n.state & (mt | vt | gt) && (r = t.curRecognizer = n), o++
                        }
                    },
                    get: function(e) {
                        if (e instanceof J) return e;
                        for (var t = this.recognizers, n = 0; n < t.length; n++)
                            if (t[n].options.event == e) return t[n];
                        return null
                    },
                    add: function(e) {
                        if (a(e, "add", this)) return this;
                        var t = this.get(e.options.event);
                        return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e
                    },
                    remove: function(e) {
                        if (a(e, "remove", this)) return this;
                        if (e = this.get(e)) {
                            var t = this.recognizers,
                                n = y(t, e); - 1 !== n && (t.splice(n, 1), this.touchAction.update())
                        }
                        return this
                    },
                    on: function(e, t) {
                        if (e !== r && t !== r) {
                            var n = this.handlers;
                            return s(g(e), function(e) {
                                n[e] = n[e] || [], n[e].push(t)
                            }), this
                        }
                    },
                    off: function(e, t) {
                        if (e !== r) {
                            var n = this.handlers;
                            return s(g(e), function(e) {
                                t ? n[e] && n[e].splice(y(n[e], t), 1) : delete n[e]
                            }), this
                        }
                    },
                    emit: function(e, t) {
                        this.options.domEvents && ue(e, t);
                        var n = this.handlers[e] && this.handlers[e].slice();
                        if (n && n.length) {
                            t.type = e, t.preventDefault = function() {
                                t.srcEvent.preventDefault()
                            };
                            for (var i = 0; i < n.length;) n[i](t), i++
                        }
                    },
                    destroy: function() {
                        this.element && he(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
                    }
                }, fe(le, {
                    INPUT_START: Le,
                    INPUT_MOVE: Re,
                    INPUT_END: Oe,
                    INPUT_CANCEL: Ne,
                    STATE_POSSIBLE: pt,
                    STATE_BEGAN: mt,
                    STATE_CHANGED: vt,
                    STATE_ENDED: gt,
                    STATE_RECOGNIZED: yt,
                    STATE_CANCELLED: xt,
                    STATE_FAILED: wt,
                    DIRECTION_NONE: Ue,
                    DIRECTION_LEFT: Fe,
                    DIRECTION_RIGHT: ke,
                    DIRECTION_UP: He,
                    DIRECTION_DOWN: Ie,
                    DIRECTION_HORIZONTAL: Ve,
                    DIRECTION_VERTICAL: ze,
                    DIRECTION_ALL: Be,
                    Manager: ce,
                    Input: M,
                    TouchAction: K,
                    TouchInput: B,
                    MouseInput: H,
                    PointerEventInput: I,
                    TouchMouseInput: G,
                    SingleTouchInput: V,
                    Recognizer: J,
                    AttrRecognizer: te,
                    Tap: se,
                    Pan: ne,
                    Swipe: ae,
                    Pinch: ie,
                    Rotate: oe,
                    Press: re,
                    on: d,
                    off: p,
                    each: s,
                    merge: we,
                    extend: xe,
                    assign: fe,
                    inherit: c,
                    bindFn: h,
                    prefixed: _
                });
                var Et = "undefined" != typeof e ? e : "undefined" != typeof self ? self : {};
                Et.Hammer = le, "function" == typeof define && define.amd ? define(function() {
                    return le
                }) : "undefined" != typeof t && t.exports ? t.exports = le : e[i] = le
            }(window, document, "Hammer")
        }, {}
    ],
    4: [
        function(e, t, n) {
            ! function(e, n) {
                "object" == typeof t && "object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function(e) {
                    if (!e.document) throw new Error("jQuery requires a window with a document");
                    return n(e)
                } : n(e)
            }("undefined" != typeof window ? window : this, function(e, t) {
                function n(e) {
                    var t = "length" in e && e.length,
                        n = Q.type(e);
                    return "function" === n || Q.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
                }

                function i(e, t, n) {
                    if (Q.isFunction(t)) return Q.grep(e, function(e, i) {
                        return !!t.call(e, i, e) !== n
                    });
                    if (t.nodeType) return Q.grep(e, function(e) {
                        return e === t !== n
                    });
                    if ("string" == typeof t) {
                        if (se.test(t)) return Q.filter(t, e, n);
                        t = Q.filter(t, e)
                    }
                    return Q.grep(e, function(e) {
                        return X.call(t, e) >= 0 !== n
                    })
                }

                function r(e, t) {
                    for (;
                        (e = e[t]) && 1 !== e.nodeType;);
                    return e
                }

                function o(e) {
                    var t = pe[e] = {};
                    return Q.each(e.match(de) || [], function(e, n) {
                        t[n] = !0
                    }), t
                }

                function a() {
                    J.removeEventListener("DOMContentLoaded", a, !1), e.removeEventListener("load", a, !1), Q.ready()
                }

                function s() {
                    Object.defineProperty(this.cache = {}, 0, {
                        get: function() {
                            return {}
                        }
                    }), this.expando = Q.expando + s.uid++
                }

                function l(e, t, n) {
                    var i;
                    if (void 0 === n && 1 === e.nodeType)
                        if (i = "data-" + t.replace(we, "-$1").toLowerCase(), n = e.getAttribute(i), "string" == typeof n) {
                            try {
                                n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : +n + "" === n ? +n : xe.test(n) ? Q.parseJSON(n) : n
                            } catch (r) {}
                            ye.set(e, t, n)
                        } else n = void 0;
                    return n
                }

                function c() {
                    return !0
                }

                function h() {
                    return !1
                }

                function u() {
                    try {
                        return J.activeElement
                    } catch (e) {}
                }

                function f(e, t) {
                    return Q.nodeName(e, "table") && Q.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
                }

                function d(e) {
                    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
                }

                function p(e) {
                    var t = Fe.exec(e.type);
                    return t ? e.type = t[1] : e.removeAttribute("type"), e
                }

                function m(e, t) {
                    for (var n = 0, i = e.length; i > n; n++) ge.set(e[n], "globalEval", !t || ge.get(t[n], "globalEval"))
                }

                function v(e, t) {
                    var n, i, r, o, a, s, l, c;
                    if (1 === t.nodeType) {
                        if (ge.hasData(e) && (o = ge.access(e), a = ge.set(t, o), c = o.events)) {
                            delete a.handle, a.events = {};
                            for (r in c)
                                for (n = 0, i = c[r].length; i > n; n++) Q.event.add(t, r, c[r][n])
                        }
                        ye.hasData(e) && (s = ye.access(e), l = Q.extend({}, s), ye.set(t, l))
                    }
                }

                function g(e, t) {
                    var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
                    return void 0 === t || t && Q.nodeName(e, t) ? Q.merge([e], n) : n
                }

                function y(e, t) {
                    var n = t.nodeName.toLowerCase();
                    "input" === n && Me.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue)
                }

                function x(t, n) {
                    var i, r = Q(n.createElement(t)).appendTo(n.body),
                        o = e.getDefaultComputedStyle && (i = e.getDefaultComputedStyle(r[0])) ? i.display : Q.css(r[0], "display");
                    return r.detach(), o
                }

                function w(e) {
                    var t = J,
                        n = Ve[e];
                    return n || (n = x(e, t), "none" !== n && n || (Ie = (Ie || Q("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = Ie[0].contentDocument, t.write(), t.close(), n = x(e, t), Ie.detach()), Ve[e] = n), n
                }

                function _(e, t, n) {
                    var i, r, o, a, s = e.style;
                    return n = n || je(e), n && (a = n.getPropertyValue(t) || n[t]), n && ("" !== a || Q.contains(e.ownerDocument, e) || (a = Q.style(e, t)), Be.test(a) && ze.test(t) && (i = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = i, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
                }

                function b(e, t) {
                    return {
                        get: function() {
                            return e() ? void delete this.get : (this.get = t).apply(this, arguments)
                        }
                    }
                }

                function E(e, t) {
                    if (t in e) return t;
                    for (var n = t[0].toUpperCase() + t.slice(1), i = t, r = Ye.length; r--;)
                        if (t = Ye[r] + n, t in e) return t;
                    return i
                }

                function M(e, t, n) {
                    var i = We.exec(t);
                    return i ? Math.max(0, i[1] - (n || 0)) + (i[2] || "px") : t
                }

                function S(e, t, n, i, r) {
                    for (var o = n === (i ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; 4 > o; o += 2) "margin" === n && (a += Q.css(e, n + be[o], !0, r)), i ? ("content" === n && (a -= Q.css(e, "padding" + be[o], !0, r)), "margin" !== n && (a -= Q.css(e, "border" + be[o] + "Width", !0, r))) : (a += Q.css(e, "padding" + be[o], !0, r), "padding" !== n && (a += Q.css(e, "border" + be[o] + "Width", !0, r)));
                    return a
                }

                function T(e, t, n) {
                    var i = !0,
                        r = "width" === t ? e.offsetWidth : e.offsetHeight,
                        o = je(e),
                        a = "border-box" === Q.css(e, "boxSizing", !1, o);
                    if (0 >= r || null == r) {
                        if (r = _(e, t, o), (0 > r || null == r) && (r = e.style[t]), Be.test(r)) return r;
                        i = a && ($.boxSizingReliable() || r === e.style[t]), r = parseFloat(r) || 0
                    }
                    return r + S(e, t, n || (a ? "border" : "content"), i, o) + "px"
                }

                function C(e, t) {
                    for (var n, i, r, o = [], a = 0, s = e.length; s > a; a++) i = e[a], i.style && (o[a] = ge.get(i, "olddisplay"), n = i.style.display, t ? (o[a] || "none" !== n || (i.style.display = ""), "" === i.style.display && Ee(i) && (o[a] = ge.access(i, "olddisplay", w(i.nodeName)))) : (r = Ee(i), "none" === n && r || ge.set(i, "olddisplay", r ? n : Q.css(i, "display"))));
                    for (a = 0; s > a; a++) i = e[a], i.style && (t && "none" !== i.style.display && "" !== i.style.display || (i.style.display = t ? o[a] || "" : "none"));
                    return e
                }

                function A(e, t, n, i, r) {
                    return new A.prototype.init(e, t, n, i, r)
                }

                function P() {
                    return setTimeout(function() {
                        $e = void 0
                    }), $e = Q.now()
                }

                function D(e, t) {
                    var n, i = 0,
                        r = {
                            height: e
                        };
                    for (t = t ? 1 : 0; 4 > i; i += 2 - t) n = be[i], r["margin" + n] = r["padding" + n] = e;
                    return t && (r.opacity = r.width = e), r
                }

                function L(e, t, n) {
                    for (var i, r = (nt[t] || []).concat(nt["*"]), o = 0, a = r.length; a > o; o++)
                        if (i = r[o].call(n, t, e)) return i
                }

                function R(e, t, n) {
                    var i, r, o, a, s, l, c, h, u = this,
                        f = {},
                        d = e.style,
                        p = e.nodeType && Ee(e),
                        m = ge.get(e, "fxshow");
                    n.queue || (s = Q._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function() {
                        s.unqueued || l()
                    }), s.unqueued++, u.always(function() {
                        u.always(function() {
                            s.unqueued--, Q.queue(e, "fx").length || s.empty.fire()
                        })
                    })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], c = Q.css(e, "display"), h = "none" === c ? ge.get(e, "olddisplay") || w(e.nodeName) : c, "inline" === h && "none" === Q.css(e, "float") && (d.display = "inline-block")), n.overflow && (d.overflow = "hidden", u.always(function() {
                        d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2]
                    }));
                    for (i in t)
                        if (r = t[i], Ze.exec(r)) {
                            if (delete t[i], o = o || "toggle" === r, r === (p ? "hide" : "show")) {
                                if ("show" !== r || !m || void 0 === m[i]) continue;
                                p = !0
                            }
                            f[i] = m && m[i] || Q.style(e, i)
                        } else c = void 0;
                    if (Q.isEmptyObject(f)) "inline" === ("none" === c ? w(e.nodeName) : c) && (d.display = c);
                    else {
                        m ? "hidden" in m && (p = m.hidden) : m = ge.access(e, "fxshow", {}), o && (m.hidden = !p), p ? Q(e).show() : u.done(function() {
                            Q(e).hide()
                        }), u.done(function() {
                            var t;
                            ge.remove(e, "fxshow");
                            for (t in f) Q.style(e, t, f[t])
                        });
                        for (i in f) a = L(p ? m[i] : 0, i, u), i in m || (m[i] = a.start, p && (a.end = a.start, a.start = "width" === i || "height" === i ? 1 : 0))
                    }
                }

                function O(e, t) {
                    var n, i, r, o, a;
                    for (n in e)
                        if (i = Q.camelCase(n), r = t[i], o = e[n], Q.isArray(o) && (r = o[1], o = e[n] = o[0]), n !== i && (e[i] = o, delete e[n]), a = Q.cssHooks[i], a && "expand" in a) {
                            o = a.expand(o), delete e[i];
                            for (n in o) n in e || (e[n] = o[n], t[n] = r)
                        } else t[i] = r
                }

                function N(e, t, n) {
                    var i, r, o = 0,
                        a = tt.length,
                        s = Q.Deferred().always(function() {
                            delete l.elem
                        }),
                        l = function() {
                            if (r) return !1;
                            for (var t = $e || P(), n = Math.max(0, c.startTime + c.duration - t), i = n / c.duration || 0, o = 1 - i, a = 0, l = c.tweens.length; l > a; a++) c.tweens[a].run(o);
                            return s.notifyWith(e, [c, o, n]), 1 > o && l ? n : (s.resolveWith(e, [c]), !1)
                        },
                        c = s.promise({
                            elem: e,
                            props: Q.extend({}, t),
                            opts: Q.extend(!0, {
                                specialEasing: {}
                            }, n),
                            originalProperties: t,
                            originalOptions: n,
                            startTime: $e || P(),
                            duration: n.duration,
                            tweens: [],
                            createTween: function(t, n) {
                                var i = Q.Tween(e, c.opts, t, n, c.opts.specialEasing[t] || c.opts.easing);
                                return c.tweens.push(i), i
                            },
                            stop: function(t) {
                                var n = 0,
                                    i = t ? c.tweens.length : 0;
                                if (r) return this;
                                for (r = !0; i > n; n++) c.tweens[n].run(1);
                                return t ? s.resolveWith(e, [c, t]) : s.rejectWith(e, [c, t]), this
                            }
                        }),
                        h = c.props;
                    for (O(h, c.opts.specialEasing); a > o; o++)
                        if (i = tt[o].call(c, e, h, c.opts)) return i;
                    return Q.map(h, L, c), Q.isFunction(c.opts.start) && c.opts.start.call(e, c), Q.fx.timer(Q.extend(l, {
                        elem: e,
                        anim: c,
                        queue: c.opts.queue
                    })), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always)
                }

                function U(e) {
                    return function(t, n) {
                        "string" != typeof t && (n = t, t = "*");
                        var i, r = 0,
                            o = t.toLowerCase().match(de) || [];
                        if (Q.isFunction(n))
                            for (; i = o[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(n)) : (e[i] = e[i] || []).push(n)
                    }
                }

                function F(e, t, n, i) {
                    function r(s) {
                        var l;
                        return o[s] = !0, Q.each(e[s] || [], function(e, s) {
                            var c = s(t, n, i);
                            return "string" != typeof c || a || o[c] ? a ? !(l = c) : void 0 : (t.dataTypes.unshift(c), r(c), !1)
                        }), l
                    }
                    var o = {},
                        a = e === xt;
                    return r(t.dataTypes[0]) || !o["*"] && r("*")
                }

                function k(e, t) {
                    var n, i, r = Q.ajaxSettings.flatOptions || {};
                    for (n in t) void 0 !== t[n] && ((r[n] ? e : i || (i = {}))[n] = t[n]);
                    return i && Q.extend(!0, e, i), e
                }

                function H(e, t, n) {
                    for (var i, r, o, a, s = e.contents, l = e.dataTypes;
                         "*" === l[0];) l.shift(), void 0 === i && (i = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (i)
                        for (r in s)
                            if (s[r] && s[r].test(i)) {
                                l.unshift(r);
                                break
                            }
                    if (l[0] in n) o = l[0];
                    else {
                        for (r in n) {
                            if (!l[0] || e.converters[r + " " + l[0]]) {
                                o = r;
                                break
                            }
                            a || (a = r)
                        }
                        o = o || a
                    }
                    return o ? (o !== l[0] && l.unshift(o), n[o]) : void 0
                }

                function I(e, t, n, i) {
                    var r, o, a, s, l, c = {},
                        h = e.dataTypes.slice();
                    if (h[1])
                        for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
                    for (o = h.shift(); o;)
                        if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && i && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = h.shift())
                            if ("*" === o) o = l;
                            else if ("*" !== l && l !== o) {
                                if (a = c[l + " " + o] || c["* " + o], !a)
                                    for (r in c)
                                        if (s = r.split(" "), s[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                                            a === !0 ? a = c[r] : c[r] !== !0 && (o = s[0], h.unshift(s[1]));
                                            break
                                        }
                                if (a !== !0)
                                    if (a && e["throws"]) t = a(t);
                                    else try {
                                        t = a(t)
                                    } catch (u) {
                                        return {
                                            state: "parsererror",
                                            error: a ? u : "No conversion from " + l + " to " + o
                                        }
                                    }
                            }
                    return {
                        state: "success",
                        data: t
                    }
                }

                function V(e, t, n, i) {
                    var r;
                    if (Q.isArray(t)) Q.each(t, function(t, r) {
                        n || Mt.test(e) ? i(e, r) : V(e + "[" + ("object" == typeof r ? t : "") + "]", r, n, i)
                    });
                    else if (n || "object" !== Q.type(t)) i(e, t);
                    else
                        for (r in t) V(e + "[" + r + "]", t[r], n, i)
                }

                function z(e) {
                    return Q.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
                }
                var B = [],
                    j = B.slice,
                    G = B.concat,
                    W = B.push,
                    X = B.indexOf,
                    q = {},
                    K = q.toString,
                    Y = q.hasOwnProperty,
                    $ = {},
                    J = e.document,
                    Z = "2.1.4",
                    Q = function(e, t) {
                        return new Q.fn.init(e, t)
                    },
                    ee = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                    te = /^-ms-/,
                    ne = /-([\da-z])/gi,
                    ie = function(e, t) {
                        return t.toUpperCase()
                    };
                Q.fn = Q.prototype = {
                    jquery: Z,
                    constructor: Q,
                    selector: "",
                    length: 0,
                    toArray: function() {
                        return j.call(this)
                    },
                    get: function(e) {
                        return null != e ? 0 > e ? this[e + this.length] : this[e] : j.call(this)
                    },
                    pushStack: function(e) {
                        var t = Q.merge(this.constructor(), e);
                        return t.prevObject = this, t.context = this.context, t
                    },
                    each: function(e, t) {
                        return Q.each(this, e, t)
                    },
                    map: function(e) {
                        return this.pushStack(Q.map(this, function(t, n) {
                            return e.call(t, n, t)
                        }))
                    },
                    slice: function() {
                        return this.pushStack(j.apply(this, arguments))
                    },
                    first: function() {
                        return this.eq(0)
                    },
                    last: function() {
                        return this.eq(-1)
                    },
                    eq: function(e) {
                        var t = this.length,
                            n = +e + (0 > e ? t : 0);
                        return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
                    },
                    end: function() {
                        return this.prevObject || this.constructor(null)
                    },
                    push: W,
                    sort: B.sort,
                    splice: B.splice
                }, Q.extend = Q.fn.extend = function() {
                    var e, t, n, i, r, o, a = arguments[0] || {},
                        s = 1,
                        l = arguments.length,
                        c = !1;
                    for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || Q.isFunction(a) || (a = {}), s === l && (a = this, s--); l > s; s++)
                        if (null != (e = arguments[s]))
                            for (t in e) n = a[t], i = e[t], a !== i && (c && i && (Q.isPlainObject(i) || (r = Q.isArray(i))) ? (r ? (r = !1, o = n && Q.isArray(n) ? n : []) : o = n && Q.isPlainObject(n) ? n : {}, a[t] = Q.extend(c, o, i)) : void 0 !== i && (a[t] = i));
                    return a
                }, Q.extend({
                    expando: "jQuery" + (Z + Math.random()).replace(/\D/g, ""),
                    isReady: !0,
                    error: function(e) {
                        throw new Error(e)
                    },
                    noop: function() {},
                    isFunction: function(e) {
                        return "function" === Q.type(e)
                    },
                    isArray: Array.isArray,
                    isWindow: function(e) {
                        return null != e && e === e.window
                    },
                    isNumeric: function(e) {
                        return !Q.isArray(e) && e - parseFloat(e) + 1 >= 0
                    },
                    isPlainObject: function(e) {
                        return "object" !== Q.type(e) || e.nodeType || Q.isWindow(e) ? !1 : !e.constructor || Y.call(e.constructor.prototype, "isPrototypeOf")
                    },
                    isEmptyObject: function(e) {
                        var t;
                        for (t in e) return !1;
                        return !0
                    },
                    type: function(e) {
                        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? q[K.call(e)] || "object" : typeof e
                    },
                    globalEval: function(e) {
                        var t, n = eval;
                        e = Q.trim(e), e && (1 === e.indexOf("use strict") ? (t = J.createElement("script"), t.text = e, J.head.appendChild(t).parentNode.removeChild(t)) : n(e))
                    },
                    camelCase: function(e) {
                        return e.replace(te, "ms-").replace(ne, ie)
                    },
                    nodeName: function(e, t) {
                        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
                    },
                    each: function(e, t, i) {
                        var r, o = 0,
                            a = e.length,
                            s = n(e);
                        if (i) {
                            if (s)
                                for (; a > o && (r = t.apply(e[o], i), r !== !1); o++);
                            else
                                for (o in e)
                                    if (r = t.apply(e[o], i), r === !1) break
                        } else if (s)
                            for (; a > o && (r = t.call(e[o], o, e[o]), r !== !1); o++);
                        else
                            for (o in e)
                                if (r = t.call(e[o], o, e[o]), r === !1) break; return e
                    },
                    trim: function(e) {
                        return null == e ? "" : (e + "").replace(ee, "")
                    },
                    makeArray: function(e, t) {
                        var i = t || [];
                        return null != e && (n(Object(e)) ? Q.merge(i, "string" == typeof e ? [e] : e) : W.call(i, e)), i
                    },
                    inArray: function(e, t, n) {
                        return null == t ? -1 : X.call(t, e, n)
                    },
                    merge: function(e, t) {
                        for (var n = +t.length, i = 0, r = e.length; n > i; i++) e[r++] = t[i];
                        return e.length = r, e
                    },
                    grep: function(e, t, n) {
                        for (var i, r = [], o = 0, a = e.length, s = !n; a > o; o++) i = !t(e[o], o), i !== s && r.push(e[o]);
                        return r
                    },
                    map: function(e, t, i) {
                        var r, o = 0,
                            a = e.length,
                            s = n(e),
                            l = [];
                        if (s)
                            for (; a > o; o++) r = t(e[o], o, i), null != r && l.push(r);
                        else
                            for (o in e) r = t(e[o], o, i), null != r && l.push(r);
                        return G.apply([], l)
                    },
                    guid: 1,
                    proxy: function(e, t) {
                        var n, i, r;
                        return "string" == typeof t && (n = e[t], t = e, e = n), Q.isFunction(e) ? (i = j.call(arguments, 2), r = function() {
                            return e.apply(t || this, i.concat(j.call(arguments)))
                        }, r.guid = e.guid = e.guid || Q.guid++, r) : void 0
                    },
                    now: Date.now,
                    support: $
                }), Q.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
                    q["[object " + t + "]"] = t.toLowerCase()
                });
                var re = function(e) {
                    function t(e, t, n, i) {
                        var r, o, a, s, l, c, u, d, p, m;
                        if ((t ? t.ownerDocument || t : V) !== R && L(t), t = t || R, n = n || [], s = t.nodeType, "string" != typeof e || !e || 1 !== s && 9 !== s && 11 !== s) return n;
                        if (!i && N) {
                            if (11 !== s && (r = ye.exec(e)))
                                if (a = r[1]) {
                                    if (9 === s) {
                                        if (o = t.getElementById(a), !o || !o.parentNode) return n;
                                        if (o.id === a) return n.push(o), n
                                    } else if (t.ownerDocument && (o = t.ownerDocument.getElementById(a)) && H(t, o) && o.id === a) return n.push(o), n
                                } else {
                                    if (r[2]) return Z.apply(n, t.getElementsByTagName(e)), n;
                                    if ((a = r[3]) && _.getElementsByClassName) return Z.apply(n, t.getElementsByClassName(a)), n
                                }
                            if (_.qsa && (!U || !U.test(e))) {
                                if (d = u = I, p = t, m = 1 !== s && e, 1 === s && "object" !== t.nodeName.toLowerCase()) {
                                    for (c = S(e), (u = t.getAttribute("id")) ? d = u.replace(we, "\\$&") : t.setAttribute("id", d), d = "[id='" + d + "'] ", l = c.length; l--;) c[l] = d + f(c[l]);
                                    p = xe.test(e) && h(t.parentNode) || t, m = c.join(",")
                                }
                                if (m) try {
                                    return Z.apply(n, p.querySelectorAll(m)), n
                                } catch (v) {} finally {
                                    u || t.removeAttribute("id")
                                }
                            }
                        }
                        return C(e.replace(le, "$1"), t, n, i)
                    }

                    function n() {
                        function e(n, i) {
                            return t.push(n + " ") > b.cacheLength && delete e[t.shift()], e[n + " "] = i
                        }
                        var t = [];
                        return e
                    }

                    function i(e) {
                        return e[I] = !0, e
                    }

                    function r(e) {
                        var t = R.createElement("div");
                        try {
                            return !!e(t)
                        } catch (n) {
                            return !1
                        } finally {
                            t.parentNode && t.parentNode.removeChild(t), t = null
                        }
                    }

                    function o(e, t) {
                        for (var n = e.split("|"), i = e.length; i--;) b.attrHandle[n[i]] = t
                    }

                    function a(e, t) {
                        var n = t && e,
                            i = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || q) - (~e.sourceIndex || q);
                        if (i) return i;
                        if (n)
                            for (; n = n.nextSibling;)
                                if (n === t) return -1;
                        return e ? 1 : -1
                    }

                    function s(e) {
                        return function(t) {
                            var n = t.nodeName.toLowerCase();
                            return "input" === n && t.type === e
                        }
                    }

                    function l(e) {
                        return function(t) {
                            var n = t.nodeName.toLowerCase();
                            return ("input" === n || "button" === n) && t.type === e
                        }
                    }

                    function c(e) {
                        return i(function(t) {
                            return t = +t, i(function(n, i) {
                                for (var r, o = e([], n.length, t), a = o.length; a--;) n[r = o[a]] && (n[r] = !(i[r] = n[r]))
                            })
                        })
                    }

                    function h(e) {
                        return e && "undefined" != typeof e.getElementsByTagName && e
                    }

                    function u() {}

                    function f(e) {
                        for (var t = 0, n = e.length, i = ""; n > t; t++) i += e[t].value;
                        return i
                    }

                    function d(e, t, n) {
                        var i = t.dir,
                            r = n && "parentNode" === i,
                            o = B++;
                        return t.first ? function(t, n, o) {
                            for (; t = t[i];)
                                if (1 === t.nodeType || r) return e(t, n, o)
                        } : function(t, n, a) {
                            var s, l, c = [z, o];
                            if (a) {
                                for (; t = t[i];)
                                    if ((1 === t.nodeType || r) && e(t, n, a)) return !0
                            } else
                                for (; t = t[i];)
                                    if (1 === t.nodeType || r) {
                                        if (l = t[I] || (t[I] = {}), (s = l[i]) && s[0] === z && s[1] === o) return c[2] = s[2];
                                        if (l[i] = c, c[2] = e(t, n, a)) return !0
                                    }
                        }
                    }

                    function p(e) {
                        return e.length > 1 ? function(t, n, i) {
                            for (var r = e.length; r--;)
                                if (!e[r](t, n, i)) return !1;
                            return !0
                        } : e[0]
                    }

                    function m(e, n, i) {
                        for (var r = 0, o = n.length; o > r; r++) t(e, n[r], i);
                        return i
                    }

                    function v(e, t, n, i, r) {
                        for (var o, a = [], s = 0, l = e.length, c = null != t; l > s; s++)(o = e[s]) && (n && !n(o, i, r) || (a.push(o), c && t.push(s)));
                        return a
                    }

                    function g(e, t, n, r, o, a) {
                        return r && !r[I] && (r = g(r)), o && !o[I] && (o = g(o, a)), i(function(i, a, s, l) {
                            var c, h, u, f = [],
                                d = [],
                                p = a.length,
                                g = i || m(t || "*", s.nodeType ? [s] : s, []),
                                y = !e || !i && t ? g : v(g, f, e, s, l),
                                x = n ? o || (i ? e : p || r) ? [] : a : y;
                            if (n && n(y, x, s, l), r)
                                for (c = v(x, d), r(c, [], s, l), h = c.length; h--;)(u = c[h]) && (x[d[h]] = !(y[d[h]] = u));
                            if (i) {
                                if (o || e) {
                                    if (o) {
                                        for (c = [], h = x.length; h--;)(u = x[h]) && c.push(y[h] = u);
                                        o(null, x = [], c, l)
                                    }
                                    for (h = x.length; h--;)(u = x[h]) && (c = o ? ee(i, u) : f[h]) > -1 && (i[c] = !(a[c] = u))
                                }
                            } else x = v(x === a ? x.splice(p, x.length) : x), o ? o(null, a, x, l) : Z.apply(a, x)
                        })
                    }

                    function y(e) {
                        for (var t, n, i, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, l = d(function(e) {
                            return e === t
                        }, a, !0), c = d(function(e) {
                            return ee(t, e) > -1
                        }, a, !0), h = [
                            function(e, n, i) {
                                var r = !o && (i || n !== A) || ((t = n).nodeType ? l(e, n, i) : c(e, n, i));
                                return t = null, r
                            }
                        ]; r > s; s++)
                            if (n = b.relative[e[s].type]) h = [d(p(h), n)];
                            else {
                                if (n = b.filter[e[s].type].apply(null, e[s].matches), n[I]) {
                                    for (i = ++s; r > i && !b.relative[e[i].type]; i++);
                                    return g(s > 1 && p(h), s > 1 && f(e.slice(0, s - 1).concat({
                                        value: " " === e[s - 2].type ? "*" : ""
                                    })).replace(le, "$1"), n, i > s && y(e.slice(s, i)), r > i && y(e = e.slice(i)), r > i && f(e))
                                }
                                h.push(n)
                            }
                        return p(h)
                    }

                    function x(e, n) {
                        var r = n.length > 0,
                            o = e.length > 0,
                            a = function(i, a, s, l, c) {
                                var h, u, f, d = 0,
                                    p = "0",
                                    m = i && [],
                                    g = [],
                                    y = A,
                                    x = i || o && b.find.TAG("*", c),
                                    w = z += null == y ? 1 : Math.random() || .1,
                                    _ = x.length;
                                for (c && (A = a !== R && a); p !== _ && null != (h = x[p]); p++) {
                                    if (o && h) {
                                        for (u = 0; f = e[u++];)
                                            if (f(h, a, s)) {
                                                l.push(h);
                                                break
                                            }
                                        c && (z = w)
                                    }
                                    r && ((h = !f && h) && d--, i && m.push(h))
                                }
                                if (d += p, r && p !== d) {
                                    for (u = 0; f = n[u++];) f(m, g, a, s);
                                    if (i) {
                                        if (d > 0)
                                            for (; p--;) m[p] || g[p] || (g[p] = $.call(l));
                                        g = v(g)
                                    }
                                    Z.apply(l, g), c && !i && g.length > 0 && d + n.length > 1 && t.uniqueSort(l)
                                }
                                return c && (z = w, A = y), m
                            };
                        return r ? i(a) : a
                    }
                    var w, _, b, E, M, S, T, C, A, P, D, L, R, O, N, U, F, k, H, I = "sizzle" + 1 * new Date,
                        V = e.document,
                        z = 0,
                        B = 0,
                        j = n(),
                        G = n(),
                        W = n(),
                        X = function(e, t) {
                            return e === t && (D = !0), 0
                        },
                        q = 1 << 31,
                        K = {}.hasOwnProperty,
                        Y = [],
                        $ = Y.pop,
                        J = Y.push,
                        Z = Y.push,
                        Q = Y.slice,
                        ee = function(e, t) {
                            for (var n = 0, i = e.length; i > n; n++)
                                if (e[n] === t) return n;
                            return -1
                        },
                        te = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                        ne = "[\\x20\\t\\r\\n\\f]",
                        ie = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                        re = ie.replace("w", "w#"),
                        oe = "\\[" + ne + "*(" + ie + ")(?:" + ne + "*([*^$|!~]?=)" + ne + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + re + "))|)" + ne + "*\\]",
                        ae = ":(" + ie + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + oe + ")*)|.*)\\)|)",
                        se = new RegExp(ne + "+", "g"),
                        le = new RegExp("^" + ne + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ne + "+$", "g"),
                        ce = new RegExp("^" + ne + "*," + ne + "*"),
                        he = new RegExp("^" + ne + "*([>+~]|" + ne + ")" + ne + "*"),
                        ue = new RegExp("=" + ne + "*([^\\]'\"]*?)" + ne + "*\\]", "g"),
                        fe = new RegExp(ae),
                        de = new RegExp("^" + re + "$"),
                        pe = {
                            ID: new RegExp("^#(" + ie + ")"),
                            CLASS: new RegExp("^\\.(" + ie + ")"),
                            TAG: new RegExp("^(" + ie.replace("w", "w*") + ")"),
                            ATTR: new RegExp("^" + oe),
                            PSEUDO: new RegExp("^" + ae),
                            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ne + "*(even|odd|(([+-]|)(\\d*)n|)" + ne + "*(?:([+-]|)" + ne + "*(\\d+)|))" + ne + "*\\)|)", "i"),
                            bool: new RegExp("^(?:" + te + ")$", "i"),
                            needsContext: new RegExp("^" + ne + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ne + "*((?:-\\d)?\\d*)" + ne + "*\\)|)(?=[^-]|$)", "i")
                        },
                        me = /^(?:input|select|textarea|button)$/i,
                        ve = /^h\d$/i,
                        ge = /^[^{]+\{\s*\[native \w/,
                        ye = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                        xe = /[+~]/,
                        we = /'|\\/g,
                        _e = new RegExp("\\\\([\\da-f]{1,6}" + ne + "?|(" + ne + ")|.)", "ig"),
                        be = function(e, t, n) {
                            var i = "0x" + t - 65536;
                            return i !== i || n ? t : 0 > i ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320)
                        },
                        Ee = function() {
                            L()
                        };
                    try {
                        Z.apply(Y = Q.call(V.childNodes), V.childNodes), Y[V.childNodes.length].nodeType
                    } catch (Me) {
                        Z = {
                            apply: Y.length ? function(e, t) {
                                J.apply(e, Q.call(t))
                            } : function(e, t) {
                                for (var n = e.length, i = 0; e[n++] = t[i++];);
                                e.length = n - 1
                            }
                        }
                    }
                    _ = t.support = {}, M = t.isXML = function(e) {
                        var t = e && (e.ownerDocument || e).documentElement;
                        return t ? "HTML" !== t.nodeName : !1
                    }, L = t.setDocument = function(e) {
                        var t, n, i = e ? e.ownerDocument || e : V;
                        return i !== R && 9 === i.nodeType && i.documentElement ? (R = i, O = i.documentElement, n = i.defaultView, n && n !== n.top && (n.addEventListener ? n.addEventListener("unload", Ee, !1) : n.attachEvent && n.attachEvent("onunload", Ee)),
                            N = !M(i), _.attributes = r(function(e) {
                            return e.className = "i", !e.getAttribute("className")
                        }), _.getElementsByTagName = r(function(e) {
                            return e.appendChild(i.createComment("")), !e.getElementsByTagName("*").length
                        }), _.getElementsByClassName = ge.test(i.getElementsByClassName), _.getById = r(function(e) {
                            return O.appendChild(e).id = I, !i.getElementsByName || !i.getElementsByName(I).length
                        }), _.getById ? (b.find.ID = function(e, t) {
                            if ("undefined" != typeof t.getElementById && N) {
                                var n = t.getElementById(e);
                                return n && n.parentNode ? [n] : []
                            }
                        }, b.filter.ID = function(e) {
                            var t = e.replace(_e, be);
                            return function(e) {
                                return e.getAttribute("id") === t
                            }
                        }) : (delete b.find.ID, b.filter.ID = function(e) {
                            var t = e.replace(_e, be);
                            return function(e) {
                                var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                                return n && n.value === t
                            }
                        }), b.find.TAG = _.getElementsByTagName ? function(e, t) {
                            return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : _.qsa ? t.querySelectorAll(e) : void 0
                        } : function(e, t) {
                            var n, i = [],
                                r = 0,
                                o = t.getElementsByTagName(e);
                            if ("*" === e) {
                                for (; n = o[r++];) 1 === n.nodeType && i.push(n);
                                return i
                            }
                            return o
                        }, b.find.CLASS = _.getElementsByClassName && function(e, t) {
                            return N ? t.getElementsByClassName(e) : void 0
                        }, F = [], U = [], (_.qsa = ge.test(i.querySelectorAll)) && (r(function(e) {
                            O.appendChild(e).innerHTML = "<a id='" + I + "'></a><select id='" + I + "-\f]' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && U.push("[*^$]=" + ne + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || U.push("\\[" + ne + "*(?:value|" + te + ")"), e.querySelectorAll("[id~=" + I + "-]").length || U.push("~="), e.querySelectorAll(":checked").length || U.push(":checked"), e.querySelectorAll("a#" + I + "+*").length || U.push(".#.+[+~]")
                        }), r(function(e) {
                            var t = i.createElement("input");
                            t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && U.push("name" + ne + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || U.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), U.push(",.*:")
                        })), (_.matchesSelector = ge.test(k = O.matches || O.webkitMatchesSelector || O.mozMatchesSelector || O.oMatchesSelector || O.msMatchesSelector)) && r(function(e) {
                            _.disconnectedMatch = k.call(e, "div"), k.call(e, "[s!='']:x"), F.push("!=", ae)
                        }), U = U.length && new RegExp(U.join("|")), F = F.length && new RegExp(F.join("|")), t = ge.test(O.compareDocumentPosition), H = t || ge.test(O.contains) ? function(e, t) {
                            var n = 9 === e.nodeType ? e.documentElement : e,
                                i = t && t.parentNode;
                            return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
                        } : function(e, t) {
                            if (t)
                                for (; t = t.parentNode;)
                                    if (t === e) return !0;
                            return !1
                        }, X = t ? function(e, t) {
                            if (e === t) return D = !0, 0;
                            var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                            return n ? n : (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & n || !_.sortDetached && t.compareDocumentPosition(e) === n ? e === i || e.ownerDocument === V && H(V, e) ? -1 : t === i || t.ownerDocument === V && H(V, t) ? 1 : P ? ee(P, e) - ee(P, t) : 0 : 4 & n ? -1 : 1)
                        } : function(e, t) {
                            if (e === t) return D = !0, 0;
                            var n, r = 0,
                                o = e.parentNode,
                                s = t.parentNode,
                                l = [e],
                                c = [t];
                            if (!o || !s) return e === i ? -1 : t === i ? 1 : o ? -1 : s ? 1 : P ? ee(P, e) - ee(P, t) : 0;
                            if (o === s) return a(e, t);
                            for (n = e; n = n.parentNode;) l.unshift(n);
                            for (n = t; n = n.parentNode;) c.unshift(n);
                            for (; l[r] === c[r];) r++;
                            return r ? a(l[r], c[r]) : l[r] === V ? -1 : c[r] === V ? 1 : 0
                        }, i) : R
                    }, t.matches = function(e, n) {
                        return t(e, null, null, n)
                    }, t.matchesSelector = function(e, n) {
                        if ((e.ownerDocument || e) !== R && L(e), n = n.replace(ue, "='$1']"), _.matchesSelector && N && (!F || !F.test(n)) && (!U || !U.test(n))) try {
                            var i = k.call(e, n);
                            if (i || _.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
                        } catch (r) {}
                        return t(n, R, null, [e]).length > 0
                    }, t.contains = function(e, t) {
                        return (e.ownerDocument || e) !== R && L(e), H(e, t)
                    }, t.attr = function(e, t) {
                        (e.ownerDocument || e) !== R && L(e);
                        var n = b.attrHandle[t.toLowerCase()],
                            i = n && K.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !N) : void 0;
                        return void 0 !== i ? i : _.attributes || !N ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
                    }, t.error = function(e) {
                        throw new Error("Syntax error, unrecognized expression: " + e)
                    }, t.uniqueSort = function(e) {
                        var t, n = [],
                            i = 0,
                            r = 0;
                        if (D = !_.detectDuplicates, P = !_.sortStable && e.slice(0), e.sort(X), D) {
                            for (; t = e[r++];) t === e[r] && (i = n.push(r));
                            for (; i--;) e.splice(n[i], 1)
                        }
                        return P = null, e
                    }, E = t.getText = function(e) {
                        var t, n = "",
                            i = 0,
                            r = e.nodeType;
                        if (r) {
                            if (1 === r || 9 === r || 11 === r) {
                                if ("string" == typeof e.textContent) return e.textContent;
                                for (e = e.firstChild; e; e = e.nextSibling) n += E(e)
                            } else if (3 === r || 4 === r) return e.nodeValue
                        } else
                            for (; t = e[i++];) n += E(t);
                        return n
                    }, b = t.selectors = {
                        cacheLength: 50,
                        createPseudo: i,
                        match: pe,
                        attrHandle: {},
                        find: {},
                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: !0
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: !0
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },
                        preFilter: {
                            ATTR: function(e) {
                                return e[1] = e[1].replace(_e, be), e[3] = (e[3] || e[4] || e[5] || "").replace(_e, be), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                            },
                            CHILD: function(e) {
                                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e
                            },
                            PSEUDO: function(e) {
                                var t, n = !e[6] && e[2];
                                return pe.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && fe.test(n) && (t = S(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                            }
                        },
                        filter: {
                            TAG: function(e) {
                                var t = e.replace(_e, be).toLowerCase();
                                return "*" === e ? function() {
                                    return !0
                                } : function(e) {
                                    return e.nodeName && e.nodeName.toLowerCase() === t
                                }
                            },
                            CLASS: function(e) {
                                var t = j[e + " "];
                                return t || (t = new RegExp("(^|" + ne + ")" + e + "(" + ne + "|$)")) && j(e, function(e) {
                                        return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                                    })
                            },
                            ATTR: function(e, n, i) {
                                return function(r) {
                                    var o = t.attr(r, e);
                                    return null == o ? "!=" === n : n ? (o += "", "=" === n ? o === i : "!=" === n ? o !== i : "^=" === n ? i && 0 === o.indexOf(i) : "*=" === n ? i && o.indexOf(i) > -1 : "$=" === n ? i && o.slice(-i.length) === i : "~=" === n ? (" " + o.replace(se, " ") + " ").indexOf(i) > -1 : "|=" === n ? o === i || o.slice(0, i.length + 1) === i + "-" : !1) : !0
                                }
                            },
                            CHILD: function(e, t, n, i, r) {
                                var o = "nth" !== e.slice(0, 3),
                                    a = "last" !== e.slice(-4),
                                    s = "of-type" === t;
                                return 1 === i && 0 === r ? function(e) {
                                    return !!e.parentNode
                                } : function(t, n, l) {
                                    var c, h, u, f, d, p, m = o !== a ? "nextSibling" : "previousSibling",
                                        v = t.parentNode,
                                        g = s && t.nodeName.toLowerCase(),
                                        y = !l && !s;
                                    if (v) {
                                        if (o) {
                                            for (; m;) {
                                                for (u = t; u = u[m];)
                                                    if (s ? u.nodeName.toLowerCase() === g : 1 === u.nodeType) return !1;
                                                p = m = "only" === e && !p && "nextSibling"
                                            }
                                            return !0
                                        }
                                        if (p = [a ? v.firstChild : v.lastChild], a && y) {
                                            for (h = v[I] || (v[I] = {}), c = h[e] || [], d = c[0] === z && c[1], f = c[0] === z && c[2], u = d && v.childNodes[d]; u = ++d && u && u[m] || (f = d = 0) || p.pop();)
                                                if (1 === u.nodeType && ++f && u === t) {
                                                    h[e] = [z, d, f];
                                                    break
                                                }
                                        } else if (y && (c = (t[I] || (t[I] = {}))[e]) && c[0] === z) f = c[1];
                                        else
                                            for (;
                                                (u = ++d && u && u[m] || (f = d = 0) || p.pop()) && ((s ? u.nodeName.toLowerCase() !== g : 1 !== u.nodeType) || !++f || (y && ((u[I] || (u[I] = {}))[e] = [z, f]), u !== t)););
                                        return f -= r, f === i || f % i === 0 && f / i >= 0
                                    }
                                }
                            },
                            PSEUDO: function(e, n) {
                                var r, o = b.pseudos[e] || b.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                                return o[I] ? o(n) : o.length > 1 ? (r = [e, e, "", n], b.setFilters.hasOwnProperty(e.toLowerCase()) ? i(function(e, t) {
                                    for (var i, r = o(e, n), a = r.length; a--;) i = ee(e, r[a]), e[i] = !(t[i] = r[a])
                                }) : function(e) {
                                    return o(e, 0, r)
                                }) : o
                            }
                        },
                        pseudos: {
                            not: i(function(e) {
                                var t = [],
                                    n = [],
                                    r = T(e.replace(le, "$1"));
                                return r[I] ? i(function(e, t, n, i) {
                                    for (var o, a = r(e, null, i, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
                                }) : function(e, i, o) {
                                    return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop()
                                }
                            }),
                            has: i(function(e) {
                                return function(n) {
                                    return t(e, n).length > 0
                                }
                            }),
                            contains: i(function(e) {
                                return e = e.replace(_e, be),
                                    function(t) {
                                        return (t.textContent || t.innerText || E(t)).indexOf(e) > -1
                                    }
                            }),
                            lang: i(function(e) {
                                return de.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(_e, be).toLowerCase(),
                                    function(t) {
                                        var n;
                                        do
                                            if (n = N ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-");
                                        while ((t = t.parentNode) && 1 === t.nodeType);
                                        return !1
                                    }
                            }),
                            target: function(t) {
                                var n = e.location && e.location.hash;
                                return n && n.slice(1) === t.id
                            },
                            root: function(e) {
                                return e === O
                            },
                            focus: function(e) {
                                return e === R.activeElement && (!R.hasFocus || R.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                            },
                            enabled: function(e) {
                                return e.disabled === !1
                            },
                            disabled: function(e) {
                                return e.disabled === !0
                            },
                            checked: function(e) {
                                var t = e.nodeName.toLowerCase();
                                return "input" === t && !!e.checked || "option" === t && !!e.selected
                            },
                            selected: function(e) {
                                return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                            },
                            empty: function(e) {
                                for (e = e.firstChild; e; e = e.nextSibling)
                                    if (e.nodeType < 6) return !1;
                                return !0
                            },
                            parent: function(e) {
                                return !b.pseudos.empty(e)
                            },
                            header: function(e) {
                                return ve.test(e.nodeName)
                            },
                            input: function(e) {
                                return me.test(e.nodeName)
                            },
                            button: function(e) {
                                var t = e.nodeName.toLowerCase();
                                return "input" === t && "button" === e.type || "button" === t
                            },
                            text: function(e) {
                                var t;
                                return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                            },
                            first: c(function() {
                                return [0]
                            }),
                            last: c(function(e, t) {
                                return [t - 1]
                            }),
                            eq: c(function(e, t, n) {
                                return [0 > n ? n + t : n]
                            }),
                            even: c(function(e, t) {
                                for (var n = 0; t > n; n += 2) e.push(n);
                                return e
                            }),
                            odd: c(function(e, t) {
                                for (var n = 1; t > n; n += 2) e.push(n);
                                return e
                            }),
                            lt: c(function(e, t, n) {
                                for (var i = 0 > n ? n + t : n; --i >= 0;) e.push(i);
                                return e
                            }),
                            gt: c(function(e, t, n) {
                                for (var i = 0 > n ? n + t : n; ++i < t;) e.push(i);
                                return e
                            })
                        }
                    }, b.pseudos.nth = b.pseudos.eq;
                    for (w in {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    }) b.pseudos[w] = s(w);
                    for (w in {
                        submit: !0,
                        reset: !0
                    }) b.pseudos[w] = l(w);
                    return u.prototype = b.filters = b.pseudos, b.setFilters = new u, S = t.tokenize = function(e, n) {
                        var i, r, o, a, s, l, c, h = G[e + " "];
                        if (h) return n ? 0 : h.slice(0);
                        for (s = e, l = [], c = b.preFilter; s;) {
                            i && !(r = ce.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), i = !1, (r = he.exec(s)) && (i = r.shift(), o.push({
                                value: i,
                                type: r[0].replace(le, " ")
                            }), s = s.slice(i.length));
                            for (a in b.filter)!(r = pe[a].exec(s)) || c[a] && !(r = c[a](r)) || (i = r.shift(), o.push({
                                value: i,
                                type: a,
                                matches: r
                            }), s = s.slice(i.length));
                            if (!i) break
                        }
                        return n ? s.length : s ? t.error(e) : G(e, l).slice(0)
                    }, T = t.compile = function(e, t) {
                        var n, i = [],
                            r = [],
                            o = W[e + " "];
                        if (!o) {
                            for (t || (t = S(e)), n = t.length; n--;) o = y(t[n]), o[I] ? i.push(o) : r.push(o);
                            o = W(e, x(r, i)), o.selector = e
                        }
                        return o
                    }, C = t.select = function(e, t, n, i) {
                        var r, o, a, s, l, c = "function" == typeof e && e,
                            u = !i && S(e = c.selector || e);
                        if (n = n || [], 1 === u.length) {
                            if (o = u[0] = u[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && _.getById && 9 === t.nodeType && N && b.relative[o[1].type]) {
                                if (t = (b.find.ID(a.matches[0].replace(_e, be), t) || [])[0], !t) return n;
                                c && (t = t.parentNode), e = e.slice(o.shift().value.length)
                            }
                            for (r = pe.needsContext.test(e) ? 0 : o.length; r-- && (a = o[r], !b.relative[s = a.type]);)
                                if ((l = b.find[s]) && (i = l(a.matches[0].replace(_e, be), xe.test(o[0].type) && h(t.parentNode) || t))) {
                                    if (o.splice(r, 1), e = i.length && f(o), !e) return Z.apply(n, i), n;
                                    break
                                }
                        }
                        return (c || T(e, u))(i, t, !N, n, xe.test(e) && h(t.parentNode) || t), n
                    }, _.sortStable = I.split("").sort(X).join("") === I, _.detectDuplicates = !!D, L(), _.sortDetached = r(function(e) {
                        return 1 & e.compareDocumentPosition(R.createElement("div"))
                    }), r(function(e) {
                        return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                    }) || o("type|href|height|width", function(e, t, n) {
                        return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                    }), _.attributes && r(function(e) {
                        return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                    }) || o("value", function(e, t, n) {
                        return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
                    }), r(function(e) {
                        return null == e.getAttribute("disabled")
                    }) || o(te, function(e, t, n) {
                        var i;
                        return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
                    }), t
                }(e);
                Q.find = re, Q.expr = re.selectors, Q.expr[":"] = Q.expr.pseudos, Q.unique = re.uniqueSort, Q.text = re.getText, Q.isXMLDoc = re.isXML, Q.contains = re.contains;
                var oe = Q.expr.match.needsContext,
                    ae = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
                    se = /^.[^:#\[\.,]*$/;
                Q.filter = function(e, t, n) {
                    var i = t[0];
                    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? Q.find.matchesSelector(i, e) ? [i] : [] : Q.find.matches(e, Q.grep(t, function(e) {
                        return 1 === e.nodeType
                    }))
                }, Q.fn.extend({
                    find: function(e) {
                        var t, n = this.length,
                            i = [],
                            r = this;
                        if ("string" != typeof e) return this.pushStack(Q(e).filter(function() {
                            for (t = 0; n > t; t++)
                                if (Q.contains(r[t], this)) return !0
                        }));
                        for (t = 0; n > t; t++) Q.find(e, r[t], i);
                        return i = this.pushStack(n > 1 ? Q.unique(i) : i), i.selector = this.selector ? this.selector + " " + e : e, i
                    },
                    filter: function(e) {
                        return this.pushStack(i(this, e || [], !1))
                    },
                    not: function(e) {
                        return this.pushStack(i(this, e || [], !0))
                    },
                    is: function(e) {
                        return !!i(this, "string" == typeof e && oe.test(e) ? Q(e) : e || [], !1).length
                    }
                });
                var le, ce = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
                    he = Q.fn.init = function(e, t) {
                        var n, i;
                        if (!e) return this;
                        if ("string" == typeof e) {
                            if (n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : ce.exec(e), !n || !n[1] && t) return !t || t.jquery ? (t || le).find(e) : this.constructor(t).find(e);
                            if (n[1]) {
                                if (t = t instanceof Q ? t[0] : t, Q.merge(this, Q.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : J, !0)), ae.test(n[1]) && Q.isPlainObject(t))
                                    for (n in t) Q.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
                                return this
                            }
                            return i = J.getElementById(n[2]), i && i.parentNode && (this.length = 1, this[0] = i), this.context = J, this.selector = e, this
                        }
                        return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : Q.isFunction(e) ? "undefined" != typeof le.ready ? le.ready(e) : e(Q) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), Q.makeArray(e, this))
                    };
                he.prototype = Q.fn, le = Q(J);
                var ue = /^(?:parents|prev(?:Until|All))/,
                    fe = {
                        children: !0,
                        contents: !0,
                        next: !0,
                        prev: !0
                    };
                Q.extend({
                    dir: function(e, t, n) {
                        for (var i = [], r = void 0 !== n;
                             (e = e[t]) && 9 !== e.nodeType;)
                            if (1 === e.nodeType) {
                                if (r && Q(e).is(n)) break;
                                i.push(e)
                            }
                        return i
                    },
                    sibling: function(e, t) {
                        for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
                        return n
                    }
                }), Q.fn.extend({
                    has: function(e) {
                        var t = Q(e, this),
                            n = t.length;
                        return this.filter(function() {
                            for (var e = 0; n > e; e++)
                                if (Q.contains(this, t[e])) return !0
                        })
                    },
                    closest: function(e, t) {
                        for (var n, i = 0, r = this.length, o = [], a = oe.test(e) || "string" != typeof e ? Q(e, t || this.context) : 0; r > i; i++)
                            for (n = this[i]; n && n !== t; n = n.parentNode)
                                if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && Q.find.matchesSelector(n, e))) {
                                    o.push(n);
                                    break
                                }
                        return this.pushStack(o.length > 1 ? Q.unique(o) : o)
                    },
                    index: function(e) {
                        return e ? "string" == typeof e ? X.call(Q(e), this[0]) : X.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                    },
                    add: function(e, t) {
                        return this.pushStack(Q.unique(Q.merge(this.get(), Q(e, t))))
                    },
                    addBack: function(e) {
                        return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                    }
                }), Q.each({
                    parent: function(e) {
                        var t = e.parentNode;
                        return t && 11 !== t.nodeType ? t : null
                    },
                    parents: function(e) {
                        return Q.dir(e, "parentNode")
                    },
                    parentsUntil: function(e, t, n) {
                        return Q.dir(e, "parentNode", n)
                    },
                    next: function(e) {
                        return r(e, "nextSibling")
                    },
                    prev: function(e) {
                        return r(e, "previousSibling")
                    },
                    nextAll: function(e) {
                        return Q.dir(e, "nextSibling")
                    },
                    prevAll: function(e) {
                        return Q.dir(e, "previousSibling")
                    },
                    nextUntil: function(e, t, n) {
                        return Q.dir(e, "nextSibling", n)
                    },
                    prevUntil: function(e, t, n) {
                        return Q.dir(e, "previousSibling", n)
                    },
                    siblings: function(e) {
                        return Q.sibling((e.parentNode || {}).firstChild, e)
                    },
                    children: function(e) {
                        return Q.sibling(e.firstChild)
                    },
                    contents: function(e) {
                        return e.contentDocument || Q.merge([], e.childNodes)
                    }
                }, function(e, t) {
                    Q.fn[e] = function(n, i) {
                        var r = Q.map(this, t, n);
                        return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = Q.filter(i, r)), this.length > 1 && (fe[e] || Q.unique(r), ue.test(e) && r.reverse()), this.pushStack(r)
                    }
                });
                var de = /\S+/g,
                    pe = {};
                Q.Callbacks = function(e) {
                    e = "string" == typeof e ? pe[e] || o(e) : Q.extend({}, e);
                    var t, n, i, r, a, s, l = [],
                        c = !e.once && [],
                        h = function(o) {
                            for (t = e.memory && o, n = !0, s = r || 0, r = 0, a = l.length, i = !0; l && a > s; s++)
                                if (l[s].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
                                    t = !1;
                                    break
                                }
                            i = !1, l && (c ? c.length && h(c.shift()) : t ? l = [] : u.disable())
                        },
                        u = {
                            add: function() {
                                if (l) {
                                    var n = l.length;
                                    ! function o(t) {
                                        Q.each(t, function(t, n) {
                                            var i = Q.type(n);
                                            "function" === i ? e.unique && u.has(n) || l.push(n) : n && n.length && "string" !== i && o(n)
                                        })
                                    }(arguments), i ? a = l.length : t && (r = n, h(t))
                                }
                                return this
                            },
                            remove: function() {
                                return l && Q.each(arguments, function(e, t) {
                                    for (var n;
                                         (n = Q.inArray(t, l, n)) > -1;) l.splice(n, 1), i && (a >= n && a--, s >= n && s--)
                                }), this
                            },
                            has: function(e) {
                                return e ? Q.inArray(e, l) > -1 : !(!l || !l.length)
                            },
                            empty: function() {
                                return l = [], a = 0, this
                            },
                            disable: function() {
                                return l = c = t = void 0, this
                            },
                            disabled: function() {
                                return !l
                            },
                            lock: function() {
                                return c = void 0, t || u.disable(), this
                            },
                            locked: function() {
                                return !c
                            },
                            fireWith: function(e, t) {
                                return !l || n && !c || (t = t || [], t = [e, t.slice ? t.slice() : t], i ? c.push(t) : h(t)), this
                            },
                            fire: function() {
                                return u.fireWith(this, arguments), this
                            },
                            fired: function() {
                                return !!n
                            }
                        };
                    return u
                }, Q.extend({
                    Deferred: function(e) {
                        var t = [
                                ["resolve", "done", Q.Callbacks("once memory"), "resolved"],
                                ["reject", "fail", Q.Callbacks("once memory"), "rejected"],
                                ["notify", "progress", Q.Callbacks("memory")]
                            ],
                            n = "pending",
                            i = {
                                state: function() {
                                    return n
                                },
                                always: function() {
                                    return r.done(arguments).fail(arguments), this
                                },
                                then: function() {
                                    var e = arguments;
                                    return Q.Deferred(function(n) {
                                        Q.each(t, function(t, o) {
                                            var a = Q.isFunction(e[t]) && e[t];
                                            r[o[1]](function() {
                                                var e = a && a.apply(this, arguments);
                                                e && Q.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[o[0] + "With"](this === i ? n.promise() : this, a ? [e] : arguments)
                                            })
                                        }), e = null
                                    }).promise()
                                },
                                promise: function(e) {
                                    return null != e ? Q.extend(e, i) : i
                                }
                            },
                            r = {};
                        return i.pipe = i.then, Q.each(t, function(e, o) {
                            var a = o[2],
                                s = o[3];
                            i[o[1]] = a.add, s && a.add(function() {
                                n = s
                            }, t[1 ^ e][2].disable, t[2][2].lock), r[o[0]] = function() {
                                return r[o[0] + "With"](this === r ? i : this, arguments), this
                            }, r[o[0] + "With"] = a.fireWith
                        }), i.promise(r), e && e.call(r, r), r
                    },
                    when: function(e) {
                        var t, n, i, r = 0,
                            o = j.call(arguments),
                            a = o.length,
                            s = 1 !== a || e && Q.isFunction(e.promise) ? a : 0,
                            l = 1 === s ? e : Q.Deferred(),
                            c = function(e, n, i) {
                                return function(r) {
                                    n[e] = this, i[e] = arguments.length > 1 ? j.call(arguments) : r, i === t ? l.notifyWith(n, i) : --s || l.resolveWith(n, i)
                                }
                            };
                        if (a > 1)
                            for (t = new Array(a), n = new Array(a), i = new Array(a); a > r; r++) o[r] && Q.isFunction(o[r].promise) ? o[r].promise().done(c(r, i, o)).fail(l.reject).progress(c(r, n, t)) : --s;
                        return s || l.resolveWith(i, o), l.promise()
                    }
                });
                var me;
                Q.fn.ready = function(e) {
                    return Q.ready.promise().done(e), this
                }, Q.extend({
                    isReady: !1,
                    readyWait: 1,
                    holdReady: function(e) {
                        e ? Q.readyWait++ : Q.ready(!0)
                    },
                    ready: function(e) {
                        (e === !0 ? --Q.readyWait : Q.isReady) || (Q.isReady = !0, e !== !0 && --Q.readyWait > 0 || (me.resolveWith(J, [Q]), Q.fn.triggerHandler && (Q(J).triggerHandler("ready"), Q(J).off("ready"))))
                    }
                }), Q.ready.promise = function(t) {
                    return me || (me = Q.Deferred(), "complete" === J.readyState ? setTimeout(Q.ready) : (J.addEventListener("DOMContentLoaded", a, !1), e.addEventListener("load", a, !1))), me.promise(t)
                }, Q.ready.promise();
                var ve = Q.access = function(e, t, n, i, r, o, a) {
                    var s = 0,
                        l = e.length,
                        c = null == n;
                    if ("object" === Q.type(n)) {
                        r = !0;
                        for (s in n) Q.access(e, t, s, n[s], !0, o, a)
                    } else if (void 0 !== i && (r = !0, Q.isFunction(i) || (a = !0), c && (a ? (t.call(e, i), t = null) : (c = t, t = function(e, t, n) {
                            return c.call(Q(e), n)
                        })), t))
                        for (; l > s; s++) t(e[s], n, a ? i : i.call(e[s], s, t(e[s], n)));
                    return r ? e : c ? t.call(e) : l ? t(e[0], n) : o
                };
                Q.acceptData = function(e) {
                    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
                }, s.uid = 1, s.accepts = Q.acceptData, s.prototype = {
                    key: function(e) {
                        if (!s.accepts(e)) return 0;
                        var t = {},
                            n = e[this.expando];
                        if (!n) {
                            n = s.uid++;
                            try {
                                t[this.expando] = {
                                    value: n
                                }, Object.defineProperties(e, t)
                            } catch (i) {
                                t[this.expando] = n, Q.extend(e, t)
                            }
                        }
                        return this.cache[n] || (this.cache[n] = {}), n
                    },
                    set: function(e, t, n) {
                        var i, r = this.key(e),
                            o = this.cache[r];
                        if ("string" == typeof t) o[t] = n;
                        else if (Q.isEmptyObject(o)) Q.extend(this.cache[r], t);
                        else
                            for (i in t) o[i] = t[i];
                        return o
                    },
                    get: function(e, t) {
                        var n = this.cache[this.key(e)];
                        return void 0 === t ? n : n[t]
                    },
                    access: function(e, t, n) {
                        var i;
                        return void 0 === t || t && "string" == typeof t && void 0 === n ? (i = this.get(e, t), void 0 !== i ? i : this.get(e, Q.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t)
                    },
                    remove: function(e, t) {
                        var n, i, r, o = this.key(e),
                            a = this.cache[o];
                        if (void 0 === t) this.cache[o] = {};
                        else {
                            Q.isArray(t) ? i = t.concat(t.map(Q.camelCase)) : (r = Q.camelCase(t), t in a ? i = [t, r] : (i = r, i = i in a ? [i] : i.match(de) || [])), n = i.length;
                            for (; n--;) delete a[i[n]]
                        }
                    },
                    hasData: function(e) {
                        return !Q.isEmptyObject(this.cache[e[this.expando]] || {})
                    },
                    discard: function(e) {
                        e[this.expando] && delete this.cache[e[this.expando]]
                    }
                };
                var ge = new s,
                    ye = new s,
                    xe = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    we = /([A-Z])/g;
                Q.extend({
                    hasData: function(e) {
                        return ye.hasData(e) || ge.hasData(e)
                    },
                    data: function(e, t, n) {
                        return ye.access(e, t, n)
                    },
                    removeData: function(e, t) {
                        ye.remove(e, t)
                    },
                    _data: function(e, t, n) {
                        return ge.access(e, t, n)
                    },
                    _removeData: function(e, t) {
                        ge.remove(e, t)
                    }
                }), Q.fn.extend({
                    data: function(e, t) {
                        var n, i, r, o = this[0],
                            a = o && o.attributes;
                        if (void 0 === e) {
                            if (this.length && (r = ye.get(o), 1 === o.nodeType && !ge.get(o, "hasDataAttrs"))) {
                                for (n = a.length; n--;) a[n] && (i = a[n].name, 0 === i.indexOf("data-") && (i = Q.camelCase(i.slice(5)), l(o, i, r[i])));
                                ge.set(o, "hasDataAttrs", !0)
                            }
                            return r
                        }
                        return "object" == typeof e ? this.each(function() {
                            ye.set(this, e)
                        }) : ve(this, function(t) {
                            var n, i = Q.camelCase(e);
                            if (o && void 0 === t) {
                                if (n = ye.get(o, e), void 0 !== n) return n;
                                if (n = ye.get(o, i), void 0 !== n) return n;
                                if (n = l(o, i, void 0), void 0 !== n) return n
                            } else this.each(function() {
                                var n = ye.get(this, i);
                                ye.set(this, i, t), -1 !== e.indexOf("-") && void 0 !== n && ye.set(this, e, t)
                            })
                        }, null, t, arguments.length > 1, null, !0)
                    },
                    removeData: function(e) {
                        return this.each(function() {
                            ye.remove(this, e)
                        })
                    }
                }), Q.extend({
                    queue: function(e, t, n) {
                        var i;
                        return e ? (t = (t || "fx") + "queue", i = ge.get(e, t), n && (!i || Q.isArray(n) ? i = ge.access(e, t, Q.makeArray(n)) : i.push(n)), i || []) : void 0
                    },
                    dequeue: function(e, t) {
                        t = t || "fx";
                        var n = Q.queue(e, t),
                            i = n.length,
                            r = n.shift(),
                            o = Q._queueHooks(e, t),
                            a = function() {
                                Q.dequeue(e, t)
                            };
                        "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete o.stop, r.call(e, a, o)), !i && o && o.empty.fire()
                    },
                    _queueHooks: function(e, t) {
                        var n = t + "queueHooks";
                        return ge.get(e, n) || ge.access(e, n, {
                                empty: Q.Callbacks("once memory").add(function() {
                                    ge.remove(e, [t + "queue", n])
                                })
                            })
                    }
                }), Q.fn.extend({
                    queue: function(e, t) {
                        var n = 2;
                        return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? Q.queue(this[0], e) : void 0 === t ? this : this.each(function() {
                            var n = Q.queue(this, e, t);
                            Q._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && Q.dequeue(this, e)
                        })
                    },
                    dequeue: function(e) {
                        return this.each(function() {
                            Q.dequeue(this, e)
                        })
                    },
                    clearQueue: function(e) {
                        return this.queue(e || "fx", [])
                    },
                    promise: function(e, t) {
                        var n, i = 1,
                            r = Q.Deferred(),
                            o = this,
                            a = this.length,
                            s = function() {
                                --i || r.resolveWith(o, [o])
                            };
                        for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;) n = ge.get(o[a], e + "queueHooks"), n && n.empty && (i++, n.empty.add(s));
                        return s(), r.promise(t)
                    }
                });
                var _e = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                    be = ["Top", "Right", "Bottom", "Left"],
                    Ee = function(e, t) {
                        return e = t || e, "none" === Q.css(e, "display") || !Q.contains(e.ownerDocument, e)
                    },
                    Me = /^(?:checkbox|radio)$/i;
                ! function() {
                    var e = J.createDocumentFragment(),
                        t = e.appendChild(J.createElement("div")),
                        n = J.createElement("input");
                    n.setAttribute("type", "radio"), n.setAttribute("checked", "checked"), n.setAttribute("name", "t"), t.appendChild(n), $.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", $.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
                }();
                var Se = "undefined";
                $.focusinBubbles = "onfocusin" in e;
                var Te = /^key/,
                    Ce = /^(?:mouse|pointer|contextmenu)|click/,
                    Ae = /^(?:focusinfocus|focusoutblur)$/,
                    Pe = /^([^.]*)(?:\.(.+)|)$/;
                Q.event = {
                    global: {},
                    add: function(e, t, n, i, r) {
                        var o, a, s, l, c, h, u, f, d, p, m, v = ge.get(e);
                        if (v)
                            for (n.handler && (o = n, n = o.handler, r = o.selector), n.guid || (n.guid = Q.guid++), (l = v.events) || (l = v.events = {}), (a = v.handle) || (a = v.handle = function(t) {
                                return typeof Q !== Se && Q.event.triggered !== t.type ? Q.event.dispatch.apply(e, arguments) : void 0
                            }), t = (t || "").match(de) || [""], c = t.length; c--;) s = Pe.exec(t[c]) || [], d = m = s[1], p = (s[2] || "").split(".").sort(), d && (u = Q.event.special[d] || {}, d = (r ? u.delegateType : u.bindType) || d, u = Q.event.special[d] || {}, h = Q.extend({
                                type: d,
                                origType: m,
                                data: i,
                                handler: n,
                                guid: n.guid,
                                selector: r,
                                needsContext: r && Q.expr.match.needsContext.test(r),
                                namespace: p.join(".")
                            }, o), (f = l[d]) || (f = l[d] = [], f.delegateCount = 0, u.setup && u.setup.call(e, i, p, a) !== !1 || e.addEventListener && e.addEventListener(d, a, !1)), u.add && (u.add.call(e, h), h.handler.guid || (h.handler.guid = n.guid)), r ? f.splice(f.delegateCount++, 0, h) : f.push(h), Q.event.global[d] = !0)
                    },
                    remove: function(e, t, n, i, r) {
                        var o, a, s, l, c, h, u, f, d, p, m, v = ge.hasData(e) && ge.get(e);
                        if (v && (l = v.events)) {
                            for (t = (t || "").match(de) || [""], c = t.length; c--;)
                                if (s = Pe.exec(t[c]) || [], d = m = s[1], p = (s[2] || "").split(".").sort(), d) {
                                    for (u = Q.event.special[d] || {}, d = (i ? u.delegateType : u.bindType) || d, f = l[d] || [], s = s[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = f.length; o--;) h = f[o], !r && m !== h.origType || n && n.guid !== h.guid || s && !s.test(h.namespace) || i && i !== h.selector && ("**" !== i || !h.selector) || (f.splice(o, 1), h.selector && f.delegateCount--, u.remove && u.remove.call(e, h));
                                    a && !f.length && (u.teardown && u.teardown.call(e, p, v.handle) !== !1 || Q.removeEvent(e, d, v.handle), delete l[d])
                                } else
                                    for (d in l) Q.event.remove(e, d + t[c], n, i, !0);
                            Q.isEmptyObject(l) && (delete v.handle, ge.remove(e, "events"))
                        }
                    },
                    trigger: function(t, n, i, r) {
                        var o, a, s, l, c, h, u, f = [i || J],
                            d = Y.call(t, "type") ? t.type : t,
                            p = Y.call(t, "namespace") ? t.namespace.split(".") : [];
                        if (a = s = i = i || J, 3 !== i.nodeType && 8 !== i.nodeType && !Ae.test(d + Q.event.triggered) && (d.indexOf(".") >= 0 && (p = d.split("."), d = p.shift(), p.sort()), c = d.indexOf(":") < 0 && "on" + d, t = t[Q.expando] ? t : new Q.Event(d, "object" == typeof t && t), t.isTrigger = r ? 2 : 3, t.namespace = p.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), n = null == n ? [t] : Q.makeArray(n, [t]), u = Q.event.special[d] || {}, r || !u.trigger || u.trigger.apply(i, n) !== !1)) {
                            if (!r && !u.noBubble && !Q.isWindow(i)) {
                                for (l = u.delegateType || d, Ae.test(l + d) || (a = a.parentNode); a; a = a.parentNode) f.push(a), s = a;
                                s === (i.ownerDocument || J) && f.push(s.defaultView || s.parentWindow || e)
                            }
                            for (o = 0;
                                 (a = f[o++]) && !t.isPropagationStopped();) t.type = o > 1 ? l : u.bindType || d, h = (ge.get(a, "events") || {})[t.type] && ge.get(a, "handle"), h && h.apply(a, n), h = c && a[c], h && h.apply && Q.acceptData(a) && (t.result = h.apply(a, n), t.result === !1 && t.preventDefault());
                            return t.type = d, r || t.isDefaultPrevented() || u._default && u._default.apply(f.pop(), n) !== !1 || !Q.acceptData(i) || c && Q.isFunction(i[d]) && !Q.isWindow(i) && (s = i[c], s && (i[c] = null), Q.event.triggered = d, i[d](), Q.event.triggered = void 0, s && (i[c] = s)), t.result
                        }
                    },
                    dispatch: function(e) {
                        e = Q.event.fix(e);
                        var t, n, i, r, o, a = [],
                            s = j.call(arguments),
                            l = (ge.get(this, "events") || {})[e.type] || [],
                            c = Q.event.special[e.type] || {};
                        if (s[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {
                            for (a = Q.event.handlers.call(this, e, l), t = 0;
                                 (r = a[t++]) && !e.isPropagationStopped();)
                                for (e.currentTarget = r.elem, n = 0;
                                     (o = r.handlers[n++]) && !e.isImmediatePropagationStopped();) e.namespace_re && !e.namespace_re.test(o.namespace) || (e.handleObj = o, e.data = o.data, i = ((Q.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, s), void 0 !== i && (e.result = i) === !1 && (e.preventDefault(), e.stopPropagation()));
                            return c.postDispatch && c.postDispatch.call(this, e), e.result
                        }
                    },
                    handlers: function(e, t) {
                        var n, i, r, o, a = [],
                            s = t.delegateCount,
                            l = e.target;
                        if (s && l.nodeType && (!e.button || "click" !== e.type))
                            for (; l !== this; l = l.parentNode || this)
                                if (l.disabled !== !0 || "click" !== e.type) {
                                    for (i = [], n = 0; s > n; n++) o = t[n], r = o.selector + " ", void 0 === i[r] && (i[r] = o.needsContext ? Q(r, this).index(l) >= 0 : Q.find(r, this, null, [l]).length), i[r] && i.push(o);
                                    i.length && a.push({
                                        elem: l,
                                        handlers: i
                                    })
                                }
                        return s < t.length && a.push({
                            elem: this,
                            handlers: t.slice(s)
                        }), a
                    },
                    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                    fixHooks: {},
                    keyHooks: {
                        props: "char charCode key keyCode".split(" "),
                        filter: function(e, t) {
                            return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
                        }
                    },
                    mouseHooks: {
                        props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                        filter: function(e, t) {
                            var n, i, r, o = t.button;
                            return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || J, i = n.documentElement, r = n.body, e.pageX = t.clientX + (i && i.scrollLeft || r && r.scrollLeft || 0) - (i && i.clientLeft || r && r.clientLeft || 0), e.pageY = t.clientY + (i && i.scrollTop || r && r.scrollTop || 0) - (i && i.clientTop || r && r.clientTop || 0)), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
                        }
                    },
                    fix: function(e) {
                        if (e[Q.expando]) return e;
                        var t, n, i, r = e.type,
                            o = e,
                            a = this.fixHooks[r];
                        for (a || (this.fixHooks[r] = a = Ce.test(r) ? this.mouseHooks : Te.test(r) ? this.keyHooks : {}), i = a.props ? this.props.concat(a.props) : this.props, e = new Q.Event(o), t = i.length; t--;) n = i[t], e[n] = o[n];
                        return e.target || (e.target = J), 3 === e.target.nodeType && (e.target = e.target.parentNode), a.filter ? a.filter(e, o) : e
                    },
                    special: {
                        load: {
                            noBubble: !0
                        },
                        focus: {
                            trigger: function() {
                                return this !== u() && this.focus ? (this.focus(), !1) : void 0
                            },
                            delegateType: "focusin"
                        },
                        blur: {
                            trigger: function() {
                                return this === u() && this.blur ? (this.blur(), !1) : void 0
                            },
                            delegateType: "focusout"
                        },
                        click: {
                            trigger: function() {
                                return "checkbox" === this.type && this.click && Q.nodeName(this, "input") ? (this.click(), !1) : void 0
                            },
                            _default: function(e) {
                                return Q.nodeName(e.target, "a")
                            }
                        },
                        beforeunload: {
                            postDispatch: function(e) {
                                void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                            }
                        }
                    },
                    simulate: function(e, t, n, i) {
                        var r = Q.extend(new Q.Event, n, {
                            type: e,
                            isSimulated: !0,
                            originalEvent: {}
                        });
                        i ? Q.event.trigger(r, null, t) : Q.event.dispatch.call(t, r), r.isDefaultPrevented() && n.preventDefault()
                    }
                }, Q.removeEvent = function(e, t, n) {
                    e.removeEventListener && e.removeEventListener(t, n, !1)
                }, Q.Event = function(e, t) {
                    return this instanceof Q.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? c : h) : this.type = e, t && Q.extend(this, t), this.timeStamp = e && e.timeStamp || Q.now(), void(this[Q.expando] = !0)) : new Q.Event(e, t)
                }, Q.Event.prototype = {
                    isDefaultPrevented: h,
                    isPropagationStopped: h,
                    isImmediatePropagationStopped: h,
                    preventDefault: function() {
                        var e = this.originalEvent;
                        this.isDefaultPrevented = c, e && e.preventDefault && e.preventDefault()
                    },
                    stopPropagation: function() {
                        var e = this.originalEvent;
                        this.isPropagationStopped = c, e && e.stopPropagation && e.stopPropagation()
                    },
                    stopImmediatePropagation: function() {
                        var e = this.originalEvent;
                        this.isImmediatePropagationStopped = c, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
                    }
                }, Q.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function(e, t) {
                    Q.event.special[e] = {
                        delegateType: t,
                        bindType: t,
                        handle: function(e) {
                            var n, i = this,
                                r = e.relatedTarget,
                                o = e.handleObj;
                            return r && (r === i || Q.contains(i, r)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
                        }
                    }
                }), $.focusinBubbles || Q.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function(e, t) {
                    var n = function(e) {
                        Q.event.simulate(t, e.target, Q.event.fix(e), !0)
                    };
                    Q.event.special[t] = {
                        setup: function() {
                            var i = this.ownerDocument || this,
                                r = ge.access(i, t);
                            r || i.addEventListener(e, n, !0), ge.access(i, t, (r || 0) + 1)
                        },
                        teardown: function() {
                            var i = this.ownerDocument || this,
                                r = ge.access(i, t) - 1;
                            r ? ge.access(i, t, r) : (i.removeEventListener(e, n, !0), ge.remove(i, t))
                        }
                    }
                }), Q.fn.extend({
                    on: function(e, t, n, i, r) {
                        var o, a;
                        if ("object" == typeof e) {
                            "string" != typeof t && (n = n || t, t = void 0);
                            for (a in e) this.on(a, t, n, e[a], r);
                            return this
                        }
                        if (null == n && null == i ? (i = t, n = t = void 0) : null == i && ("string" == typeof t ? (i = n, n = void 0) : (i = n, n = t, t = void 0)), i === !1) i = h;
                        else if (!i) return this;
                        return 1 === r && (o = i, i = function(e) {
                            return Q().off(e), o.apply(this, arguments)
                        }, i.guid = o.guid || (o.guid = Q.guid++)), this.each(function() {
                            Q.event.add(this, e, i, n, t)
                        })
                    },
                    one: function(e, t, n, i) {
                        return this.on(e, t, n, i, 1)
                    },
                    off: function(e, t, n) {
                        var i, r;
                        if (e && e.preventDefault && e.handleObj) return i = e.handleObj, Q(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                        if ("object" == typeof e) {
                            for (r in e) this.off(r, t, e[r]);
                            return this
                        }
                        return t !== !1 && "function" != typeof t || (n = t, t = void 0), n === !1 && (n = h), this.each(function() {
                            Q.event.remove(this, e, n, t)
                        })
                    },
                    trigger: function(e, t) {
                        return this.each(function() {
                            Q.event.trigger(e, t, this)
                        })
                    },
                    triggerHandler: function(e, t) {
                        var n = this[0];
                        return n ? Q.event.trigger(e, t, n, !0) : void 0
                    }
                });
                var De = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                    Le = /<([\w:]+)/,
                    Re = /<|&#?\w+;/,
                    Oe = /<(?:script|style|link)/i,
                    Ne = /checked\s*(?:[^=]|=\s*.checked.)/i,
                    Ue = /^$|\/(?:java|ecma)script/i,
                    Fe = /^true\/(.*)/,
                    ke = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
                    He = {
                        option: [1, "<select multiple='multiple'>", "</select>"],
                        thead: [1, "<table>", "</table>"],
                        col: [2, "<table><colgroup>", "</colgroup></table>"],
                        tr: [2, "<table><tbody>", "</tbody></table>"],
                        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                        _default: [0, "", ""]
                    };
                He.optgroup = He.option, He.tbody = He.tfoot = He.colgroup = He.caption = He.thead, He.th = He.td, Q.extend({
                    clone: function(e, t, n) {
                        var i, r, o, a, s = e.cloneNode(!0),
                            l = Q.contains(e.ownerDocument, e);
                        if (!($.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || Q.isXMLDoc(e)))
                            for (a = g(s), o = g(e), i = 0, r = o.length; r > i; i++) y(o[i], a[i]);
                        if (t)
                            if (n)
                                for (o = o || g(e), a = a || g(s), i = 0, r = o.length; r > i; i++) v(o[i], a[i]);
                            else v(e, s);
                        return a = g(s, "script"), a.length > 0 && m(a, !l && g(e, "script")), s
                    },
                    buildFragment: function(e, t, n, i) {
                        for (var r, o, a, s, l, c, h = t.createDocumentFragment(), u = [], f = 0, d = e.length; d > f; f++)
                            if (r = e[f], r || 0 === r)
                                if ("object" === Q.type(r)) Q.merge(u, r.nodeType ? [r] : r);
                                else if (Re.test(r)) {
                                    for (o = o || h.appendChild(t.createElement("div")), a = (Le.exec(r) || ["", ""])[1].toLowerCase(), s = He[a] || He._default, o.innerHTML = s[1] + r.replace(De, "<$1></$2>") + s[2], c = s[0]; c--;) o = o.lastChild;
                                    Q.merge(u, o.childNodes), o = h.firstChild, o.textContent = ""
                                } else u.push(t.createTextNode(r));
                        for (h.textContent = "", f = 0; r = u[f++];)
                            if ((!i || -1 === Q.inArray(r, i)) && (l = Q.contains(r.ownerDocument, r), o = g(h.appendChild(r), "script"), l && m(o), n))
                                for (c = 0; r = o[c++];) Ue.test(r.type || "") && n.push(r);
                        return h
                    },
                    cleanData: function(e) {
                        for (var t, n, i, r, o = Q.event.special, a = 0; void 0 !== (n = e[a]); a++) {
                            if (Q.acceptData(n) && (r = n[ge.expando], r && (t = ge.cache[r]))) {
                                if (t.events)
                                    for (i in t.events) o[i] ? Q.event.remove(n, i) : Q.removeEvent(n, i, t.handle);
                                ge.cache[r] && delete ge.cache[r]
                            }
                            delete ye.cache[n[ye.expando]]
                        }
                    }
                }), Q.fn.extend({
                    text: function(e) {
                        return ve(this, function(e) {
                            return void 0 === e ? Q.text(this) : this.empty().each(function() {
                                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                            })
                        }, null, e, arguments.length)
                    },
                    append: function() {
                        return this.domManip(arguments, function(e) {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                                var t = f(this, e);
                                t.appendChild(e)
                            }
                        })
                    },
                    prepend: function() {
                        return this.domManip(arguments, function(e) {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                                var t = f(this, e);
                                t.insertBefore(e, t.firstChild)
                            }
                        })
                    },
                    before: function() {
                        return this.domManip(arguments, function(e) {
                            this.parentNode && this.parentNode.insertBefore(e, this)
                        })
                    },
                    after: function() {
                        return this.domManip(arguments, function(e) {
                            this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                        })
                    },
                    remove: function(e, t) {
                        for (var n, i = e ? Q.filter(e, this) : this, r = 0; null != (n = i[r]); r++) t || 1 !== n.nodeType || Q.cleanData(g(n)), n.parentNode && (t && Q.contains(n.ownerDocument, n) && m(g(n, "script")), n.parentNode.removeChild(n));
                        return this
                    },
                    empty: function() {
                        for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (Q.cleanData(g(e, !1)), e.textContent = "");
                        return this
                    },
                    clone: function(e, t) {
                        return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
                            return Q.clone(this, e, t)
                        })
                    },
                    html: function(e) {
                        return ve(this, function(e) {
                            var t = this[0] || {},
                                n = 0,
                                i = this.length;
                            if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                            if ("string" == typeof e && !Oe.test(e) && !He[(Le.exec(e) || ["", ""])[1].toLowerCase()]) {
                                e = e.replace(De, "<$1></$2>");
                                try {
                                    for (; i > n; n++) t = this[n] || {}, 1 === t.nodeType && (Q.cleanData(g(t, !1)), t.innerHTML = e);
                                    t = 0
                                } catch (r) {}
                            }
                            t && this.empty().append(e)
                        }, null, e, arguments.length)
                    },
                    replaceWith: function() {
                        var e = arguments[0];
                        return this.domManip(arguments, function(t) {
                            e = this.parentNode, Q.cleanData(g(this)), e && e.replaceChild(t, this)
                        }), e && (e.length || e.nodeType) ? this : this.remove()
                    },
                    detach: function(e) {
                        return this.remove(e, !0)
                    },
                    domManip: function(e, t) {
                        e = G.apply([], e);
                        var n, i, r, o, a, s, l = 0,
                            c = this.length,
                            h = this,
                            u = c - 1,
                            f = e[0],
                            m = Q.isFunction(f);
                        if (m || c > 1 && "string" == typeof f && !$.checkClone && Ne.test(f)) return this.each(function(n) {
                            var i = h.eq(n);
                            m && (e[0] = f.call(this, n, i.html())), i.domManip(e, t)
                        });
                        if (c && (n = Q.buildFragment(e, this[0].ownerDocument, !1, this), i = n.firstChild, 1 === n.childNodes.length && (n = i), i)) {
                            for (r = Q.map(g(n, "script"), d), o = r.length; c > l; l++) a = n, l !== u && (a = Q.clone(a, !0, !0), o && Q.merge(r, g(a, "script"))), t.call(this[l], a, l);
                            if (o)
                                for (s = r[r.length - 1].ownerDocument, Q.map(r, p), l = 0; o > l; l++) a = r[l], Ue.test(a.type || "") && !ge.access(a, "globalEval") && Q.contains(s, a) && (a.src ? Q._evalUrl && Q._evalUrl(a.src) : Q.globalEval(a.textContent.replace(ke, "")))
                        }
                        return this
                    }
                }), Q.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function(e, t) {
                    Q.fn[e] = function(e) {
                        for (var n, i = [], r = Q(e), o = r.length - 1, a = 0; o >= a; a++) n = a === o ? this : this.clone(!0), Q(r[a])[t](n), W.apply(i, n.get());
                        return this.pushStack(i)
                    }
                });
                var Ie, Ve = {},
                    ze = /^margin/,
                    Be = new RegExp("^(" + _e + ")(?!px)[a-z%]+$", "i"),
                    je = function(t) {
                        return t.ownerDocument.defaultView.opener ? t.ownerDocument.defaultView.getComputedStyle(t, null) : e.getComputedStyle(t, null)
                    };
                ! function() {
                    function t() {
                        a.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", a.innerHTML = "", r.appendChild(o);
                        var t = e.getComputedStyle(a, null);
                        n = "1%" !== t.top, i = "4px" === t.width, r.removeChild(o)
                    }
                    var n, i, r = J.documentElement,
                        o = J.createElement("div"),
                        a = J.createElement("div");
                    a.style && (a.style.backgroundClip = "content-box", a.cloneNode(!0).style.backgroundClip = "", $.clearCloneStyle = "content-box" === a.style.backgroundClip, o.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", o.appendChild(a), e.getComputedStyle && Q.extend($, {
                        pixelPosition: function() {
                            return t(), n
                        },
                        boxSizingReliable: function() {
                            return null == i && t(), i
                        },
                        reliableMarginRight: function() {
                            var t, n = a.appendChild(J.createElement("div"));
                            return n.style.cssText = a.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", n.style.marginRight = n.style.width = "0", a.style.width = "1px", r.appendChild(o), t = !parseFloat(e.getComputedStyle(n, null).marginRight), r.removeChild(o), a.removeChild(n), t
                        }
                    }))
                }(), Q.swap = function(e, t, n, i) {
                    var r, o, a = {};
                    for (o in t) a[o] = e.style[o], e.style[o] = t[o];
                    r = n.apply(e, i || []);
                    for (o in t) e.style[o] = a[o];
                    return r
                };
                var Ge = /^(none|table(?!-c[ea]).+)/,
                    We = new RegExp("^(" + _e + ")(.*)$", "i"),
                    Xe = new RegExp("^([+-])=(" + _e + ")", "i"),
                    qe = {
                        position: "absolute",
                        visibility: "hidden",
                        display: "block"
                    },
                    Ke = {
                        letterSpacing: "0",
                        fontWeight: "400"
                    },
                    Ye = ["Webkit", "O", "Moz", "ms"];
                Q.extend({
                    cssHooks: {
                        opacity: {
                            get: function(e, t) {
                                if (t) {
                                    var n = _(e, "opacity");
                                    return "" === n ? "1" : n
                                }
                            }
                        }
                    },
                    cssNumber: {
                        columnCount: !0,
                        fillOpacity: !0,
                        flexGrow: !0,
                        flexShrink: !0,
                        fontWeight: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0
                    },
                    cssProps: {
                        "float": "cssFloat"
                    },
                    style: function(e, t, n, i) {
                        if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                            var r, o, a, s = Q.camelCase(t),
                                l = e.style;
                            return t = Q.cssProps[s] || (Q.cssProps[s] = E(l, s)), a = Q.cssHooks[t] || Q.cssHooks[s], void 0 === n ? a && "get" in a && void 0 !== (r = a.get(e, !1, i)) ? r : l[t] : (o = typeof n, "string" === o && (r = Xe.exec(n)) && (n = (r[1] + 1) * r[2] + parseFloat(Q.css(e, t)), o = "number"), null != n && n === n && ("number" !== o || Q.cssNumber[s] || (n += "px"), $.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, i)) || (l[t] = n)), void 0)
                        }
                    },
                    css: function(e, t, n, i) {
                        var r, o, a, s = Q.camelCase(t);
                        return t = Q.cssProps[s] || (Q.cssProps[s] = E(e.style, s)), a = Q.cssHooks[t] || Q.cssHooks[s], a && "get" in a && (r = a.get(e, !0, n)), void 0 === r && (r = _(e, t, i)), "normal" === r && t in Ke && (r = Ke[t]), "" === n || n ? (o = parseFloat(r), n === !0 || Q.isNumeric(o) ? o || 0 : r) : r
                    }
                }), Q.each(["height", "width"], function(e, t) {
                    Q.cssHooks[t] = {
                        get: function(e, n, i) {
                            return n ? Ge.test(Q.css(e, "display")) && 0 === e.offsetWidth ? Q.swap(e, qe, function() {
                                return T(e, t, i)
                            }) : T(e, t, i) : void 0
                        },
                        set: function(e, n, i) {
                            var r = i && je(e);
                            return M(e, n, i ? S(e, t, i, "border-box" === Q.css(e, "boxSizing", !1, r), r) : 0)
                        }
                    }
                }), Q.cssHooks.marginRight = b($.reliableMarginRight, function(e, t) {
                    return t ? Q.swap(e, {
                        display: "inline-block"
                    }, _, [e, "marginRight"]) : void 0
                }), Q.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function(e, t) {
                    Q.cssHooks[e + t] = {
                        expand: function(n) {
                            for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; 4 > i; i++) r[e + be[i] + t] = o[i] || o[i - 2] || o[0];
                            return r
                        }
                    }, ze.test(e) || (Q.cssHooks[e + t].set = M)
                }), Q.fn.extend({
                    css: function(e, t) {
                        return ve(this, function(e, t, n) {
                            var i, r, o = {},
                                a = 0;
                            if (Q.isArray(t)) {
                                for (i = je(e), r = t.length; r > a; a++) o[t[a]] = Q.css(e, t[a], !1, i);
                                return o
                            }
                            return void 0 !== n ? Q.style(e, t, n) : Q.css(e, t)
                        }, e, t, arguments.length > 1)
                    },
                    show: function() {
                        return C(this, !0)
                    },
                    hide: function() {
                        return C(this)
                    },
                    toggle: function(e) {
                        return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                            Ee(this) ? Q(this).show() : Q(this).hide()
                        })
                    }
                }), Q.Tween = A, A.prototype = {
                    constructor: A,
                    init: function(e, t, n, i, r, o) {
                        this.elem = e, this.prop = n, this.easing = r || "swing", this.options = t, this.start = this.now = this.cur(), this.end = i, this.unit = o || (Q.cssNumber[n] ? "" : "px")
                    },
                    cur: function() {
                        var e = A.propHooks[this.prop];
                        return e && e.get ? e.get(this) : A.propHooks._default.get(this)
                    },
                    run: function(e) {
                        var t, n = A.propHooks[this.prop];
                        return this.options.duration ? this.pos = t = Q.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : A.propHooks._default.set(this), this
                    }
                }, A.prototype.init.prototype = A.prototype, A.propHooks = {
                    _default: {
                        get: function(e) {
                            var t;
                            return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = Q.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
                        },
                        set: function(e) {
                            Q.fx.step[e.prop] ? Q.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[Q.cssProps[e.prop]] || Q.cssHooks[e.prop]) ? Q.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
                        }
                    }
                }, A.propHooks.scrollTop = A.propHooks.scrollLeft = {
                    set: function(e) {
                        e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
                    }
                }, Q.easing = {
                    linear: function(e) {
                        return e
                    },
                    swing: function(e) {
                        return .5 - Math.cos(e * Math.PI) / 2
                    }
                }, Q.fx = A.prototype.init, Q.fx.step = {};
                var $e, Je, Ze = /^(?:toggle|show|hide)$/,
                    Qe = new RegExp("^(?:([+-])=|)(" + _e + ")([a-z%]*)$", "i"),
                    et = /queueHooks$/,
                    tt = [R],
                    nt = {
                        "*": [
                            function(e, t) {
                                var n = this.createTween(e, t),
                                    i = n.cur(),
                                    r = Qe.exec(t),
                                    o = r && r[3] || (Q.cssNumber[e] ? "" : "px"),
                                    a = (Q.cssNumber[e] || "px" !== o && +i) && Qe.exec(Q.css(n.elem, e)),
                                    s = 1,
                                    l = 20;
                                if (a && a[3] !== o) {
                                    o = o || a[3], r = r || [], a = +i || 1;
                                    do s = s || ".5", a /= s, Q.style(n.elem, e, a + o); while (s !== (s = n.cur() / i) && 1 !== s && --l)
                                }
                                return r && (a = n.start = +a || +i || 0, n.unit = o, n.end = r[1] ? a + (r[1] + 1) * r[2] : +r[2]), n
                            }
                        ]
                    };
                Q.Animation = Q.extend(N, {
                    tweener: function(e, t) {
                        Q.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
                        for (var n, i = 0, r = e.length; r > i; i++) n = e[i], nt[n] = nt[n] || [], nt[n].unshift(t)
                    },
                    prefilter: function(e, t) {
                        t ? tt.unshift(e) : tt.push(e)
                    }
                }), Q.speed = function(e, t, n) {
                    var i = e && "object" == typeof e ? Q.extend({}, e) : {
                        complete: n || !n && t || Q.isFunction(e) && e,
                        duration: e,
                        easing: n && t || t && !Q.isFunction(t) && t
                    };
                    return i.duration = Q.fx.off ? 0 : "number" == typeof i.duration ? i.duration : i.duration in Q.fx.speeds ? Q.fx.speeds[i.duration] : Q.fx.speeds._default, null != i.queue && i.queue !== !0 || (i.queue = "fx"), i.old = i.complete, i.complete = function() {
                        Q.isFunction(i.old) && i.old.call(this), i.queue && Q.dequeue(this, i.queue)
                    }, i
                }, Q.fn.extend({
                    fadeTo: function(e, t, n, i) {
                        return this.filter(Ee).css("opacity", 0).show().end().animate({
                            opacity: t
                        }, e, n, i)
                    },
                    animate: function(e, t, n, i) {
                        var r = Q.isEmptyObject(e),
                            o = Q.speed(t, n, i),
                            a = function() {
                                var t = N(this, Q.extend({}, e), o);
                                (r || ge.get(this, "finish")) && t.stop(!0)
                            };
                        return a.finish = a, r || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
                    },
                    stop: function(e, t, n) {
                        var i = function(e) {
                            var t = e.stop;
                            delete e.stop, t(n)
                        };
                        return "string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function() {
                            var t = !0,
                                r = null != e && e + "queueHooks",
                                o = Q.timers,
                                a = ge.get(this);
                            if (r) a[r] && a[r].stop && i(a[r]);
                            else
                                for (r in a) a[r] && a[r].stop && et.test(r) && i(a[r]);
                            for (r = o.length; r--;) o[r].elem !== this || null != e && o[r].queue !== e || (o[r].anim.stop(n), t = !1, o.splice(r, 1));
                            !t && n || Q.dequeue(this, e)
                        })
                    },
                    finish: function(e) {
                        return e !== !1 && (e = e || "fx"), this.each(function() {
                            var t, n = ge.get(this),
                                i = n[e + "queue"],
                                r = n[e + "queueHooks"],
                                o = Q.timers,
                                a = i ? i.length : 0;
                            for (n.finish = !0, Q.queue(this, e, []), r && r.stop && r.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                            for (t = 0; a > t; t++) i[t] && i[t].finish && i[t].finish.call(this);
                            delete n.finish
                        })
                    }
                }), Q.each(["toggle", "show", "hide"], function(e, t) {
                    var n = Q.fn[t];
                    Q.fn[t] = function(e, i, r) {
                        return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(D(t, !0), e, i, r)
                    }
                }), Q.each({
                    slideDown: D("show"),
                    slideUp: D("hide"),
                    slideToggle: D("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(e, t) {
                    Q.fn[e] = function(e, n, i) {
                        return this.animate(t, e, n, i)
                    }
                }), Q.timers = [], Q.fx.tick = function() {
                    var e, t = 0,
                        n = Q.timers;
                    for ($e = Q.now(); t < n.length; t++) e = n[t], e() || n[t] !== e || n.splice(t--, 1);
                    n.length || Q.fx.stop(), $e = void 0
                }, Q.fx.timer = function(e) {
                    Q.timers.push(e), e() ? Q.fx.start() : Q.timers.pop()
                }, Q.fx.interval = 13, Q.fx.start = function() {
                    Je || (Je = setInterval(Q.fx.tick, Q.fx.interval))
                }, Q.fx.stop = function() {
                    clearInterval(Je), Je = null
                }, Q.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                }, Q.fn.delay = function(e, t) {
                    return e = Q.fx ? Q.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) {
                        var i = setTimeout(t, e);
                        n.stop = function() {
                            clearTimeout(i)
                        }
                    })
                },
                    function() {
                        var e = J.createElement("input"),
                            t = J.createElement("select"),
                            n = t.appendChild(J.createElement("option"));
                        e.type = "checkbox", $.checkOn = "" !== e.value, $.optSelected = n.selected, t.disabled = !0, $.optDisabled = !n.disabled, e = J.createElement("input"), e.value = "t", e.type = "radio", $.radioValue = "t" === e.value
                    }();
                var it, rt, ot = Q.expr.attrHandle;
                Q.fn.extend({
                    attr: function(e, t) {
                        return ve(this, Q.attr, e, t, arguments.length > 1)
                    },
                    removeAttr: function(e) {
                        return this.each(function() {
                            Q.removeAttr(this, e)
                        })
                    }
                }), Q.extend({
                    attr: function(e, t, n) {
                        var i, r, o = e.nodeType;
                        if (e && 3 !== o && 8 !== o && 2 !== o) return typeof e.getAttribute === Se ? Q.prop(e, t, n) : (1 === o && Q.isXMLDoc(e) || (t = t.toLowerCase(), i = Q.attrHooks[t] || (Q.expr.match.bool.test(t) ? rt : it)), void 0 === n ? i && "get" in i && null !== (r = i.get(e, t)) ? r : (r = Q.find.attr(e, t), null == r ? void 0 : r) : null !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : void Q.removeAttr(e, t))
                    },
                    removeAttr: function(e, t) {
                        var n, i, r = 0,
                            o = t && t.match(de);
                        if (o && 1 === e.nodeType)
                            for (; n = o[r++];) i = Q.propFix[n] || n, Q.expr.match.bool.test(n) && (e[i] = !1), e.removeAttribute(n)
                    },
                    attrHooks: {
                        type: {
                            set: function(e, t) {
                                if (!$.radioValue && "radio" === t && Q.nodeName(e, "input")) {
                                    var n = e.value;
                                    return e.setAttribute("type", t), n && (e.value = n), t
                                }
                            }
                        }
                    }
                }), rt = {
                    set: function(e, t, n) {
                        return t === !1 ? Q.removeAttr(e, n) : e.setAttribute(n, n), n
                    }
                }, Q.each(Q.expr.match.bool.source.match(/\w+/g), function(e, t) {
                    var n = ot[t] || Q.find.attr;
                    ot[t] = function(e, t, i) {
                        var r, o;
                        return i || (o = ot[t], ot[t] = r, r = null != n(e, t, i) ? t.toLowerCase() : null, ot[t] = o), r
                    }
                });
                var at = /^(?:input|select|textarea|button)$/i;
                Q.fn.extend({
                    prop: function(e, t) {
                        return ve(this, Q.prop, e, t, arguments.length > 1)
                    },
                    removeProp: function(e) {
                        return this.each(function() {
                            delete this[Q.propFix[e] || e]
                        })
                    }
                }), Q.extend({
                    propFix: {
                        "for": "htmlFor",
                        "class": "className"
                    },
                    prop: function(e, t, n) {
                        var i, r, o, a = e.nodeType;
                        if (e && 3 !== a && 8 !== a && 2 !== a) return o = 1 !== a || !Q.isXMLDoc(e), o && (t = Q.propFix[t] || t, r = Q.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t]
                    },
                    propHooks: {
                        tabIndex: {
                            get: function(e) {
                                return e.hasAttribute("tabindex") || at.test(e.nodeName) || e.href ? e.tabIndex : -1
                            }
                        }
                    }
                }), $.optSelected || (Q.propHooks.selected = {
                    get: function(e) {
                        var t = e.parentNode;
                        return t && t.parentNode && t.parentNode.selectedIndex, null
                    }
                }), Q.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                    Q.propFix[this.toLowerCase()] = this
                });
                var st = /[\t\r\n\f]/g;
                Q.fn.extend({
                    addClass: function(e) {
                        var t, n, i, r, o, a, s = "string" == typeof e && e,
                            l = 0,
                            c = this.length;
                        if (Q.isFunction(e)) return this.each(function(t) {
                            Q(this).addClass(e.call(this, t, this.className))
                        });
                        if (s)
                            for (t = (e || "").match(de) || []; c > l; l++)
                                if (n = this[l], i = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(st, " ") : " ")) {
                                    for (o = 0; r = t[o++];) i.indexOf(" " + r + " ") < 0 && (i += r + " ");
                                    a = Q.trim(i), n.className !== a && (n.className = a)
                                }
                        return this
                    },
                    removeClass: function(e) {
                        var t, n, i, r, o, a, s = 0 === arguments.length || "string" == typeof e && e,
                            l = 0,
                            c = this.length;
                        if (Q.isFunction(e)) return this.each(function(t) {
                            Q(this).removeClass(e.call(this, t, this.className))
                        });
                        if (s)
                            for (t = (e || "").match(de) || []; c > l; l++)
                                if (n = this[l], i = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(st, " ") : "")) {
                                    for (o = 0; r = t[o++];)
                                        for (; i.indexOf(" " + r + " ") >= 0;) i = i.replace(" " + r + " ", " ");
                                    a = e ? Q.trim(i) : "", n.className !== a && (n.className = a)
                                }
                        return this
                    },
                    toggleClass: function(e, t) {
                        var n = typeof e;
                        return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : Q.isFunction(e) ? this.each(function(n) {
                            Q(this).toggleClass(e.call(this, n, this.className, t), t)
                        }) : this.each(function() {
                            if ("string" === n)
                                for (var t, i = 0, r = Q(this), o = e.match(de) || []; t = o[i++];) r.hasClass(t) ? r.removeClass(t) : r.addClass(t);
                            else n !== Se && "boolean" !== n || (this.className && ge.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : ge.get(this, "__className__") || "")
                        })
                    },
                    hasClass: function(e) {
                        for (var t = " " + e + " ", n = 0, i = this.length; i > n; n++)
                            if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(st, " ").indexOf(t) >= 0) return !0;
                        return !1
                    }
                });
                var lt = /\r/g;
                Q.fn.extend({
                    val: function(e) {
                        var t, n, i, r = this[0]; {
                            if (arguments.length) return i = Q.isFunction(e), this.each(function(n) {
                                var r;
                                1 === this.nodeType && (r = i ? e.call(this, n, Q(this).val()) : e, null == r ? r = "" : "number" == typeof r ? r += "" : Q.isArray(r) && (r = Q.map(r, function(e) {
                                    return null == e ? "" : e + ""
                                })), t = Q.valHooks[this.type] || Q.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r))
                            });
                            if (r) return t = Q.valHooks[r.type] || Q.valHooks[r.nodeName.toLowerCase()], t && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : (n = r.value, "string" == typeof n ? n.replace(lt, "") : null == n ? "" : n)
                        }
                    }
                }), Q.extend({
                    valHooks: {
                        option: {
                            get: function(e) {
                                var t = Q.find.attr(e, "value");
                                return null != t ? t : Q.trim(Q.text(e))
                            }
                        },
                        select: {
                            get: function(e) {
                                for (var t, n, i = e.options, r = e.selectedIndex, o = "select-one" === e.type || 0 > r, a = o ? null : [], s = o ? r + 1 : i.length, l = 0 > r ? s : o ? r : 0; s > l; l++)
                                    if (n = i[l], (n.selected || l === r) && ($.optDisabled ? !n.disabled : null === n.getAttribute("disabled")) && (!n.parentNode.disabled || !Q.nodeName(n.parentNode, "optgroup"))) {
                                        if (t = Q(n).val(), o) return t;
                                        a.push(t)
                                    }
                                return a
                            },
                            set: function(e, t) {
                                for (var n, i, r = e.options, o = Q.makeArray(t), a = r.length; a--;) i = r[a], (i.selected = Q.inArray(i.value, o) >= 0) && (n = !0);
                                return n || (e.selectedIndex = -1), o
                            }
                        }
                    }
                }), Q.each(["radio", "checkbox"], function() {
                    Q.valHooks[this] = {
                        set: function(e, t) {
                            return Q.isArray(t) ? e.checked = Q.inArray(Q(e).val(), t) >= 0 : void 0
                        }
                    }, $.checkOn || (Q.valHooks[this].get = function(e) {
                        return null === e.getAttribute("value") ? "on" : e.value
                    })
                }), Q.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
                    Q.fn[t] = function(e, n) {
                        return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
                    }
                }), Q.fn.extend({
                    hover: function(e, t) {
                        return this.mouseenter(e).mouseleave(t || e)
                    },
                    bind: function(e, t, n) {
                        return this.on(e, null, t, n)
                    },
                    unbind: function(e, t) {
                        return this.off(e, null, t)
                    },
                    delegate: function(e, t, n, i) {
                        return this.on(t, e, n, i)
                    },
                    undelegate: function(e, t, n) {
                        return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
                    }
                });
                var ct = Q.now(),
                    ht = /\?/;
                Q.parseJSON = function(e) {
                    return JSON.parse(e + "")
                }, Q.parseXML = function(e) {
                    var t, n;
                    if (!e || "string" != typeof e) return null;
                    try {
                        n = new DOMParser, t = n.parseFromString(e, "text/xml")
                    } catch (i) {
                        t = void 0
                    }
                    return t && !t.getElementsByTagName("parsererror").length || Q.error("Invalid XML: " + e), t
                };
                var ut = /#.*$/,
                    ft = /([?&])_=[^&]*/,
                    dt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                    pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    mt = /^(?:GET|HEAD)$/,
                    vt = /^\/\//,
                    gt = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
                    yt = {},
                    xt = {},
                    wt = "*/".concat("*"),
                    _t = e.location.href,
                    bt = gt.exec(_t.toLowerCase()) || [];
                Q.extend({
                    active: 0,
                    lastModified: {},
                    etag: {},
                    ajaxSettings: {
                        url: _t,
                        type: "GET",
                        isLocal: pt.test(bt[1]),
                        global: !0,
                        processData: !0,
                        async: !0,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        accepts: {
                            "*": wt,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        contents: {
                            xml: /xml/,
                            html: /html/,
                            json: /json/
                        },
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        converters: {
                            "* text": String,
                            "text html": !0,
                            "text json": Q.parseJSON,
                            "text xml": Q.parseXML
                        },
                        flatOptions: {
                            url: !0,
                            context: !0
                        }
                    },
                    ajaxSetup: function(e, t) {
                        return t ? k(k(e, Q.ajaxSettings), t) : k(Q.ajaxSettings, e)
                    },
                    ajaxPrefilter: U(yt),
                    ajaxTransport: U(xt),
                    ajax: function(e, t) {
                        function n(e, t, n, a) {
                            var l, h, g, y, w, b = t;
                            2 !== x && (x = 2, s && clearTimeout(s), i = void 0, o = a || "", _.readyState = e > 0 ? 4 : 0, l = e >= 200 && 300 > e || 304 === e, n && (y = H(u, _, n)), y = I(u, y, _, l), l ? (u.ifModified && (w = _.getResponseHeader("Last-Modified"), w && (Q.lastModified[r] = w), w = _.getResponseHeader("etag"), w && (Q.etag[r] = w)), 204 === e || "HEAD" === u.type ? b = "nocontent" : 304 === e ? b = "notmodified" : (b = y.state, h = y.data, g = y.error, l = !g)) : (g = b, !e && b || (b = "error", 0 > e && (e = 0))), _.status = e, _.statusText = (t || b) + "", l ? p.resolveWith(f, [h, b, _]) : p.rejectWith(f, [_, b, g]), _.statusCode(v), v = void 0, c && d.trigger(l ? "ajaxSuccess" : "ajaxError", [_, u, l ? h : g]), m.fireWith(f, [_, b]), c && (d.trigger("ajaxComplete", [_, u]), --Q.active || Q.event.trigger("ajaxStop")))
                        }
                        "object" == typeof e && (t = e, e = void 0), t = t || {};
                        var i, r, o, a, s, l, c, h, u = Q.ajaxSetup({}, t),
                            f = u.context || u,
                            d = u.context && (f.nodeType || f.jquery) ? Q(f) : Q.event,
                            p = Q.Deferred(),
                            m = Q.Callbacks("once memory"),
                            v = u.statusCode || {},
                            g = {},
                            y = {},
                            x = 0,
                            w = "canceled",
                            _ = {
                                readyState: 0,
                                getResponseHeader: function(e) {
                                    var t;
                                    if (2 === x) {
                                        if (!a)
                                            for (a = {}; t = dt.exec(o);) a[t[1].toLowerCase()] = t[2];
                                        t = a[e.toLowerCase()]
                                    }
                                    return null == t ? null : t
                                },
                                getAllResponseHeaders: function() {
                                    return 2 === x ? o : null
                                },
                                setRequestHeader: function(e, t) {
                                    var n = e.toLowerCase();
                                    return x || (e = y[n] = y[n] || e, g[e] = t), this
                                },
                                overrideMimeType: function(e) {
                                    return x || (u.mimeType = e), this
                                },
                                statusCode: function(e) {
                                    var t;
                                    if (e)
                                        if (2 > x)
                                            for (t in e) v[t] = [v[t], e[t]];
                                        else _.always(e[_.status]);
                                    return this
                                },
                                abort: function(e) {
                                    var t = e || w;
                                    return i && i.abort(t), n(0, t), this
                                }
                            };
                        if (p.promise(_).complete = m.add, _.success = _.done, _.error = _.fail, u.url = ((e || u.url || _t) + "").replace(ut, "").replace(vt, bt[1] + "//"), u.type = t.method || t.type || u.method || u.type, u.dataTypes = Q.trim(u.dataType || "*").toLowerCase().match(de) || [""], null == u.crossDomain && (l = gt.exec(u.url.toLowerCase()), u.crossDomain = !(!l || l[1] === bt[1] && l[2] === bt[2] && (l[3] || ("http:" === l[1] ? "80" : "443")) === (bt[3] || ("http:" === bt[1] ? "80" : "443")))), u.data && u.processData && "string" != typeof u.data && (u.data = Q.param(u.data, u.traditional)), F(yt, u, t, _), 2 === x) return _;
                        c = Q.event && u.global, c && 0 === Q.active++ && Q.event.trigger("ajaxStart"), u.type = u.type.toUpperCase(), u.hasContent = !mt.test(u.type), r = u.url, u.hasContent || (u.data && (r = u.url += (ht.test(r) ? "&" : "?") + u.data, delete u.data), u.cache === !1 && (u.url = ft.test(r) ? r.replace(ft, "$1_=" + ct++) : r + (ht.test(r) ? "&" : "?") + "_=" + ct++)), u.ifModified && (Q.lastModified[r] && _.setRequestHeader("If-Modified-Since", Q.lastModified[r]), Q.etag[r] && _.setRequestHeader("If-None-Match", Q.etag[r])), (u.data && u.hasContent && u.contentType !== !1 || t.contentType) && _.setRequestHeader("Content-Type", u.contentType), _.setRequestHeader("Accept", u.dataTypes[0] && u.accepts[u.dataTypes[0]] ? u.accepts[u.dataTypes[0]] + ("*" !== u.dataTypes[0] ? ", " + wt + "; q=0.01" : "") : u.accepts["*"]);
                        for (h in u.headers) _.setRequestHeader(h, u.headers[h]);
                        if (u.beforeSend && (u.beforeSend.call(f, _, u) === !1 || 2 === x)) return _.abort();
                        w = "abort";
                        for (h in {
                            success: 1,
                            error: 1,
                            complete: 1
                        }) _[h](u[h]);
                        if (i = F(xt, u, t, _)) {
                            _.readyState = 1, c && d.trigger("ajaxSend", [_, u]), u.async && u.timeout > 0 && (s = setTimeout(function() {
                                _.abort("timeout")
                            }, u.timeout));
                            try {
                                x = 1, i.send(g, n)
                            } catch (b) {
                                if (!(2 > x)) throw b;
                                n(-1, b)
                            }
                        } else n(-1, "No Transport");
                        return _
                    },
                    getJSON: function(e, t, n) {
                        return Q.get(e, t, n, "json")
                    },
                    getScript: function(e, t) {
                        return Q.get(e, void 0, t, "script")
                    }
                }), Q.each(["get", "post"], function(e, t) {
                    Q[t] = function(e, n, i, r) {
                        return Q.isFunction(n) && (r = r || i, i = n, n = void 0), Q.ajax({
                            url: e,
                            type: t,
                            dataType: r,
                            data: n,
                            success: i
                        })
                    }
                }), Q._evalUrl = function(e) {
                    return Q.ajax({
                        url: e,
                        type: "GET",
                        dataType: "script",
                        async: !1,
                        global: !1,
                        "throws": !0
                    })
                }, Q.fn.extend({
                    wrapAll: function(e) {
                        var t;
                        return Q.isFunction(e) ? this.each(function(t) {
                            Q(this).wrapAll(e.call(this, t))
                        }) : (this[0] && (t = Q(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                            for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                            return e
                        }).append(this)), this)
                    },
                    wrapInner: function(e) {
                        return Q.isFunction(e) ? this.each(function(t) {
                            Q(this).wrapInner(e.call(this, t))
                        }) : this.each(function() {
                            var t = Q(this),
                                n = t.contents();
                            n.length ? n.wrapAll(e) : t.append(e)
                        })
                    },
                    wrap: function(e) {
                        var t = Q.isFunction(e);
                        return this.each(function(n) {
                            Q(this).wrapAll(t ? e.call(this, n) : e)
                        })
                    },
                    unwrap: function() {
                        return this.parent().each(function() {
                            Q.nodeName(this, "body") || Q(this).replaceWith(this.childNodes)
                        }).end()
                    }
                }), Q.expr.filters.hidden = function(e) {
                    return e.offsetWidth <= 0 && e.offsetHeight <= 0
                }, Q.expr.filters.visible = function(e) {
                    return !Q.expr.filters.hidden(e)
                };
                var Et = /%20/g,
                    Mt = /\[\]$/,
                    St = /\r?\n/g,
                    Tt = /^(?:submit|button|image|reset|file)$/i,
                    Ct = /^(?:input|select|textarea|keygen)/i;
                Q.param = function(e, t) {
                    var n, i = [],
                        r = function(e, t) {
                            t = Q.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
                        };
                    if (void 0 === t && (t = Q.ajaxSettings && Q.ajaxSettings.traditional), Q.isArray(e) || e.jquery && !Q.isPlainObject(e)) Q.each(e, function() {
                        r(this.name, this.value)
                    });
                    else
                        for (n in e) V(n, e[n], t, r);
                    return i.join("&").replace(Et, "+")
                }, Q.fn.extend({
                    serialize: function() {
                        return Q.param(this.serializeArray())
                    },
                    serializeArray: function() {
                        return this.map(function() {
                            var e = Q.prop(this, "elements");
                            return e ? Q.makeArray(e) : this
                        }).filter(function() {
                            var e = this.type;
                            return this.name && !Q(this).is(":disabled") && Ct.test(this.nodeName) && !Tt.test(e) && (this.checked || !Me.test(e))
                        }).map(function(e, t) {
                            var n = Q(this).val();
                            return null == n ? null : Q.isArray(n) ? Q.map(n, function(e) {
                                return {
                                    name: t.name,
                                    value: e.replace(St, "\r\n")
                                }
                            }) : {
                                name: t.name,
                                value: n.replace(St, "\r\n")
                            }
                        }).get()
                    }
                }), Q.ajaxSettings.xhr = function() {
                    try {
                        return new XMLHttpRequest
                    } catch (e) {}
                };
                var At = 0,
                    Pt = {},
                    Dt = {
                        0: 200,
                        1223: 204
                    },
                    Lt = Q.ajaxSettings.xhr();
                e.attachEvent && e.attachEvent("onunload", function() {
                    for (var e in Pt) Pt[e]()
                }), $.cors = !!Lt && "withCredentials" in Lt, $.ajax = Lt = !!Lt, Q.ajaxTransport(function(e) {
                    var t;
                    return $.cors || Lt && !e.crossDomain ? {
                        send: function(n, i) {
                            var r, o = e.xhr(),
                                a = ++At;
                            if (o.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                                for (r in e.xhrFields) o[r] = e.xhrFields[r];
                            e.mimeType && o.overrideMimeType && o.overrideMimeType(e.mimeType), e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
                            for (r in n) o.setRequestHeader(r, n[r]);
                            t = function(e) {
                                return function() {
                                    t && (delete Pt[a], t = o.onload = o.onerror = null, "abort" === e ? o.abort() : "error" === e ? i(o.status, o.statusText) : i(Dt[o.status] || o.status, o.statusText, "string" == typeof o.responseText ? {
                                        text: o.responseText
                                    } : void 0, o.getAllResponseHeaders()))
                                }
                            }, o.onload = t(), o.onerror = t("error"), t = Pt[a] = t("abort");
                            try {
                                o.send(e.hasContent && e.data || null)
                            } catch (s) {
                                if (t) throw s
                            }
                        },
                        abort: function() {
                            t && t()
                        }
                    } : void 0
                }), Q.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /(?:java|ecma)script/
                    },
                    converters: {
                        "text script": function(e) {
                            return Q.globalEval(e), e
                        }
                    }
                }), Q.ajaxPrefilter("script", function(e) {
                    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
                }), Q.ajaxTransport("script", function(e) {
                    if (e.crossDomain) {
                        var t, n;
                        return {
                            send: function(i, r) {
                                t = Q("<script>").prop({
                                    async: !0,
                                    charset: e.scriptCharset,
                                    src: e.url
                                }).on("load error", n = function(e) {
                                    t.remove(), n = null, e && r("error" === e.type ? 404 : 200, e.type)
                                }), J.head.appendChild(t[0])
                            },
                            abort: function() {
                                n && n()
                            }
                        }
                    }
                });
                var Rt = [],
                    Ot = /(=)\?(?=&|$)|\?\?/;
                Q.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var e = Rt.pop() || Q.expando + "_" + ct++;
                        return this[e] = !0, e
                    }
                }), Q.ajaxPrefilter("json jsonp", function(t, n, i) {
                    var r, o, a, s = t.jsonp !== !1 && (Ot.test(t.url) ? "url" : "string" == typeof t.data && !(t.contentType || "").indexOf("application/x-www-form-urlencoded") && Ot.test(t.data) && "data");
                    return s || "jsonp" === t.dataTypes[0] ? (r = t.jsonpCallback = Q.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Ot, "$1" + r) : t.jsonp !== !1 && (t.url += (ht.test(t.url) ? "&" : "?") + t.jsonp + "=" + r), t.converters["script json"] = function() {
                        return a || Q.error(r + " was not called"), a[0]
                    }, t.dataTypes[0] = "json", o = e[r], e[r] = function() {
                        a = arguments
                    }, i.always(function() {
                        e[r] = o, t[r] && (t.jsonpCallback = n.jsonpCallback, Rt.push(r)), a && Q.isFunction(o) && o(a[0]), a = o = void 0
                    }), "script") : void 0
                }), Q.parseHTML = function(e, t, n) {
                    if (!e || "string" != typeof e) return null;
                    "boolean" == typeof t && (n = t, t = !1), t = t || J;
                    var i = ae.exec(e),
                        r = !n && [];
                    return i ? [t.createElement(i[1])] : (i = Q.buildFragment([e], t, r), r && r.length && Q(r).remove(), Q.merge([], i.childNodes))
                };
                var Nt = Q.fn.load;
                Q.fn.load = function(e, t, n) {
                    if ("string" != typeof e && Nt) return Nt.apply(this, arguments);
                    var i, r, o, a = this,
                        s = e.indexOf(" ");
                    return s >= 0 && (i = Q.trim(e.slice(s)), e = e.slice(0, s)), Q.isFunction(t) ? (n = t, t = void 0) : t && "object" == typeof t && (r = "POST"), a.length > 0 && Q.ajax({
                        url: e,
                        type: r,
                        dataType: "html",
                        data: t
                    }).done(function(e) {
                        o = arguments, a.html(i ? Q("<div>").append(Q.parseHTML(e)).find(i) : e)
                    }).complete(n && function(e, t) {
                        a.each(n, o || [e.responseText, t, e])
                    }), this
                }, Q.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
                    Q.fn[t] = function(e) {
                        return this.on(t, e)
                    }
                }), Q.expr.filters.animated = function(e) {
                    return Q.grep(Q.timers, function(t) {
                        return e === t.elem
                    }).length
                };
                var Ut = e.document.documentElement;
                Q.offset = {
                    setOffset: function(e, t, n) {
                        var i, r, o, a, s, l, c, h = Q.css(e, "position"),
                            u = Q(e),
                            f = {};
                        "static" === h && (e.style.position = "relative"), s = u.offset(), o = Q.css(e, "top"), l = Q.css(e, "left"), c = ("absolute" === h || "fixed" === h) && (o + l).indexOf("auto") > -1, c ? (i = u.position(), a = i.top, r = i.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), Q.isFunction(t) && (t = t.call(e, n, s)), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + r), "using" in t ? t.using.call(e, f) : u.css(f)
                    }
                }, Q.fn.extend({
                    offset: function(e) {
                        if (arguments.length) return void 0 === e ? this : this.each(function(t) {
                            Q.offset.setOffset(this, e, t)
                        });
                        var t, n, i = this[0],
                            r = {
                                top: 0,
                                left: 0
                            },
                            o = i && i.ownerDocument;
                        if (o) return t = o.documentElement, Q.contains(t, i) ? (typeof i.getBoundingClientRect !== Se && (r = i.getBoundingClientRect()), n = z(o), {
                            top: r.top + n.pageYOffset - t.clientTop,
                            left: r.left + n.pageXOffset - t.clientLeft
                        }) : r
                    },
                    position: function() {
                        if (this[0]) {
                            var e, t, n = this[0],
                                i = {
                                    top: 0,
                                    left: 0
                                };
                            return "fixed" === Q.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), Q.nodeName(e[0], "html") || (i = e.offset()), i.top += Q.css(e[0], "borderTopWidth", !0), i.left += Q.css(e[0], "borderLeftWidth", !0)), {
                                top: t.top - i.top - Q.css(n, "marginTop", !0),
                                left: t.left - i.left - Q.css(n, "marginLeft", !0)
                            }
                        }
                    },
                    offsetParent: function() {
                        return this.map(function() {
                            for (var e = this.offsetParent || Ut; e && !Q.nodeName(e, "html") && "static" === Q.css(e, "position");) e = e.offsetParent;
                            return e || Ut
                        })
                    }
                }), Q.each({
                    scrollLeft: "pageXOffset",
                    scrollTop: "pageYOffset"
                }, function(t, n) {
                    var i = "pageYOffset" === n;
                    Q.fn[t] = function(r) {
                        return ve(this, function(t, r, o) {
                            var a = z(t);
                            return void 0 === o ? a ? a[n] : t[r] : void(a ? a.scrollTo(i ? e.pageXOffset : o, i ? o : e.pageYOffset) : t[r] = o)
                        }, t, r, arguments.length, null)
                    }
                }), Q.each(["top", "left"], function(e, t) {
                    Q.cssHooks[t] = b($.pixelPosition, function(e, n) {
                        return n ? (n = _(e, t), Be.test(n) ? Q(e).position()[t] + "px" : n) : void 0
                    })
                }), Q.each({
                    Height: "height",
                    Width: "width"
                }, function(e, t) {
                    Q.each({
                        padding: "inner" + e,
                        content: t,
                        "": "outer" + e
                    }, function(n, i) {
                        Q.fn[i] = function(i, r) {
                            var o = arguments.length && (n || "boolean" != typeof i),
                                a = n || (i === !0 || r === !0 ? "margin" : "border");
                            return ve(this, function(t, n, i) {
                                var r;
                                return Q.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (r = t.documentElement, Math.max(t.body["scroll" + e], r["scroll" + e], t.body["offset" + e], r["offset" + e], r["client" + e])) : void 0 === i ? Q.css(t, n, a) : Q.style(t, n, i, a)
                            }, t, o ? i : void 0, o, null)
                        }
                    })
                }), Q.fn.size = function() {
                    return this.length
                }, Q.fn.andSelf = Q.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
                    return Q
                });
                var Ft = e.jQuery,
                    kt = e.$;
                return Q.noConflict = function(t) {
                    return e.$ === Q && (e.$ = kt), t && e.jQuery === Q && (e.jQuery = Ft), Q
                }, typeof t === Se && (e.jQuery = e.$ = Q), Q
            })
        }, {}
    ],
    5: [
        function(e, t, n) {
            (function(e) {
                (function() {
                    function i(e, t, n) {
                        for (var i = (n || 0) - 1, r = e ? e.length : 0; ++i < r;)
                            if (e[i] === t) return i;
                        return -1
                    }

                    function r(e, t) {
                        var n = typeof t;
                        if (e = e.cache, "boolean" == n || null == t) return e[t] ? 0 : -1;
                        "number" != n && "string" != n && (n = "object");
                        var r = "number" == n ? t : w + t;
                        return e = (e = e[n]) && e[r], "object" == n ? e && i(e, t) > -1 ? 0 : -1 : e ? 0 : -1
                    }

                    function o(e) {
                        var t = this.cache,
                            n = typeof e;
                        if ("boolean" == n || null == e) t[e] = !0;
                        else {
                            "number" != n && "string" != n && (n = "object");
                            var i = "number" == n ? e : w + e,
                                r = t[n] || (t[n] = {});
                            "object" == n ? (r[i] || (r[i] = [])).push(e) : r[i] = !0
                        }
                    }

                    function a(e) {
                        return e.charCodeAt(0)
                    }

                    function s(e, t) {
                        for (var n = e.criteria, i = t.criteria, r = -1, o = n.length; ++r < o;) {
                            var a = n[r],
                                s = i[r];
                            if (a !== s) {
                                if (a > s || "undefined" == typeof a) return 1;
                                if (s > a || "undefined" == typeof s) return -1
                            }
                        }
                        return e.index - t.index
                    }

                    function l(e) {
                        var t = -1,
                            n = e.length,
                            i = e[0],
                            r = e[n / 2 | 0],
                            a = e[n - 1];
                        if (i && "object" == typeof i && r && "object" == typeof r && a && "object" == typeof a) return !1;
                        var s = u();
                        s["false"] = s["null"] = s["true"] = s.undefined = !1;
                        var l = u();
                        for (l.array = e, l.cache = s, l.push = o; ++t < n;) l.push(e[t]);
                        return l
                    }

                    function c(e) {
                        return "\\" + $[e]
                    }

                    function h() {
                        return g.pop() || []
                    }

                    function u() {
                        return y.pop() || {
                                array: null,
                                cache: null,
                                criteria: null,
                                "false": !1,
                                index: 0,
                                "null": !1,
                                number: null,
                                object: null,
                                push: null,
                                string: null,
                                "true": !1,
                                undefined: !1,
                                value: null
                            }
                    }

                    function f(e) {
                        e.length = 0, g.length < b && g.push(e)
                    }

                    function d(e) {
                        var t = e.cache;
                        t && d(t), e.array = e.cache = e.criteria = e.object = e.number = e.string = e.value = null, y.length < b && y.push(e)
                    }

                    function p(e, t, n) {
                        t || (t = 0), "undefined" == typeof n && (n = e ? e.length : 0);
                        for (var i = -1, r = n - t || 0, o = Array(0 > r ? 0 : r); ++i < r;) o[i] = e[t + i];
                        return o
                    }

                    function m(e) {
                        function t(e) {
                            return e && "object" == typeof e && !Zn(e) && Nn.call(e, "__wrapped__") ? e : new n(e)
                        }

                        function n(e, t) {
                            this.__chain__ = !!t, this.__wrapped__ = e
                        }

                        function o(e) {
                            function t() {
                                if (i) {
                                    var e = p(i);
                                    Un.apply(e, arguments)
                                }
                                if (this instanceof t) {
                                    var o = y(n.prototype),
                                        a = n.apply(o, e || arguments);
                                    return De(a) ? a : o
                                }
                                return n.apply(r, e || arguments)
                            }
                            var n = e[0],
                                i = e[2],
                                r = e[4];
                            return Jn(t, e), t
                        }

                        function g(e, t, n, i, r) {
                            if (n) {
                                var o = n(e);
                                if ("undefined" != typeof o) return o
                            }
                            var a = De(e);
                            if (!a) return e;
                            var s = Cn.call(e);
                            if (!X[s]) return e;
                            var l = Yn[s];
                            switch (s) {
                                case I:
                                case V:
                                    return new l(+e);
                                case B:
                                case W:
                                    return new l(e);
                                case G:
                                    return o = l(e.source, A.exec(e)), o.lastIndex = e.lastIndex, o
                            }
                            var c = Zn(e);
                            if (t) {
                                var u = !i;
                                i || (i = h()), r || (r = h());
                                for (var d = i.length; d--;)
                                    if (i[d] == e) return r[d];
                                o = c ? l(e.length) : {}
                            } else o = c ? p(e) : oi({}, e);
                            return c && (Nn.call(e, "index") && (o.index = e.index), Nn.call(e, "input") && (o.input = e.input)), t ? (i.push(e), r.push(o), (c ? $e : li)(e, function(e, a) {
                                o[a] = g(e, t, n, i, r)
                            }), u && (f(i), f(r)), o) : o
                        }

                        function y(e, t) {
                            return De(e) ? Vn(e) : {}
                        }

                        function b(e, t, n) {
                            if ("function" != typeof e) return Jt;
                            if ("undefined" == typeof t || !("prototype" in e)) return e;
                            var i = e.__bindData__;
                            if ("undefined" == typeof i && ($n.funcNames && (i = !e.name), i = i || !$n.funcDecomp, !i)) {
                                var r = Rn.call(e);
                                $n.funcNames || (i = !P.test(r)), i || (i = O.test(r), Jn(e, i))
                            }
                            if (i === !1 || i !== !0 && 1 & i[1]) return e;
                            switch (n) {
                                case 1:
                                    return function(n) {
                                        return e.call(t, n)
                                    };
                                case 2:
                                    return function(n, i) {
                                        return e.call(t, n, i)
                                    };
                                case 3:
                                    return function(n, i, r) {
                                        return e.call(t, n, i, r)
                                    };
                                case 4:
                                    return function(n, i, r, o) {
                                        return e.call(t, n, i, r, o)
                                    }
                            }
                            return Nt(e, t)
                        }

                        function $(e) {
                            function t() {
                                var e = l ? a : this;
                                if (r) {
                                    var d = p(r);
                                    Un.apply(d, arguments)
                                }
                                if ((o || h) && (d || (d = p(arguments)), o && Un.apply(d, o), h && d.length < s)) return i |= 16, $([n, u ? i : -4 & i, d, null, a, s]);
                                if (d || (d = arguments), c && (n = e[f]), this instanceof t) {
                                    e = y(n.prototype);
                                    var m = n.apply(e, d);
                                    return De(m) ? m : e
                                }
                                return n.apply(e, d)
                            }
                            var n = e[0],
                                i = e[1],
                                r = e[2],
                                o = e[3],
                                a = e[4],
                                s = e[5],
                                l = 1 & i,
                                c = 2 & i,
                                h = 4 & i,
                                u = 8 & i,
                                f = n;
                            return Jn(t, e), t
                        }

                        function Z(e, t) {
                            var n = -1,
                                o = le(),
                                a = e ? e.length : 0,
                                s = a >= _ && o === i,
                                c = [];
                            if (s) {
                                var h = l(t);
                                h ? (o = r, t = h) : s = !1
                            }
                            for (; ++n < a;) {
                                var u = e[n];
                                o(t, u) < 0 && c.push(u)
                            }
                            return s && d(t), c
                        }

                        function Q(e, t, n, i) {
                            for (var r = (i || 0) - 1, o = e ? e.length : 0, a = []; ++r < o;) {
                                var s = e[r];
                                if (s && "object" == typeof s && "number" == typeof s.length && (Zn(s) || fe(s))) {
                                    t || (s = Q(s, t, n));
                                    var l = -1,
                                        c = s.length,
                                        h = a.length;
                                    for (a.length += c; ++l < c;) a[h++] = s[l]
                                } else n || a.push(s)
                            }
                            return a
                        }

                        function ee(e, t, n, i, r, o) {
                            if (n) {
                                var a = n(e, t);
                                if ("undefined" != typeof a) return !!a
                            }
                            if (e === t) return 0 !== e || 1 / e == 1 / t;
                            var s = typeof e,
                                l = typeof t;
                            if (!(e !== e || e && Y[s] || t && Y[l])) return !1;
                            if (null == e || null == t) return e === t;
                            var c = Cn.call(e),
                                u = Cn.call(t);
                            if (c == k && (c = j), u == k && (u = j), c != u) return !1;
                            switch (c) {
                                case I:
                                case V:
                                    return +e == +t;
                                case B:
                                    return e != +e ? t != +t : 0 == e ? 1 / e == 1 / t : e == +t;
                                case G:
                                case W:
                                    return e == bn(t)
                            }
                            var d = c == H;
                            if (!d) {
                                var p = Nn.call(e, "__wrapped__"),
                                    m = Nn.call(t, "__wrapped__");
                                if (p || m) return ee(p ? e.__wrapped__ : e, m ? t.__wrapped__ : t, n, i, r, o);
                                if (c != j) return !1;
                                var v = e.constructor,
                                    g = t.constructor;
                                if (v != g && !(Pe(v) && v instanceof v && Pe(g) && g instanceof g) && "constructor" in e && "constructor" in t) return !1
                            }
                            var y = !r;
                            r || (r = h()), o || (o = h());
                            for (var x = r.length; x--;)
                                if (r[x] == e) return o[x] == t;
                            var w = 0;
                            if (a = !0, r.push(e), o.push(t), d) {
                                if (x = e.length, w = t.length, a = w == x, a || i)
                                    for (; w--;) {
                                        var _ = x,
                                            b = t[w];
                                        if (i)
                                            for (; _-- && !(a = ee(e[_], b, n, i, r, o)););
                                        else if (!(a = ee(e[w], b, n, i, r, o))) break
                                    }
                            } else si(t, function(t, s, l) {
                                return Nn.call(l, s) ? (w++, a = Nn.call(e, s) && ee(e[s], t, n, i, r, o)) : void 0
                            }), a && !i && si(e, function(e, t, n) {
                                return Nn.call(n, t) ? a = --w > -1 : void 0
                            });
                            return r.pop(), o.pop(), y && (f(r), f(o)), a
                        }

                        function te(e, t, n, i, r) {
                            (Zn(t) ? $e : li)(t, function(t, o) {
                                var a, s, l = t,
                                    c = e[o];
                                if (t && ((s = Zn(t)) || ci(t))) {
                                    for (var h = i.length; h--;)
                                        if (a = i[h] == t) {
                                            c = r[h];
                                            break
                                        }
                                    if (!a) {
                                        var u;
                                        n && (l = n(c, t), (u = "undefined" != typeof l) && (c = l)), u || (c = s ? Zn(c) ? c : [] : ci(c) ? c : {}), i.push(t), r.push(c), u || te(c, t, n, i, r)
                                    }
                                } else n && (l = n(c, t), "undefined" == typeof l && (l = t)), "undefined" != typeof l && (c = l);
                                e[o] = c
                            })
                        }

                        function ie(e, t) {
                            return e + Ln(Kn() * (t - e + 1))
                        }

                        function re(e, t, n) {
                            var o = -1,
                                a = le(),
                                s = e ? e.length : 0,
                                c = [],
                                u = !t && s >= _ && a === i,
                                p = n || u ? h() : c;
                            if (u) {
                                var m = l(p);
                                a = r, p = m
                            }
                            for (; ++o < s;) {
                                var v = e[o],
                                    g = n ? n(v, o, e) : v;
                                (t ? !o || p[p.length - 1] !== g : a(p, g) < 0) && ((n || u) && p.push(g), c.push(v))
                            }
                            return u ? (f(p.array), d(p)) : n && f(p), c
                        }

                        function oe(e) {
                            return function(n, i, r) {
                                var o = {};
                                i = t.createCallback(i, r, 3);
                                var a = -1,
                                    s = n ? n.length : 0;
                                if ("number" == typeof s)
                                    for (; ++a < s;) {
                                        var l = n[a];
                                        e(o, l, i(l, a, n), n)
                                    } else li(n, function(t, n, r) {
                                    e(o, t, i(t, n, r), r)
                                });
                                return o
                            }
                        }

                        function ae(e, t, n, i, r, a) {
                            var s = 1 & t,
                                l = 2 & t,
                                c = 4 & t,
                                h = 16 & t,
                                u = 32 & t;
                            if (!l && !Pe(e)) throw new En;
                            h && !n.length && (t &= -17, h = n = !1), u && !i.length && (t &= -33, u = i = !1);
                            var f = e && e.__bindData__;
                            if (f && f !== !0) return f = p(f), f[2] && (f[2] = p(f[2])), f[3] && (f[3] = p(f[3])), !s || 1 & f[1] || (f[4] = r), !s && 1 & f[1] && (t |= 8), !c || 4 & f[1] || (f[5] = a), h && Un.apply(f[2] || (f[2] = []), n), u && Hn.apply(f[3] || (f[3] = []), i), f[1] |= t, ae.apply(null, f);
                            var d = 1 == t || 17 === t ? o : $;
                            return d([e, t, n, i, r, a])
                        }

                        function se(e) {
                            return ti[e]
                        }

                        function le() {
                            var e = (e = t.indexOf) === gt ? i : e;
                            return e
                        }

                        function ce(e) {
                            return "function" == typeof e && An.test(e)
                        }

                        function he(e) {
                            var t, n;
                            return e && Cn.call(e) == j && (t = e.constructor, !Pe(t) || t instanceof t) ? (si(e, function(e, t) {
                                n = t
                            }), "undefined" == typeof n || Nn.call(e, n)) : !1
                        }

                        function ue(e) {
                            return ni[e]
                        }

                        function fe(e) {
                            return e && "object" == typeof e && "number" == typeof e.length && Cn.call(e) == k || !1
                        }

                        function de(e, t, n, i) {
                            return "boolean" != typeof t && null != t && (i = n, n = t, t = !1), g(e, t, "function" == typeof n && b(n, i, 1))
                        }

                        function pe(e, t, n) {
                            return g(e, !0, "function" == typeof t && b(t, n, 1))
                        }

                        function me(e, t) {
                            var n = y(e);
                            return t ? oi(n, t) : n
                        }

                        function ve(e, n, i) {
                            var r;
                            return n = t.createCallback(n, i, 3), li(e, function(e, t, i) {
                                return n(e, t, i) ? (r = t, !1) : void 0
                            }), r
                        }

                        function ge(e, n, i) {
                            var r;
                            return n = t.createCallback(n, i, 3), xe(e, function(e, t, i) {
                                return n(e, t, i) ? (r = t, !1) : void 0
                            }), r
                        }

                        function ye(e, t, n) {
                            var i = [];
                            si(e, function(e, t) {
                                i.push(t, e)
                            });
                            var r = i.length;
                            for (t = b(t, n, 3); r-- && t(i[r--], i[r], e) !== !1;);
                            return e
                        }

                        function xe(e, t, n) {
                            var i = ei(e),
                                r = i.length;
                            for (t = b(t, n, 3); r--;) {
                                var o = i[r];
                                if (t(e[o], o, e) === !1) break
                            }
                            return e
                        }

                        function we(e) {
                            var t = [];
                            return si(e, function(e, n) {
                                Pe(e) && t.push(n)
                            }), t.sort()
                        }

                        function _e(e, t) {
                            return e ? Nn.call(e, t) : !1
                        }

                        function be(e) {
                            for (var t = -1, n = ei(e), i = n.length, r = {}; ++t < i;) {
                                var o = n[t];
                                r[e[o]] = o
                            }
                            return r
                        }

                        function Ee(e) {
                            return e === !0 || e === !1 || e && "object" == typeof e && Cn.call(e) == I || !1
                        }

                        function Me(e) {
                            return e && "object" == typeof e && Cn.call(e) == V || !1
                        }

                        function Se(e) {
                            return e && 1 === e.nodeType || !1
                        }

                        function Te(e) {
                            var t = !0;
                            if (!e) return t;
                            var n = Cn.call(e),
                                i = e.length;
                            return n == H || n == W || n == k || n == j && "number" == typeof i && Pe(e.splice) ? !i : (li(e, function() {
                                return t = !1
                            }), t)
                        }

                        function Ce(e, t, n, i) {
                            return ee(e, t, "function" == typeof n && b(n, i, 2))
                        }

                        function Ae(e) {
                            return Bn(e) && !jn(parseFloat(e))
                        }

                        function Pe(e) {
                            return "function" == typeof e
                        }

                        function De(e) {
                            return !(!e || !Y[typeof e])
                        }

                        function Le(e) {
                            return Oe(e) && e != +e
                        }

                        function Re(e) {
                            return null === e
                        }

                        function Oe(e) {
                            return "number" == typeof e || e && "object" == typeof e && Cn.call(e) == B || !1
                        }

                        function Ne(e) {
                            return e && "object" == typeof e && Cn.call(e) == G || !1
                        }

                        function Ue(e) {
                            return "string" == typeof e || e && "object" == typeof e && Cn.call(e) == W || !1
                        }

                        function Fe(e) {
                            return "undefined" == typeof e
                        }

                        function ke(e, n, i) {
                            var r = {};
                            return n = t.createCallback(n, i, 3), li(e, function(e, t, i) {
                                r[t] = n(e, t, i)
                            }), r
                        }

                        function He(e) {
                            var t = arguments,
                                n = 2;
                            if (!De(e)) return e;
                            if ("number" != typeof t[2] && (n = t.length), n > 3 && "function" == typeof t[n - 2]) var i = b(t[--n - 1], t[n--], 2);
                            else n > 2 && "function" == typeof t[n - 1] && (i = t[--n]);
                            for (var r = p(arguments, 1, n), o = -1, a = h(), s = h(); ++o < n;) te(e, r[o], i, a, s);
                            return f(a), f(s), e
                        }

                        function Ie(e, n, i) {
                            var r = {};
                            if ("function" != typeof n) {
                                var o = [];
                                si(e, function(e, t) {
                                    o.push(t)
                                }), o = Z(o, Q(arguments, !0, !1, 1));
                                for (var a = -1, s = o.length; ++a < s;) {
                                    var l = o[a];
                                    r[l] = e[l]
                                }
                            } else n = t.createCallback(n, i, 3), si(e, function(e, t, i) {
                                n(e, t, i) || (r[t] = e)
                            });
                            return r
                        }

                        function Ve(e) {
                            for (var t = -1, n = ei(e), i = n.length, r = pn(i); ++t < i;) {
                                var o = n[t];
                                r[t] = [o, e[o]]
                            }
                            return r
                        }

                        function ze(e, n, i) {
                            var r = {};
                            if ("function" != typeof n)
                                for (var o = -1, a = Q(arguments, !0, !1, 1), s = De(e) ? a.length : 0; ++o < s;) {
                                    var l = a[o];
                                    l in e && (r[l] = e[l])
                                } else n = t.createCallback(n, i, 3), si(e, function(e, t, i) {
                                n(e, t, i) && (r[t] = e)
                            });
                            return r
                        }

                        function Be(e, n, i, r) {
                            var o = Zn(e);
                            if (null == i)
                                if (o) i = [];
                                else {
                                    var a = e && e.constructor,
                                        s = a && a.prototype;
                                    i = y(s)
                                }
                            return n && (n = t.createCallback(n, r, 4), (o ? $e : li)(e, function(e, t, r) {
                                return n(i, e, t, r)
                            })), i
                        }

                        function je(e) {
                            for (var t = -1, n = ei(e), i = n.length, r = pn(i); ++t < i;) r[t] = e[n[t]];
                            return r
                        }

                        function Ge(e) {
                            for (var t = arguments, n = -1, i = Q(t, !0, !1, 1), r = t[2] && t[2][t[1]] === e ? 1 : i.length, o = pn(r); ++n < r;) o[n] = e[i[n]];
                            return o
                        }

                        function We(e, t, n) {
                            var i = -1,
                                r = le(),
                                o = e ? e.length : 0,
                                a = !1;
                            return n = (0 > n ? Wn(0, o + n) : n) || 0, Zn(e) ? a = r(e, t, n) > -1 : "number" == typeof o ? a = (Ue(e) ? e.indexOf(t, n) : r(e, t, n)) > -1 : li(e, function(e) {
                                return ++i >= n ? !(a = e === t) : void 0
                            }), a
                        }

                        function Xe(e, n, i) {
                            var r = !0;
                            n = t.createCallback(n, i, 3);
                            var o = -1,
                                a = e ? e.length : 0;
                            if ("number" == typeof a)
                                for (; ++o < a && (r = !!n(e[o], o, e)););
                            else li(e, function(e, t, i) {
                                return r = !!n(e, t, i)
                            });
                            return r
                        }

                        function qe(e, n, i) {
                            var r = [];
                            n = t.createCallback(n, i, 3);
                            var o = -1,
                                a = e ? e.length : 0;
                            if ("number" == typeof a)
                                for (; ++o < a;) {
                                    var s = e[o];
                                    n(s, o, e) && r.push(s)
                                } else li(e, function(e, t, i) {
                                n(e, t, i) && r.push(e)
                            });
                            return r
                        }

                        function Ke(e, n, i) {
                            n = t.createCallback(n, i, 3);
                            var r = -1,
                                o = e ? e.length : 0;
                            if ("number" != typeof o) {
                                var a;
                                return li(e, function(e, t, i) {
                                    return n(e, t, i) ? (a = e, !1) : void 0
                                }), a
                            }
                            for (; ++r < o;) {
                                var s = e[r];
                                if (n(s, r, e)) return s
                            }
                        }

                        function Ye(e, n, i) {
                            var r;
                            return n = t.createCallback(n, i, 3), Je(e, function(e, t, i) {
                                return n(e, t, i) ? (r = e, !1) : void 0
                            }), r
                        }

                        function $e(e, t, n) {
                            var i = -1,
                                r = e ? e.length : 0;
                            if (t = t && "undefined" == typeof n ? t : b(t, n, 3), "number" == typeof r)
                                for (; ++i < r && t(e[i], i, e) !== !1;);
                            else li(e, t);
                            return e
                        }

                        function Je(e, t, n) {
                            var i = e ? e.length : 0;
                            if (t = t && "undefined" == typeof n ? t : b(t, n, 3), "number" == typeof i)
                                for (; i-- && t(e[i], i, e) !== !1;);
                            else {
                                var r = ei(e);
                                i = r.length, li(e, function(e, n, o) {
                                    return n = r ? r[--i] : --i, t(o[n], n, o)
                                })
                            }
                            return e
                        }

                        function Ze(e, t) {
                            var n = p(arguments, 2),
                                i = -1,
                                r = "function" == typeof t,
                                o = e ? e.length : 0,
                                a = pn("number" == typeof o ? o : 0);
                            return $e(e, function(e) {
                                a[++i] = (r ? t : e[t]).apply(e, n)
                            }), a
                        }

                        function Qe(e, n, i) {
                            var r = -1,
                                o = e ? e.length : 0;
                            if (n = t.createCallback(n, i, 3), "number" == typeof o)
                                for (var a = pn(o); ++r < o;) a[r] = n(e[r], r, e);
                            else a = [], li(e, function(e, t, i) {
                                a[++r] = n(e, t, i)
                            });
                            return a
                        }

                        function et(e, n, i) {
                            var r = -(1 / 0),
                                o = r;
                            if ("function" != typeof n && i && i[n] === e && (n = null), null == n && Zn(e))
                                for (var s = -1, l = e.length; ++s < l;) {
                                    var c = e[s];
                                    c > o && (o = c)
                                } else n = null == n && Ue(e) ? a : t.createCallback(n, i, 3), $e(e, function(e, t, i) {
                                var a = n(e, t, i);
                                a > r && (r = a, o = e)
                            });
                            return o
                        }

                        function tt(e, n, i) {
                            var r = 1 / 0,
                                o = r;
                            if ("function" != typeof n && i && i[n] === e && (n = null), null == n && Zn(e))
                                for (var s = -1, l = e.length; ++s < l;) {
                                    var c = e[s];
                                    o > c && (o = c)
                                } else n = null == n && Ue(e) ? a : t.createCallback(n, i, 3), $e(e, function(e, t, i) {
                                var a = n(e, t, i);
                                r > a && (r = a, o = e)
                            });
                            return o
                        }

                        function nt(e, n, i, r) {
                            if (!e) return i;
                            var o = arguments.length < 3;
                            n = t.createCallback(n, r, 4);
                            var a = -1,
                                s = e.length;
                            if ("number" == typeof s)
                                for (o && (i = e[++a]); ++a < s;) i = n(i, e[a], a, e);
                            else li(e, function(e, t, r) {
                                i = o ? (o = !1, e) : n(i, e, t, r)
                            });
                            return i
                        }

                        function it(e, n, i, r) {
                            var o = arguments.length < 3;
                            return n = t.createCallback(n, r, 4), Je(e, function(e, t, r) {
                                i = o ? (o = !1, e) : n(i, e, t, r)
                            }), i
                        }

                        function rt(e, n, i) {
                            return n = t.createCallback(n, i, 3), qe(e, function(e, t, i) {
                                return !n(e, t, i)
                            })
                        }

                        function ot(e, t, n) {
                            if (e && "number" != typeof e.length && (e = je(e)), null == t || n) return e ? e[ie(0, e.length - 1)] : v;
                            var i = at(e);
                            return i.length = Xn(Wn(0, t), i.length), i
                        }

                        function at(e) {
                            var t = -1,
                                n = e ? e.length : 0,
                                i = pn("number" == typeof n ? n : 0);
                            return $e(e, function(e) {
                                var n = ie(0, ++t);
                                i[t] = i[n], i[n] = e
                            }), i
                        }

                        function st(e) {
                            var t = e ? e.length : 0;
                            return "number" == typeof t ? t : ei(e).length
                        }

                        function lt(e, n, i) {
                            var r;
                            n = t.createCallback(n, i, 3);
                            var o = -1,
                                a = e ? e.length : 0;
                            if ("number" == typeof a)
                                for (; ++o < a && !(r = n(e[o], o, e)););
                            else li(e, function(e, t, i) {
                                return !(r = n(e, t, i))
                            });
                            return !!r
                        }

                        function ct(e, n, i) {
                            var r = -1,
                                o = Zn(n),
                                a = e ? e.length : 0,
                                l = pn("number" == typeof a ? a : 0);
                            for (o || (n = t.createCallback(n, i, 3)), $e(e, function(e, t, i) {
                                var a = l[++r] = u();
                                o ? a.criteria = Qe(n, function(t) {
                                    return e[t]
                                }) : (a.criteria = h())[0] = n(e, t, i), a.index = r, a.value = e
                            }), a = l.length, l.sort(s); a--;) {
                                var c = l[a];
                                l[a] = c.value, o || f(c.criteria), d(c)
                            }
                            return l
                        }

                        function ht(e) {
                            return e && "number" == typeof e.length ? p(e) : je(e)
                        }

                        function ut(e) {
                            for (var t = -1, n = e ? e.length : 0, i = []; ++t < n;) {
                                var r = e[t];
                                r && i.push(r)
                            }
                            return i
                        }

                        function ft(e) {
                            return Z(e, Q(arguments, !0, !0, 1))
                        }

                        function dt(e, n, i) {
                            var r = -1,
                                o = e ? e.length : 0;
                            for (n = t.createCallback(n, i, 3); ++r < o;)
                                if (n(e[r], r, e)) return r;
                            return -1
                        }

                        function pt(e, n, i) {
                            var r = e ? e.length : 0;
                            for (n = t.createCallback(n, i, 3); r--;)
                                if (n(e[r], r, e)) return r;
                            return -1
                        }

                        function mt(e, n, i) {
                            var r = 0,
                                o = e ? e.length : 0;
                            if ("number" != typeof n && null != n) {
                                var a = -1;
                                for (n = t.createCallback(n, i, 3); ++a < o && n(e[a], a, e);) r++
                            } else if (r = n, null == r || i) return e ? e[0] : v;
                            return p(e, 0, Xn(Wn(0, r), o))
                        }

                        function vt(e, t, n, i) {
                            return "boolean" != typeof t && null != t && (i = n, n = "function" != typeof t && i && i[t] === e ? null : t, t = !1), null != n && (e = Qe(e, n, i)), Q(e, t)
                        }

                        function gt(e, t, n) {
                            if ("number" == typeof n) {
                                var r = e ? e.length : 0;
                                n = 0 > n ? Wn(0, r + n) : n || 0
                            } else if (n) {
                                var o = Tt(e, t);
                                return e[o] === t ? o : -1
                            }
                            return i(e, t, n)
                        }

                        function yt(e, n, i) {
                            var r = 0,
                                o = e ? e.length : 0;
                            if ("number" != typeof n && null != n) {
                                var a = o;
                                for (n = t.createCallback(n, i, 3); a-- && n(e[a], a, e);) r++
                            } else r = null == n || i ? 1 : n || r;
                            return p(e, 0, Xn(Wn(0, o - r), o))
                        }

                        function xt() {
                            for (var e = [], t = -1, n = arguments.length, o = h(), a = le(), s = a === i, c = h(); ++t < n;) {
                                var u = arguments[t];
                                (Zn(u) || fe(u)) && (e.push(u), o.push(s && u.length >= _ && l(t ? e[t] : c)))
                            }
                            var p = e[0],
                                m = -1,
                                v = p ? p.length : 0,
                                g = [];
                            e: for (; ++m < v;) {
                                var y = o[0];
                                if (u = p[m], (y ? r(y, u) : a(c, u)) < 0) {
                                    for (t = n, (y || c).push(u); --t;)
                                        if (y = o[t], (y ? r(y, u) : a(e[t], u)) < 0) continue e;
                                    g.push(u)
                                }
                            }
                            for (; n--;) y = o[n], y && d(y);
                            return f(o), f(c), g
                        }

                        function wt(e, n, i) {
                            var r = 0,
                                o = e ? e.length : 0;
                            if ("number" != typeof n && null != n) {
                                var a = o;
                                for (n = t.createCallback(n, i, 3); a-- && n(e[a], a, e);) r++
                            } else if (r = n, null == r || i) return e ? e[o - 1] : v;
                            return p(e, Wn(0, o - r))
                        }

                        function _t(e, t, n) {
                            var i = e ? e.length : 0;
                            for ("number" == typeof n && (i = (0 > n ? Wn(0, i + n) : Xn(n, i - 1)) + 1); i--;)
                                if (e[i] === t) return i;
                            return -1
                        }

                        function bt(e) {
                            for (var t = arguments, n = 0, i = t.length, r = e ? e.length : 0; ++n < i;)
                                for (var o = -1, a = t[n]; ++o < r;) e[o] === a && (kn.call(e, o--, 1), r--);
                            return e
                        }

                        function Et(e, t, n) {
                            e = +e || 0, n = "number" == typeof n ? n : +n || 1, null == t && (t = e, e = 0);
                            for (var i = -1, r = Wn(0, Pn((t - e) / (n || 1))), o = pn(r); ++i < r;) o[i] = e, e += n;
                            return o
                        }

                        function Mt(e, n, i) {
                            var r = -1,
                                o = e ? e.length : 0,
                                a = [];
                            for (n = t.createCallback(n, i, 3); ++r < o;) {
                                var s = e[r];
                                n(s, r, e) && (a.push(s), kn.call(e, r--, 1), o--)
                            }
                            return a
                        }

                        function St(e, n, i) {
                            if ("number" != typeof n && null != n) {
                                var r = 0,
                                    o = -1,
                                    a = e ? e.length : 0;
                                for (n = t.createCallback(n, i, 3); ++o < a && n(e[o], o, e);) r++
                            } else r = null == n || i ? 1 : Wn(0, n);
                            return p(e, r)
                        }

                        function Tt(e, n, i, r) {
                            var o = 0,
                                a = e ? e.length : o;
                            for (i = i ? t.createCallback(i, r, 1) : Jt, n = i(n); a > o;) {
                                var s = o + a >>> 1;
                                i(e[s]) < n ? o = s + 1 : a = s
                            }
                            return o
                        }

                        function Ct() {
                            return re(Q(arguments, !0, !0))
                        }

                        function At(e, n, i, r) {
                            return "boolean" != typeof n && null != n && (r = i, i = "function" != typeof n && r && r[n] === e ? null : n, n = !1), null != i && (i = t.createCallback(i, r, 3)), re(e, n, i)
                        }

                        function Pt(e) {
                            return Z(e, p(arguments, 1))
                        }

                        function Dt() {
                            for (var e = -1, t = arguments.length; ++e < t;) {
                                var n = arguments[e];
                                if (Zn(n) || fe(n)) var i = i ? re(Z(i, n).concat(Z(n, i))) : n
                            }
                            return i || []
                        }

                        function Lt() {
                            for (var e = arguments.length > 1 ? arguments : arguments[0], t = -1, n = e ? et(di(e, "length")) : 0, i = pn(0 > n ? 0 : n); ++t < n;) i[t] = di(e, t);
                            return i
                        }

                        function Rt(e, t) {
                            var n = -1,
                                i = e ? e.length : 0,
                                r = {};
                            for (t || !i || Zn(e[0]) || (t = []); ++n < i;) {
                                var o = e[n];
                                t ? r[o] = t[n] : o && (r[o[0]] = o[1])
                            }
                            return r
                        }

                        function Ot(e, t) {
                            if (!Pe(t)) throw new En;
                            return function() {
                                return --e < 1 ? t.apply(this, arguments) : void 0
                            }
                        }

                        function Nt(e, t) {
                            return arguments.length > 2 ? ae(e, 17, p(arguments, 2), null, t) : ae(e, 1, null, null, t)
                        }

                        function Ut(e) {
                            for (var t = arguments.length > 1 ? Q(arguments, !0, !1, 1) : we(e), n = -1, i = t.length; ++n < i;) {
                                var r = t[n];
                                e[r] = ae(e[r], 1, null, null, e)
                            }
                            return e
                        }

                        function Ft(e, t) {
                            return arguments.length > 2 ? ae(t, 19, p(arguments, 2), null, e) : ae(t, 3, null, null, e)
                        }

                        function kt() {
                            for (var e = arguments, t = e.length; t--;)
                                if (!Pe(e[t])) throw new En;
                            return function() {
                                for (var t = arguments, n = e.length; n--;) t = [e[n].apply(this, t)];
                                return t[0]
                            }
                        }

                        function Ht(e, t) {
                            return t = "number" == typeof t ? t : +t || e.length, ae(e, 4, null, null, null, t)
                        }

                        function It(e, t, n) {
                            var i, r, o, a, s, l, c, h = 0,
                                u = !1,
                                f = !0;
                            if (!Pe(e)) throw new En;
                            if (t = Wn(0, t) || 0, n === !0) {
                                var d = !0;
                                f = !1
                            } else De(n) && (d = n.leading, u = "maxWait" in n && (Wn(t, n.maxWait) || 0), f = "trailing" in n ? n.trailing : f);
                            var p = function() {
                                    var n = t - (mi() - a);
                                    if (0 >= n) {
                                        r && Dn(r);
                                        var u = c;
                                        r = l = c = v, u && (h = mi(), o = e.apply(s, i), l || r || (i = s = null))
                                    } else l = Fn(p, n)
                                },
                                m = function() {
                                    l && Dn(l), r = l = c = v, (f || u !== t) && (h = mi(), o = e.apply(s, i), l || r || (i = s = null))
                                };
                            return function() {
                                if (i = arguments, a = mi(), s = this, c = f && (l || !d), u === !1) var n = d && !l;
                                else {
                                    r || d || (h = a);
                                    var v = u - (a - h),
                                        g = 0 >= v;
                                    g ? (r && (r = Dn(r)), h = a, o = e.apply(s, i)) : r || (r = Fn(m, v))
                                }
                                return g && l ? l = Dn(l) : l || t === u || (l = Fn(p, t)), n && (g = !0, o = e.apply(s, i)), !g || l || r || (i = s = null), o
                            }
                        }

                        function Vt(e) {
                            if (!Pe(e)) throw new En;
                            var t = p(arguments, 1);
                            return Fn(function() {
                                e.apply(v, t)
                            }, 1)
                        }

                        function zt(e, t) {
                            if (!Pe(e)) throw new En;
                            var n = p(arguments, 2);
                            return Fn(function() {
                                e.apply(v, n)
                            }, t)
                        }

                        function Bt(e, t) {
                            if (!Pe(e)) throw new En;
                            var n = function() {
                                var i = n.cache,
                                    r = t ? t.apply(this, arguments) : w + arguments[0];
                                return Nn.call(i, r) ? i[r] : i[r] = e.apply(this, arguments)
                            };
                            return n.cache = {}, n
                        }

                        function jt(e) {
                            var t, n;
                            if (!Pe(e)) throw new En;
                            return function() {
                                return t ? n : (t = !0, n = e.apply(this, arguments), e = null, n)
                            }
                        }

                        function Gt(e) {
                            return ae(e, 16, p(arguments, 1))
                        }

                        function Wt(e) {
                            return ae(e, 32, null, p(arguments, 1))
                        }

                        function Xt(e, t, n) {
                            var i = !0,
                                r = !0;
                            if (!Pe(e)) throw new En;
                            return n === !1 ? i = !1 : De(n) && (i = "leading" in n ? n.leading : i, r = "trailing" in n ? n.trailing : r), q.leading = i, q.maxWait = t, q.trailing = r, It(e, t, q)
                        }

                        function qt(e, t) {
                            return ae(t, 16, [e])
                        }

                        function Kt(e) {
                            return function() {
                                return e
                            }
                        }

                        function Yt(e, t, n) {
                            var i = typeof e;
                            if (null == e || "function" == i) return b(e, t, n);
                            if ("object" != i) return tn(e);
                            var r = ei(e),
                                o = r[0],
                                a = e[o];
                            return 1 != r.length || a !== a || De(a) ? function(t) {
                                for (var n = r.length, i = !1; n-- && (i = ee(t[r[n]], e[r[n]], null, !0)););
                                return i
                            } : function(e) {
                                var t = e[o];
                                return a === t && (0 !== a || 1 / a == 1 / t)
                            }
                        }

                        function $t(e) {
                            return null == e ? "" : bn(e).replace(ri, se)
                        }

                        function Jt(e) {
                            return e
                        }

                        function Zt(e, i, r) {
                            var o = !0,
                                a = i && we(i);
                            i && (r || a.length) || (null == r && (r = i), s = n, i = e, e = t, a = we(i)), r === !1 ? o = !1 : De(r) && "chain" in r && (o = r.chain);
                            var s = e,
                                l = Pe(s);
                            $e(a, function(t) {
                                var n = e[t] = i[t];
                                l && (s.prototype[t] = function() {
                                    var t = this.__chain__,
                                        i = this.__wrapped__,
                                        r = [i];
                                    Un.apply(r, arguments);
                                    var a = n.apply(e, r);
                                    if (o || t) {
                                        if (i === a && De(a)) return this;
                                        a = new s(a), a.__chain__ = t
                                    }
                                    return a
                                })
                            })
                        }

                        function Qt() {
                            return e._ = Tn, this
                        }

                        function en() {}

                        function tn(e) {
                            return function(t) {
                                return t[e]
                            }
                        }

                        function nn(e, t, n) {
                            var i = null == e,
                                r = null == t;
                            if (null == n && ("boolean" == typeof e && r ? (n = e, e = 1) : r || "boolean" != typeof t || (n = t, r = !0)), i && r && (t = 1), e = +e || 0, r ? (t = e, e = 0) : t = +t || 0, n || e % 1 || t % 1) {
                                var o = Kn();
                                return Xn(e + o * (t - e + parseFloat("1e-" + ((o + "").length - 1))), t)
                            }
                            return ie(e, t)
                        }

                        function rn(e, t) {
                            if (e) {
                                var n = e[t];
                                return Pe(n) ? e[t]() : n
                            }
                        }

                        function on(e, n, i) {
                            var r = t.templateSettings;
                            e = bn(e || ""), i = ai({}, i, r);
                            var o, a = ai({}, i.imports, r.imports),
                                s = ei(a),
                                l = je(a),
                                h = 0,
                                u = i.interpolate || R,
                                f = "__p += '",
                                d = _n((i.escape || R).source + "|" + u.source + "|" + (u === D ? C : R).source + "|" + (i.evaluate || R).source + "|$", "g");
                            e.replace(d, function(t, n, i, r, a, s) {
                                return i || (i = r), f += e.slice(h, s).replace(N, c), n && (f += "' +\n__e(" + n + ") +\n'"), a && (o = !0, f += "';\n" + a + ";\n__p += '"), i && (f += "' +\n((__t = (" + i + ")) == null ? '' : __t) +\n'"), h = s + t.length, t
                            }), f += "';\n";
                            var p = i.variable,
                                m = p;
                            m || (p = "obj", f = "with (" + p + ") {\n" + f + "\n}\n"), f = (o ? f.replace(M, "") : f).replace(S, "$1").replace(T, "$1;"), f = "function(" + p + ") {\n" + (m ? "" : p + " || (" + p + " = {});\n") + "var __t, __p = '', __e = _.escape" + (o ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + f + "return __p\n}";
                            var g = "\n/*\n//# sourceURL=" + (i.sourceURL || "/lodash/template/source[" + F+++"]") + "\n*/";
                            try {
                                var y = gn(s, "return " + f + g).apply(v, l)
                            } catch (x) {
                                throw x.source = f, x
                            }
                            return n ? y(n) : (y.source = f, y)
                        }

                        function an(e, t, n) {
                            e = (e = +e) > -1 ? e : 0;
                            var i = -1,
                                r = pn(e);
                            for (t = b(t, n, 1); ++i < e;) r[i] = t(i);
                            return r
                        }

                        function sn(e) {
                            return null == e ? "" : bn(e).replace(ii, ue)
                        }

                        function ln(e) {
                            var t = ++x;
                            return bn(null == e ? "" : e) + t
                        }

                        function cn(e) {
                            return e = new n(e), e.__chain__ = !0, e
                        }

                        function hn(e, t) {
                            return t(e), e
                        }

                        function un() {
                            return this.__chain__ = !0, this
                        }

                        function fn() {
                            return bn(this.__wrapped__)
                        }

                        function dn() {
                            return this.__wrapped__
                        }
                        e = e ? ne.defaults(J.Object(), e, ne.pick(J, U)) : J;
                        var pn = e.Array,
                            mn = e.Boolean,
                            vn = e.Date,
                            gn = e.Function,
                            yn = e.Math,
                            xn = e.Number,
                            wn = e.Object,
                            _n = e.RegExp,
                            bn = e.String,
                            En = e.TypeError,
                            Mn = [],
                            Sn = wn.prototype,
                            Tn = e._,
                            Cn = Sn.toString,
                            An = _n("^" + bn(Cn).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"),
                            Pn = yn.ceil,
                            Dn = e.clearTimeout,
                            Ln = yn.floor,
                            Rn = gn.prototype.toString,
                            On = ce(On = wn.getPrototypeOf) && On,
                            Nn = Sn.hasOwnProperty,
                            Un = Mn.push,
                            Fn = e.setTimeout,
                            kn = Mn.splice,
                            Hn = Mn.unshift,
                            In = function() {
                                try {
                                    var e = {},
                                        t = ce(t = wn.defineProperty) && t,
                                        n = t(e, e, e) && t
                                } catch (i) {}
                                return n
                            }(),
                            Vn = ce(Vn = wn.create) && Vn,
                            zn = ce(zn = pn.isArray) && zn,
                            Bn = e.isFinite,
                            jn = e.isNaN,
                            Gn = ce(Gn = wn.keys) && Gn,
                            Wn = yn.max,
                            Xn = yn.min,
                            qn = e.parseInt,
                            Kn = yn.random,
                            Yn = {};
                        Yn[H] = pn, Yn[I] = mn, Yn[V] = vn, Yn[z] = gn, Yn[j] = wn, Yn[B] = xn, Yn[G] = _n, Yn[W] = bn, n.prototype = t.prototype;
                        var $n = t.support = {};
                        $n.funcDecomp = !ce(e.WinRTError) && O.test(m), $n.funcNames = "string" == typeof gn.name, t.templateSettings = {
                            escape: /<%-([\s\S]+?)%>/g,
                            evaluate: /<%([\s\S]+?)%>/g,
                            interpolate: D,
                            variable: "",
                            imports: {
                                _: t
                            }
                        }, Vn || (y = function() {
                            function t() {}
                            return function(n) {
                                if (De(n)) {
                                    t.prototype = n;
                                    var i = new t;
                                    t.prototype = null
                                }
                                return i || e.Object()
                            }
                        }());
                        var Jn = In ? function(e, t) {
                                K.value = t, In(e, "__bindData__", K), K.value = null
                            } : en,
                            Zn = zn || function(e) {
                                    return e && "object" == typeof e && "number" == typeof e.length && Cn.call(e) == H || !1
                                },
                            Qn = function(e) {
                                var t, n = e,
                                    i = [];
                                if (!n) return i;
                                if (!Y[typeof e]) return i;
                                for (t in n) Nn.call(n, t) && i.push(t);
                                return i
                            },
                            ei = Gn ? function(e) {
                                return De(e) ? Gn(e) : []
                            } : Qn,
                            ti = {
                                "&": "&amp;",
                                "<": "&lt;",
                                ">": "&gt;",
                                '"': "&quot;",
                                "'": "&#39;"
                            },
                            ni = be(ti),
                            ii = _n("(" + ei(ni).join("|") + ")", "g"),
                            ri = _n("[" + ei(ti).join("") + "]", "g"),
                            oi = function(e, t, n) {
                                var i, r = e,
                                    o = r;
                                if (!r) return o;
                                var a = arguments,
                                    s = 0,
                                    l = "number" == typeof n ? 2 : a.length;
                                if (l > 3 && "function" == typeof a[l - 2]) var c = b(a[--l - 1], a[l--], 2);
                                else l > 2 && "function" == typeof a[l - 1] && (c = a[--l]);
                                for (; ++s < l;)
                                    if (r = a[s], r && Y[typeof r])
                                        for (var h = -1, u = Y[typeof r] && ei(r), f = u ? u.length : 0; ++h < f;) i = u[h], o[i] = c ? c(o[i], r[i]) : r[i];
                                return o
                            },
                            ai = function(e, t, n) {
                                var i, r = e,
                                    o = r;
                                if (!r) return o;
                                for (var a = arguments, s = 0, l = "number" == typeof n ? 2 : a.length; ++s < l;)
                                    if (r = a[s], r && Y[typeof r])
                                        for (var c = -1, h = Y[typeof r] && ei(r), u = h ? h.length : 0; ++c < u;) i = h[c], "undefined" == typeof o[i] && (o[i] = r[i]);
                                return o
                            },
                            si = function(e, t, n) {
                                var i, r = e,
                                    o = r;
                                if (!r) return o;
                                if (!Y[typeof r]) return o;
                                t = t && "undefined" == typeof n ? t : b(t, n, 3);
                                for (i in r)
                                    if (t(r[i], i, e) === !1) return o;
                                return o
                            },
                            li = function(e, t, n) {
                                var i, r = e,
                                    o = r;
                                if (!r) return o;
                                if (!Y[typeof r]) return o;
                                t = t && "undefined" == typeof n ? t : b(t, n, 3);
                                for (var a = -1, s = Y[typeof r] && ei(r), l = s ? s.length : 0; ++a < l;)
                                    if (i = s[a], t(r[i], i, e) === !1) return o;
                                return o
                            },
                            ci = On ? function(e) {
                                if (!e || Cn.call(e) != j) return !1;
                                var t = e.valueOf,
                                    n = ce(t) && (n = On(t)) && On(n);
                                return n ? e == n || On(e) == n : he(e)
                            } : he,
                            hi = oe(function(e, t, n) {
                                Nn.call(e, n) ? e[n]++ : e[n] = 1
                            }),
                            ui = oe(function(e, t, n) {
                                (Nn.call(e, n) ? e[n] : e[n] = []).push(t)
                            }),
                            fi = oe(function(e, t, n) {
                                e[n] = t
                            }),
                            di = Qe,
                            pi = qe,
                            mi = ce(mi = vn.now) && mi || function() {
                                    return (new vn).getTime()
                                },
                            vi = 8 == qn(E + "08") ? qn : function(e, t) {
                                return qn(Ue(e) ? e.replace(L, "") : e, t || 0)
                            };
                        return t.after = Ot, t.assign = oi, t.at = Ge, t.bind = Nt, t.bindAll = Ut, t.bindKey = Ft, t.chain = cn, t.compact = ut, t.compose = kt, t.constant = Kt, t.countBy = hi, t.create = me, t.createCallback = Yt, t.curry = Ht, t.debounce = It, t.defaults = ai, t.defer = Vt, t.delay = zt, t.difference = ft, t.filter = qe, t.flatten = vt, t.forEach = $e, t.forEachRight = Je, t.forIn = si, t.forInRight = ye, t.forOwn = li, t.forOwnRight = xe, t.functions = we, t.groupBy = ui, t.indexBy = fi, t.initial = yt, t.intersection = xt, t.invert = be, t.invoke = Ze, t.keys = ei, t.map = Qe, t.mapValues = ke, t.max = et, t.memoize = Bt, t.merge = He, t.min = tt, t.omit = Ie, t.once = jt, t.pairs = Ve, t.partial = Gt, t.partialRight = Wt, t.pick = ze, t.pluck = di, t.property = tn, t.pull = bt, t.range = Et, t.reject = rt, t.remove = Mt, t.rest = St, t.shuffle = at, t.sortBy = ct, t.tap = hn, t.throttle = Xt, t.times = an, t.toArray = ht, t.transform = Be, t.union = Ct, t.uniq = At, t.values = je, t.where = pi, t.without = Pt, t.wrap = qt, t.xor = Dt, t.zip = Lt, t.zipObject = Rt, t.collect = Qe, t.drop = St, t.each = $e, t.eachRight = Je, t.extend = oi, t.methods = we, t.object = Rt, t.select = qe, t.tail = St, t.unique = At, t.unzip = Lt, Zt(t), t.clone = de, t.cloneDeep = pe, t.contains = We, t.escape = $t, t.every = Xe, t.find = Ke, t.findIndex = dt, t.findKey = ve, t.findLast = Ye, t.findLastIndex = pt, t.findLastKey = ge, t.has = _e, t.identity = Jt, t.indexOf = gt, t.isArguments = fe, t.isArray = Zn, t.isBoolean = Ee, t.isDate = Me, t.isElement = Se, t.isEmpty = Te, t.isEqual = Ce, t.isFinite = Ae, t.isFunction = Pe, t.isNaN = Le, t.isNull = Re, t.isNumber = Oe, t.isObject = De, t.isPlainObject = ci, t.isRegExp = Ne, t.isString = Ue, t.isUndefined = Fe, t.lastIndexOf = _t, t.mixin = Zt, t.noConflict = Qt, t.noop = en, t.now = mi, t.parseInt = vi, t.random = nn, t.reduce = nt, t.reduceRight = it, t.result = rn, t.runInContext = m, t.size = st, t.some = lt, t.sortedIndex = Tt, t.template = on, t.unescape = sn, t.uniqueId = ln, t.all = Xe, t.any = lt, t.detect = Ke, t.findWhere = Ke, t.foldl = nt, t.foldr = it, t.include = We, t.inject = nt, Zt(function() {
                            var e = {};
                            return li(t, function(n, i) {
                                t.prototype[i] || (e[i] = n)
                            }), e
                        }(), !1), t.first = mt, t.last = wt, t.sample = ot, t.take = mt, t.head = mt, li(t, function(e, i) {
                            var r = "sample" !== i;
                            t.prototype[i] || (t.prototype[i] = function(t, i) {
                                var o = this.__chain__,
                                    a = e(this.__wrapped__, t, i);
                                return o || null != t && (!i || r && "function" == typeof t) ? new n(a, o) : a
                            })
                        }), t.VERSION = "2.4.2", t.prototype.chain = un, t.prototype.toString = fn, t.prototype.value = dn, t.prototype.valueOf = dn, $e(["join", "pop", "shift"], function(e) {
                            var i = Mn[e];
                            t.prototype[e] = function() {
                                var e = this.__chain__,
                                    t = i.apply(this.__wrapped__, arguments);
                                return e ? new n(t, e) : t
                            }
                        }), $e(["push", "reverse", "sort", "unshift"], function(e) {
                            var n = Mn[e];
                            t.prototype[e] = function() {
                                return n.apply(this.__wrapped__, arguments), this
                            }
                        }), $e(["concat", "slice", "splice"], function(e) {
                            var i = Mn[e];
                            t.prototype[e] = function() {
                                return new n(i.apply(this.__wrapped__, arguments), this.__chain__)
                            }
                        }), t
                    }
                    var v, g = [],
                        y = [],
                        x = 0,
                        w = +new Date + "",
                        _ = 75,
                        b = 40,
                        E = " 	\x0B\f\ufeff\n\r\u2028\u2029",
                        M = /\b__p \+= '';/g,
                        S = /\b(__p \+=) '' \+/g,
                        T = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                        C = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                        A = /\w*$/,
                        P = /^\s*function[ \n\r\t]+\w/,
                        D = /<%=([\s\S]+?)%>/g,
                        L = RegExp("^[" + E + "]*0+(?=.$)"),
                        R = /($^)/,
                        O = /\bthis\b/,
                        N = /['\n\r\t\u2028\u2029\\]/g,
                        U = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout"],
                        F = 0,
                        k = "[object Arguments]",
                        H = "[object Array]",
                        I = "[object Boolean]",
                        V = "[object Date]",
                        z = "[object Function]",
                        B = "[object Number]",
                        j = "[object Object]",
                        G = "[object RegExp]",
                        W = "[object String]",
                        X = {};
                    X[z] = !1, X[k] = X[H] = X[I] = X[V] = X[B] = X[j] = X[G] = X[W] = !0;
                    var q = {
                            leading: !1,
                            maxWait: 0,
                            trailing: !1
                        },
                        K = {
                            configurable: !1,
                            enumerable: !1,
                            value: null,
                            writable: !1
                        },
                        Y = {
                            "boolean": !1,
                            "function": !0,
                            object: !0,
                            number: !1,
                            string: !1,
                            undefined: !1
                        },
                        $ = {
                            "\\": "\\",
                            "'": "'",
                            "\n": "n",
                            "\r": "r",
                            "	": "t",
                            "\u2028": "u2028",
                            "\u2029": "u2029"
                        },
                        J = Y[typeof window] && window || this,
                        Z = Y[typeof n] && n && !n.nodeType && n,
                        Q = Y[typeof t] && t && !t.nodeType && t,
                        ee = Q && Q.exports === Z && Z,
                        te = Y[typeof e] && e;
                    !te || te.global !== te && te.window !== te || (J = te);
                    var ne = m();
                    "function" == typeof define && "object" == typeof define.amd && define.amd ? (J._ = ne, define(function() {
                        return ne
                    })) : Z && Q ? ee ? (Q.exports = ne)._ = ne : Z._ = ne : J._ = ne
                }).call(this)
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {}
    ],
    6: [
        function(e, t, n) {
            ! function() {
                var e = {};
                ! function() {
                    "use strict";

                    function t(e, n, i) {
                        var r = function() {};
                        r.prototype = e.prototype;
                        var o = new r,
                            a = /xyz/.test(function() {
                                xyz
                            }) ? /\bparent\b/ : /.*/;
                        i = i || {};
                        for (var s in i) {
                            var l = i[s],
                                c = o[s];
                            "function" == typeof c && "function" == typeof l && a.test(l) ? o[s] = function(e, t) {
                                return function() {
                                    var n = this.parent;
                                    this.parent = t;
                                    var i = e.apply(this, arguments);
                                    return this.parent = n, i
                                }
                            }(l, c) : o[s] = l
                        }
                        o.typename = n;
                        var h = function() {
                            o.init && o.init.apply(this, arguments)
                        };
                        return h.prototype = o, h.prototype.constructor = h, h.extend = function(e, n) {
                            return "object" == typeof e && (n = e, e = "anonymous"), t(h, e, n)
                        }, h
                    }
                    e.object = t(Object, "Object", {})
                }(),
                    function() {
                        "use strict";
                        var t = Array.prototype,
                            n = Object.prototype,
                            i = {
                                "&": "&amp;",
                                '"': "&quot;",
                                "'": "&#39;",
                                "<": "&lt;",
                                ">": "&gt;"
                            },
                            r = /[&"'<>]/g,
                            o = function(e) {
                                return i[e]
                            },
                            a = e.lib = {};
                        a.withPrettyErrors = function(e, t, n) {
                            try {
                                return n()
                            } catch (i) {
                                if (i.Update || (i = new a.TemplateError(i)), i.Update(e), !t) {
                                    var r = i;
                                    i = new Error(r.message), i.name = r.name
                                }
                                throw i
                            }
                        }, a.TemplateError = function(e, t, n) {
                            var i = this;
                            return e instanceof Error ? (i = e, e = e.name + ": " + e.message) : Error.captureStackTrace && Error.captureStackTrace(i), i.name = "Template render error", i.message = e, i.lineno = t, i.colno = n, i.firstUpdate = !0, i.Update = function(e) {
                                var t = "(" + (e || "unknown path") + ")";
                                return this.firstUpdate && (this.lineno && this.colno ? t += " [Line " + this.lineno + ", Column " + this.colno + "]" : this.lineno && (t += " [Line " + this.lineno + "]")), t += "\n ", this.firstUpdate && (t += " "), this.message = t + (this.message || ""), this.firstUpdate = !1, this
                            }, i
                        }, a.TemplateError.prototype = Error.prototype, a.escape = function(e) {
                            return e.replace(r, o)
                        }, a.isFunction = function(e) {
                            return "[object Function]" === n.toString.call(e)
                        }, a.isArray = Array.isArray || function(e) {
                            return "[object Array]" === n.toString.call(e)
                        }, a.isString = function(e) {
                            return "[object String]" === n.toString.call(e)
                        }, a.isObject = function(e) {
                            return "[object Object]" === n.toString.call(e)
                        }, a.groupBy = function(e, t) {
                            for (var n = {}, i = a.isFunction(t) ? t : function(e) {
                                return e[t]
                            }, r = 0; r < e.length; r++) {
                                var o = e[r],
                                    s = i(o, r);
                                (n[s] || (n[s] = [])).push(o)
                            }
                            return n
                        }, a.toArray = function(e) {
                            return Array.prototype.slice.call(e)
                        }, a.without = function(e) {
                            var t = [];
                            if (!e) return t;
                            for (var n = -1, i = e.length, r = a.toArray(arguments).slice(1); ++n < i;) - 1 === a.indexOf(r, e[n]) && t.push(e[n]);
                            return t
                        }, a.extend = function(e, t) {
                            for (var n in t) e[n] = t[n];
                            return e
                        }, a.repeat = function(e, t) {
                            for (var n = "", i = 0; t > i; i++) n += e;
                            return n
                        }, a.each = function(e, n, i) {
                            if (null != e)
                                if (t.each && e.each === t.each) e.forEach(n, i);
                                else if (e.length === +e.length)
                                    for (var r = 0, o = e.length; o > r; r++) n.call(i, e[r], r, e)
                        }, a.map = function(e, n) {
                            var i = [];
                            if (null == e) return i;
                            if (t.map && e.map === t.map) return e.map(n);
                            for (var r = 0; r < e.length; r++) i[i.length] = n(e[r], r);
                            return e.length === +e.length && (i.length = e.length), i
                        }, a.asyncIter = function(e, t, n) {
                            function i() {
                                r++, r < e.length ? t(e[r], r, i, n) : n()
                            }
                            var r = -1;
                            i()
                        }, a.asyncFor = function(e, t, n) {
                            function i() {
                                s++;
                                var a = r[s];
                                o > s ? t(a, e[a], s, o, i) : n()
                            }
                            var r = a.keys(e),
                                o = r.length,
                                s = -1;
                            i()
                        }, a.indexOf = Array.prototype.indexOf ? function(e, t, n) {
                            return Array.prototype.indexOf.call(e, t, n)
                        } : function(e, t, n) {
                            var i = this.length >>> 0;
                            for (n = +n || 0, Math.abs(n) === 1 / 0 && (n = 0), 0 > n && (n += i, 0 > n && (n = 0)); i > n; n++)
                                if (e[n] === t) return n;
                            return -1
                        }, Array.prototype.map || (Array.prototype.map = function() {
                            throw new Error("map is unimplemented for this js engine")
                        }), a.keys = function(e) {
                            if (Object.prototype.keys) return e.keys();
                            var t = [];
                            for (var n in e) e.hasOwnProperty(n) && t.push(n);
                            return t
                        }
                    }(),
                    function() {
                        "use strict";

                        function t(e, t, n) {
                            return function() {
                                var o, a = r(arguments),
                                    s = i(arguments);
                                if (a > e.length) {
                                    o = Array.prototype.slice.call(arguments, 0, e.length);
                                    for (var l = Array.prototype.slice.call(arguments, o.length, a), c = 0; c < l.length; c++) c < t.length && (s[t[c]] = l[c]);
                                    o.push(s)
                                } else if (a < e.length) {
                                    o = Array.prototype.slice.call(arguments, 0, a);
                                    for (var c = a; c < e.length; c++) {
                                        var h = e[c];
                                        o.push(s[h]), delete s[h]
                                    }
                                    o.push(s)
                                } else o = arguments;
                                return n.apply(this, o)
                            }
                        }

                        function n(e) {
                            return e.__keywords = !0, e
                        }

                        function i(e) {
                            var t = e.length;
                            if (t) {
                                var n = e[t - 1];
                                if (n && n.hasOwnProperty("__keywords")) return n
                            }
                            return {}
                        }

                        function r(e) {
                            var t = e.length;
                            if (0 === t) return 0;
                            var n = e[t - 1];
                            return n && n.hasOwnProperty("__keywords") ? t - 1 : t
                        }

                        function o(e) {
                            return "string" != typeof e ? e : void(this.val = e)
                        }

                        function a(e, t) {
                            return e instanceof o ? new o(t) : t.toString()
                        }

                        function s(e) {
                            var t = typeof e;
                            return "string" === t ? new o(e) : "function" !== t ? e : function() {
                                var t = e.apply(this, arguments);
                                return "string" == typeof t ? new o(t) : t
                            }
                        }

                        function l(e, t) {
                            return e = void 0 !== e && null !== e ? e : "", t && "string" == typeof e && (e = m.escape(e)), e
                        }

                        function c(e, t) {
                            return e = e || {}, "function" == typeof e[t] ? function() {
                                return e[t].apply(e, arguments)
                            } : e[t]
                        }

                        function h(e, t, n) {
                            if (!e) throw new Error("Unable to call `" + t + "`, which is undefined or falsey");
                            if ("function" != typeof e) throw new Error("Unable to call `" + t + "`, which is not a function");
                            return e.apply(this, n)
                        }

                        function u(e, t, n) {
                            var i = t.lookup(n);
                            return void 0 !== i && null !== i ? i : e.lookup(n)
                        }

                        function f(e, t, n) {
                            return e.lineno ? e : new m.TemplateError(e, t, n)
                        }

                        function d(e, t, n, i) {
                            if (m.isArray(e)) {
                                var r = e.length;
                                m.asyncIter(e, function(e, i, o) {
                                    switch (t) {
                                        case 1:
                                            n(e, i, r, o);
                                            break;
                                        case 2:
                                            n(e[0], e[1], i, r, o);
                                            break;
                                        case 3:
                                            n(e[0], e[1], e[2], i, r, o);
                                            break;
                                        default:
                                            e.push(i, o), n.apply(this, e)
                                    }
                                }, i)
                            } else m.asyncFor(e, function(e, t, i, r, o) {
                                n(e, t, i, r, o)
                            }, i)
                        }

                        function p(e, t, n, i) {
                            function r(e, t) {
                                s++, a[e] = t, s === o && i(null, a.join(""))
                            }
                            var o, a, s = 0;
                            if (m.isArray(e))
                                if (o = e.length, a = new Array(o), 0 === o) i(null, "");
                                else
                                    for (var l = 0; l < e.length; l++) {
                                        var c = e[l];
                                        switch (t) {
                                            case 1:
                                                n(c, l, o, r);
                                                break;
                                            case 2:
                                                n(c[0], c[1], l, o, r);
                                                break;
                                            case 3:
                                                n(c[0], c[1], c[2], l, o, r);
                                                break;
                                            default:
                                                c.push(l, r), n.apply(this, c)
                                        }
                                    } else {
                                var h = m.keys(e);
                                if (o = h.length, a = new Array(o), 0 === o) i(null, "");
                                else
                                    for (var l = 0; l < h.length; l++) {
                                        var u = h[l];
                                        n(u, e[u], l, o, r)
                                    }
                            }
                        }
                        var m = e.lib,
                            v = e.object,
                            g = v.extend({
                                init: function(e) {
                                    this.variables = {}, this.parent = e
                                },
                                set: function(e, t, n) {
                                    var i = e.split("."),
                                        r = this.variables,
                                        o = this;
                                    if (n) {
                                        if (o = this.resolve(i[0])) return void o.set(e, t);
                                        o = this
                                    }
                                    for (var a = 0; a < i.length - 1; a++) {
                                        var s = i[a];
                                        r[s] || (r[s] = {}), r = r[s]
                                    }
                                    r[i[i.length - 1]] = t
                                },
                                get: function(e) {
                                    var t = this.variables[e];
                                    return void 0 !== t && null !== t ? t : null
                                },
                                lookup: function(e) {
                                    var t = this.parent,
                                        n = this.variables[e];
                                    return void 0 !== n && null !== n ? n : t && t.lookup(e)
                                },
                                resolve: function(e) {
                                    var t = this.parent,
                                        n = this.variables[e];
                                    return void 0 !== n && null !== n ? this : t && t.resolve(e)
                                },
                                push: function() {
                                    return new g(this)
                                },
                                pop: function() {
                                    return this.parent
                                }
                            });
                        o.prototype = Object.create(String.prototype), o.prototype.valueOf = function() {
                            return this.val
                        }, o.prototype.toString = function() {
                            return this.val
                        }, e.runtime = {
                            Frame: g,
                            makeMacro: t,
                            makeKeywordArgs: n,
                            numArgs: r,
                            suppressValue: l,
                            memberLookup: c,
                            contextOrFrameLookup: u,
                            callWrap: h,
                            handleError: f,
                            isArray: m.isArray,
                            keys: m.keys,
                            SafeString: o,
                            copySafeness: a,
                            markSafe: s,
                            asyncEach: d,
                            asyncAll: p
                        }
                    }(),
                    function() {
                        "use strict";
                        var t = e.path,
                            n = e.object,
                            i = e.lib,
                            r = n.extend({
                                on: function(e, t) {
                                    this.listeners = this.listeners || {}, this.listeners[e] = this.listeners[e] || [], this.listeners[e].push(t)
                                },
                                emit: function(e) {
                                    var t = Array.prototype.slice.call(arguments, 1);
                                    this.listeners && this.listeners[e] && i.each(this.listeners[e], function(e) {
                                        e.apply(null, t)
                                    })
                                },
                                resolve: function(e, n) {
                                    return t.resolve(t.dirname(e), n)
                                },
                                isRelative: function(e) {
                                    return 0 === e.indexOf("./") || 0 === e.indexOf("../")
                                }
                            });
                        e.loader = r
                    }(),
                    function() {
                        "use strict";
                        var t = e.loader,
                            n = t.extend({
                                init: function(e, t) {
                                    this.precompiled = window.nunjucksPrecompiled || {}, this.baseURL = e || "", this.neverUpdate = t
                                },
                                getSource: function(e) {
                                    if (this.precompiled[e]) return {
                                        src: {
                                            type: "code",
                                            obj: this.precompiled[e]
                                        },
                                        path: e
                                    };
                                    var t = this.fetch(this.baseURL + "/" + e);
                                    return t ? {
                                        src: t,
                                        path: e,
                                        noCache: !this.neverUpdate
                                    } : null
                                },
                                fetch: function(e, t) {
                                    var n, i, r = !0;
                                    return window.XMLHttpRequest ? n = new XMLHttpRequest : window.ActiveXObject && (n = new ActiveXObject("Microsoft.XMLHTTP")), n.onreadystatechange = function() {
                                        4 !== n.readyState || 0 !== n.status && 200 !== n.status || !r || (r = !1, i = n.responseText)
                                    }, e += (-1 === e.indexOf("?") ? "?" : "&") + "s=" + (new Date).getTime(), n.open("GET", e, !1), n.send(), i
                                }
                            });
                        e["web-loaders"] = {
                            WebLoader: n
                        }
                    }(),
                    function() {
                        "undefined" == typeof window || window !== this ? e.loaders = e["node-loaders"] : e.loaders = e["web-loaders"]
                    }(),
                    function() {
                        "use strict";
                        var t = e.lib,
                            n = e.runtime,
                            i = {
                                abs: function(e) {
                                    return Math.abs(e)
                                },
                                batch: function(e, t, n) {
                                    for (var i = [], r = [], o = 0; o < e.length; o++) o % t === 0 && r.length && (i.push(r), r = []), r.push(e[o]);
                                    if (r.length) {
                                        if (n)
                                            for (var o = r.length; t > o; o++) r.push(n);
                                        i.push(r)
                                    }
                                    return i
                                },
                                capitalize: function(e) {
                                    var t = e.toLowerCase();
                                    return n.copySafeness(e, t.charAt(0).toUpperCase() + t.slice(1))
                                },
                                center: function(e, i) {
                                    if (i = i || 80, e.length >= i) return e;
                                    var r = i - e.length,
                                        o = t.repeat(" ", r / 2 - r % 2),
                                        a = t.repeat(" ", r / 2);
                                    return n.copySafeness(e, o + e + a)
                                },
                                "default": function(e, t) {
                                    return e ? e : t
                                },
                                dictsort: function(e, n, i) {
                                    if (!t.isObject(e)) throw new t.TemplateError("dictsort filter: val must be an object");
                                    var r = [];
                                    for (var o in e) r.push([o, e[o]]);
                                    var a;
                                    if (void 0 === i || "key" === i) a = 0;
                                    else {
                                        if ("value" !== i) throw new t.TemplateError("dictsort filter: You can only sort by either key or value");
                                        a = 1
                                    }
                                    return r.sort(function(e, i) {
                                        var r = e[a],
                                            o = i[a];
                                        return n || (t.isString(r) && (r = r.toUpperCase()), t.isString(o) && (o = o.toUpperCase())), r > o ? 1 : r === o ? 0 : -1
                                    }), r
                                },
                                escape: function(e) {
                                    return "string" == typeof e || e instanceof n.SafeString ? t.escape(e) : e
                                },
                                safe: function(e) {
                                    return n.markSafe(e)
                                },
                                first: function(e) {
                                    return e[0]
                                },
                                groupby: function(e, n) {
                                    return t.groupBy(e, n)
                                },
                                indent: function(e, i, r) {
                                    i = i || 4;
                                    for (var o = "", a = e.split("\n"), s = t.repeat(" ", i), l = 0; l < a.length; l++) o += 0 !== l || r ? s + a[l] + "\n" : a[l] + "\n";
                                    return n.copySafeness(e, o)
                                },
                                join: function(e, n, i) {
                                    return n = n || "", i && (e = t.map(e, function(e) {
                                        return e[i]
                                    })), e.join(n)
                                },
                                last: function(e) {
                                    return e[e.length - 1]
                                },
                                length: function(e) {
                                    return void 0 !== e ? e.length : 0
                                },
                                list: function(e) {
                                    if (t.isString(e)) return e.split("");
                                    if (t.isObject(e)) {
                                        var n = [];
                                        if (Object.keys) n = Object.keys(e);
                                        else
                                            for (var i in e) n.push(i);
                                        return t.map(n, function(t) {
                                            return {
                                                key: t,
                                                value: e[t]
                                            }
                                        })
                                    }
                                    if (t.isArray(e)) return e;
                                    throw new t.TemplateError("list filter: type not iterable")
                                },
                                lower: function(e) {
                                    return e.toLowerCase()
                                },
                                random: function(e) {
                                    return e[Math.floor(Math.random() * e.length)]
                                },
                                rejectattr: function(e, t) {
                                    return e.filter(function(e) {
                                        return !e[t]
                                    })
                                },
                                selectattr: function(e, t) {
                                    return e.filter(function(e) {
                                        return !!e[t]
                                    })
                                },
                                replace: function(e, t, i, r) {
                                    if (t instanceof RegExp) return e.replace(t, i);
                                    var o = e,
                                        a = o,
                                        s = 1;
                                    for (o = o.replace(t, i); a !== o && !(s >= r);) a = o, o = o.replace(t, i), s++;
                                    return n.copySafeness(e, o)
                                },
                                reverse: function(e) {
                                    var r;
                                    return r = t.isString(e) ? i.list(e) : t.map(e, function(e) {
                                        return e
                                    }), r.reverse(), t.isString(e) ? n.copySafeness(e, r.join("")) : r
                                },
                                round: function(e, t, n) {
                                    t = t || 0;
                                    var i, r = Math.pow(10, t);
                                    return i = "ceil" === n ? Math.ceil : "floor" === n ? Math.floor : Math.round, i(e * r) / r
                                },
                                slice: function(e, t, n) {
                                    for (var i = Math.floor(e.length / t), r = e.length % t, o = 0, a = [], s = 0; t > s; s++) {
                                        var l = o + s * i;
                                        r > s && o++;
                                        var c = o + (s + 1) * i,
                                            h = e.slice(l, c);
                                        n && s >= r && h.push(n), a.push(h)
                                    }
                                    return a
                                },
                                sort: function(e, n, i, r) {
                                    return e = t.map(e, function(e) {
                                        return e
                                    }), e.sort(function(e, o) {
                                        var a, s;
                                        return r ? (a = e[r], s = o[r]) : (a = e, s = o), !i && t.isString(a) && t.isString(s) && (a = a.toLowerCase(), s = s.toLowerCase()), s > a ? n ? 1 : -1 : a > s ? n ? -1 : 1 : 0
                                    }), e
                                },
                                string: function(e) {
                                    return n.copySafeness(e, e)
                                },
                                title: function(e) {
                                    for (var t = e.split(" "), r = 0; r < t.length; r++) t[r] = i.capitalize(t[r]);
                                    return n.copySafeness(e, t.join(" "))
                                },
                                trim: function(e) {
                                    return n.copySafeness(e, e.replace(/^\s*|\s*$/g, ""))
                                },
                                truncate: function(e, t, i, r) {
                                    var o = e;
                                    if (t = t || 255, e.length <= t) return e;
                                    if (i) e = e.substring(0, t);
                                    else {
                                        var a = e.lastIndexOf(" ", t); - 1 === a && (a = t), e = e.substring(0, a)
                                    }
                                    return e += void 0 !== r && null !== r ? r : "...", n.copySafeness(o, e)
                                },
                                upper: function(e) {
                                    return e.toUpperCase()
                                },
                                urlencode: function(e) {
                                    var n = encodeURIComponent;
                                    if (t.isString(e)) return n(e);
                                    var i;
                                    if (t.isArray(e)) i = e.map(function(e) {
                                        return n(e[0]) + "=" + n(e[1])
                                    });
                                    else {
                                        i = [];
                                        for (var r in e) e.hasOwnProperty(r) && i.push(n(r) + "=" + n(e[r]))
                                    }
                                    return i.join("&")
                                },
                                urlize: function(e, t, n) {
                                    isNaN(t) && (t = 1 / 0);
                                    var i = n === !0 ? ' rel="nofollow"' : "",
                                        r = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/,
                                        o = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i,
                                        a = /^https?:\/\/.*$/,
                                        s = /^www\./,
                                        l = /\.(?:org|net|com)(?:\:|\/|$)/,
                                        c = e.split(/\s+/).filter(function(e) {
                                            return e && e.length
                                        }).map(function(e) {
                                            var n = e.match(r),
                                                c = n && n[1] || e;
                                            return a.test(c) ? '<a href="' + c + '"' + i + ">" + c.substr(0, t) + "</a>" : s.test(c) ? '<a href="http://' + c + '"' + i + ">" + c.substr(0, t) + "</a>" : o.test(c) ? '<a href="mailto:' + c + '">' + c + "</a>" : l.test(c) ? '<a href="http://' + c + '"' + i + ">" + c.substr(0, t) + "</a>" : e
                                        });
                                    return c.join(" ")
                                },
                                wordcount: function(e) {
                                    var t = e ? e.match(/\w+/g) : null;
                                    return t ? t.length : null
                                },
                                "float": function(e, t) {
                                    var n = parseFloat(e);
                                    return isNaN(n) ? t : n
                                },
                                "int": function(e, t) {
                                    var n = parseInt(e, 10);
                                    return isNaN(n) ? t : n
                                }
                            };
                        i.d = i["default"], i.e = i.escape, e.filters = i
                    }(),
                    function() {
                        "use strict";

                        function t(e) {
                            var t = -1;
                            return {
                                current: null,
                                reset: function() {
                                    t = -1, this.current = null
                                },
                                next: function() {
                                    return t++, t >= e.length && (t = 0), this.current = e[t], this.current
                                }
                            }
                        }

                        function n(e) {
                            e = e || ",";
                            var t = !0;
                            return function() {
                                var n = t ? "" : e;
                                return t = !1, n
                            }
                        }
                        var i = {
                            range: function(e, t, n) {
                                t ? n || (n = 1) : (t = e, e = 0, n = 1);
                                for (var i = [], r = e; t > r; r += n) i.push(r);
                                return i
                            },
                            cycler: function() {
                                return t(Array.prototype.slice.call(arguments))
                            },
                            joiner: function(e) {
                                return n(e)
                            }
                        };
                        e.globals = i
                    }(),
                    function() {
                        "use strict";
                        var t = e.path,
                            n = e.lib,
                            i = e.object,
                            r = (e.lexer, e.compiler),
                            o = e.filters,
                            a = e.loaders,
                            s = e.runtime,
                            l = e.globals,
                            c = s.Frame,
                            h = i.extend({
                                init: function(e, t) {
                                    var t = this.opts = t || {};
                                    this.opts.dev = !!t.dev, this.opts.autoescape = !!t.autoescape, this.opts.trimBlocks = !!t.trimBlocks, this.opts.lstripBlocks = !!t.lstripBlocks, e ? this.loaders = n.isArray(e) ? e : [e] : a.FileSystemLoader ? this.loaders = [new a.FileSystemLoader("views")] : this.loaders = [new a.WebLoader("/views")], this.initCache(), this.filters = {}, this.asyncFilters = [], this.extensions = {}, this.extensionsList = [];
                                    for (var i in o) this.addFilter(i, o[i])
                                },
                                initCache: function() {
                                    n.each(this.loaders, function(e) {
                                        e.cache = {}, "function" == typeof e.on && e.on("update", function(t) {
                                            e.cache[t] = null
                                        })
                                    })
                                },
                                addExtension: function(e, t) {
                                    t._name = e, this.extensions[e] = t, this.extensionsList.push(t)
                                },
                                getExtension: function(e) {
                                    return this.extensions[e]
                                },
                                addGlobal: function(e, t) {
                                    l[e] = t
                                },
                                addFilter: function(e, t, n) {
                                    var i = t;
                                    n && this.asyncFilters.push(e), this.filters[e] = i
                                },
                                getFilter: function(e) {
                                    if (!this.filters[e]) throw new Error("filter not found: " + e);
                                    return this.filters[e]
                                },
                                resolveTemplate: function(e, t, n) {
                                    var i = e.isRelative && t ? e.isRelative(n) : !1;
                                    return i && e.resolve ? e.resolve(t, n) : n
                                },
                                getTemplate: function(e, t, i, r) {
                                    var o = this,
                                        a = null;
                                    if (e && e.raw && (e = e.raw), n.isFunction(i) && (r = i, i = null, t = t || !1), n.isFunction(t) && (r = t, t = !1), "string" != typeof e) throw new Error("template names must be a string: " + e);
                                    for (var s = 0; s < this.loaders.length; s++) {
                                        var l = this.resolveTemplate(this.loaders[s], i, e);
                                        if (a = this.loaders[s].cache[l]) break
                                    }
                                    if (!a) {
                                        var c;
                                        return n.asyncIter(this.loaders, function(t, n, r, a) {
                                            function s(e) {
                                                e ? (e.loader = t, a(e)) : r()
                                            }
                                            e = o.resolveTemplate(t, i, e), t.async ? t.getSource(e, function(e, t) {
                                                if (e) throw e;
                                                s(t)
                                            }) : s(t.getSource(e))
                                        }, function(n) {
                                            if (n) {
                                                var i = new f(n.src, this, n.path, t);
                                                n.noCache || (n.loader.cache[e] = i), r ? r(null, i) : c = i
                                            } else {
                                                var o = new Error("template not found: " + e);
                                                if (!r) throw o;
                                                r(o)
                                            }
                                        }.bind(this)), c
                                    }
                                    return t && a.compile(), r ? void r(null, a) : a
                                },
                                express: function(e) {
                                    function n(e, n) {
                                        if (this.name = e, this.path = e, this.defaultEngine = n.defaultEngine, this.ext = t.extname(e), !this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
                                        this.ext || (this.name += this.ext = ("." !== this.defaultEngine[0] ? "." : "") + this.defaultEngine)
                                    }
                                    var i = this;
                                    n.prototype.render = function(e, t) {
                                        i.render(this.name, e, t)
                                    }, e.set("view", n)
                                },
                                render: function(e, t, i) {
                                    n.isFunction(t) && (i = t, t = null);
                                    var r = null;
                                    return this.getTemplate(e, function(e, n) {
                                        if (e && i) i(e);
                                        else {
                                            if (e) throw e;
                                            n.render(t, i || function(e, t) {
                                                if (e) throw e;
                                                r = t
                                            })
                                        }
                                    }), r
                                },
                                renderString: function(e, t, i, r) {
                                    n.isFunction(i) && (r = i, i = {}), i = i || {};
                                    var o = new f(e, this, i.path);
                                    return o.render(t, r)
                                }
                            }),
                            u = i.extend({
                                init: function(e, t) {
                                    this.ctx = e, this.blocks = {}, this.exported = [];
                                    for (var n in t) this.addBlock(n, t[n])
                                },
                                lookup: function(e) {
                                    return e in l && !(e in this.ctx) ? l[e] : this.ctx[e]
                                },
                                setVariable: function(e, t) {
                                    this.ctx[e] = t
                                },
                                getVariables: function() {
                                    return this.ctx
                                },
                                addBlock: function(e, t) {
                                    this.blocks[e] = this.blocks[e] || [], this.blocks[e].push(t)
                                },
                                getBlock: function(e) {
                                    if (!this.blocks[e]) throw new Error('unknown block "' + e + '"');
                                    return this.blocks[e][0]
                                },
                                getSuper: function(e, t, i, r, o, a) {
                                    var s = n.indexOf(this.blocks[t] || [], i),
                                        l = this.blocks[t][s + 1],
                                        c = this;
                                    if (-1 === s || !l) throw new Error('no super block available for "' + t + '"');
                                    l(e, c, r, o, a)
                                },
                                addExport: function(e) {
                                    this.exported.push(e)
                                },
                                getExported: function() {
                                    for (var e = {}, t = 0; t < this.exported.length; t++) {
                                        var n = this.exported[t];
                                        e[n] = this.ctx[n]
                                    }
                                    return e
                                }
                            }),
                            f = i.extend({
                                init: function(e, t, i, r) {
                                    if (this.env = t || new h, n.isObject(e)) switch (e.type) {
                                        case "code":
                                            this.tmplProps = e.obj;
                                            break;
                                        case "string":
                                            this.tmplStr = e.obj
                                    } else {
                                        if (!n.isString(e)) throw new Error("src must be a string or an object describing the source");
                                        this.tmplStr = e
                                    }
                                    this.path = i, r ? n.withPrettyErrors(this.path, this.env.dev, this._compile.bind(this)) : this.compiled = !1
                                },
                                render: function(e, t, i) {
                                    return "function" == typeof e ? (i = e, e = {}) : "function" == typeof t && (i = t, t = null), n.withPrettyErrors(this.path, this.env.dev, function() {
                                        try {
                                            this.compile()
                                        } catch (n) {
                                            if (i) return i(n);
                                            throw n
                                        }
                                        var r = new u(e || {}, this.blocks),
                                            o = null;
                                        return this.rootRenderFunc(this.env, r, t || new c, s, i || function(e, t) {
                                            if (e) throw e;
                                            o = t
                                        }), o
                                    }.bind(this))
                                },
                                getExported: function(e, t, n) {
                                    "function" == typeof e && (n = e, e = {}), "function" == typeof t && (n = t, t = null);
                                    try {
                                        this.compile()
                                    } catch (i) {
                                        if (n) return n(i);
                                        throw i
                                    }
                                    var r = new u(e || {}, this.blocks);
                                    this.rootRenderFunc(this.env, r, t || new c, s, function() {
                                        n(null, r.getExported())
                                    })
                                },
                                compile: function() {
                                    this.compiled || this._compile()
                                },
                                _compile: function() {
                                    var e;
                                    if (this.tmplProps) e = this.tmplProps;
                                    else {
                                        var t = r.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts),
                                            n = new Function(t);
                                        e = n()
                                    }
                                    this.blocks = this._getBlocks(e), this.rootRenderFunc = e.root, this.compiled = !0
                                },
                                _getBlocks: function(e) {
                                    var t = {};
                                    for (var n in e) "b_" === n.slice(0, 2) && (t[n.slice(2)] = e[n]);
                                    return t
                                }
                            });
                        e.environment = {
                            Environment: h,
                            Template: f
                        }
                    }();
                var n, i = e.lib,
                    r = e.environment,
                    o = e.compiler,
                    a = e.parser,
                    s = e.lexer,
                    l = e.runtime,
                    c = e.loader,
                    h = e.loaders,
                    u = e.precompile;
                n = {}, n.Environment = r.Environment, n.Template = r.Template, n.Loader = c, n.FileSystemLoader = h.FileSystemLoader, n.WebLoader = h.WebLoader, n.compiler = o, n.parser = a, n.lexer = s, n.runtime = l;
                var f;
                n.configure = function(e, t) {
                    t = t || {}, i.isObject(e) && (t = e, e = null);
                    var n = "watch" in t ? !t.watch : !1,
                        o = h.FileSystemLoader || h.WebLoader;
                    return f = new r.Environment(new o(e, n), t), t && t.express && f.express(t.express), f
                }, n.compile = function(e, t, i, r) {
                    return f || n.configure(), new n.Template(e, t, i, r)
                }, n.render = function(e, t, i) {
                    return f || n.configure(), f.render(e, t, i)
                }, n.renderString = function(e, t, i) {
                    return f || n.configure(), f.renderString(e, t, i)
                }, u && (n.precompile = u.precompile, n.precompileString = u.precompileString), n.require = function(t) {
                    return e[t]
                }, "function" == typeof define && define.amd ? define(function() {
                    return n
                }) : (window.nunjucks = n, "undefined" != typeof t && (t.exports = n))
            }()
        }, {}
    ],
    7: [
        function(e, t, n) {
            (function() {
                function e(e) {
                    function t(t, n, i, r, o, a) {
                        for (; o >= 0 && a > o; o += e) {
                            var s = r ? r[o] : o;
                            i = n(i, t[s], s, t)
                        }
                        return i
                    }
                    return function(n, i, r, o) {
                        i = _(i, o, 4);
                        var a = !A(n) && w.keys(n),
                            s = (a || n).length,
                            l = e > 0 ? 0 : s - 1;
                        return arguments.length < 3 && (r = n[a ? a[l] : l], l += e), t(n, i, r, a, l, s)
                    }
                }

                function i(e) {
                    return function(t, n, i) {
                        n = b(n, i);
                        for (var r = C(t), o = e > 0 ? 0 : r - 1; o >= 0 && r > o; o += e)
                            if (n(t[o], o, t)) return o;
                        return -1
                    }
                }

                function r(e, t, n) {
                    return function(i, r, o) {
                        var a = 0,
                            s = C(i);
                        if ("number" == typeof o) e > 0 ? a = o >= 0 ? o : Math.max(o + s, a) : s = o >= 0 ? Math.min(o + 1, s) : o + s + 1;
                        else if (n && o && s) return o = n(i, r), i[o] === r ? o : -1;
                        if (r !== r) return o = t(f.call(i, a, s), w.isNaN), o >= 0 ? o + a : -1;
                        for (o = e > 0 ? a : s - 1; o >= 0 && s > o; o += e)
                            if (i[o] === r) return o;
                        return -1
                    }
                }

                function o(e, t) {
                    var n = O.length,
                        i = e.constructor,
                        r = w.isFunction(i) && i.prototype || c,
                        o = "constructor";
                    for (w.has(e, o) && !w.contains(t, o) && t.push(o); n--;) o = O[n], o in e && e[o] !== r[o] && !w.contains(t, o) && t.push(o)
                }
                var a = this,
                    s = a._,
                    l = Array.prototype,
                    c = Object.prototype,
                    h = Function.prototype,
                    u = l.push,
                    f = l.slice,
                    d = c.toString,
                    p = c.hasOwnProperty,
                    m = Array.isArray,
                    v = Object.keys,
                    g = h.bind,
                    y = Object.create,
                    x = function() {},
                    w = function(e) {
                        return e instanceof w ? e : this instanceof w ? void(this._wrapped = e) : new w(e)
                    };
                "undefined" != typeof n ? ("undefined" != typeof t && t.exports && (n = t.exports = w), n._ = w) : a._ = w, w.VERSION = "1.8.3";
                var _ = function(e, t, n) {
                        if (void 0 === t) return e;
                        switch (null == n ? 3 : n) {
                            case 1:
                                return function(n) {
                                    return e.call(t, n)
                                };
                            case 2:
                                return function(n, i) {
                                    return e.call(t, n, i)
                                };
                            case 3:
                                return function(n, i, r) {
                                    return e.call(t, n, i, r)
                                };
                            case 4:
                                return function(n, i, r, o) {
                                    return e.call(t, n, i, r, o)
                                }
                        }
                        return function() {
                            return e.apply(t, arguments)
                        }
                    },
                    b = function(e, t, n) {
                        return null == e ? w.identity : w.isFunction(e) ? _(e, t, n) : w.isObject(e) ? w.matcher(e) : w.property(e)
                    };
                w.iteratee = function(e, t) {
                    return b(e, t, 1 / 0)
                };
                var E = function(e, t) {
                        return function(n) {
                            var i = arguments.length;
                            if (2 > i || null == n) return n;
                            for (var r = 1; i > r; r++)
                                for (var o = arguments[r], a = e(o), s = a.length, l = 0; s > l; l++) {
                                    var c = a[l];
                                    t && void 0 !== n[c] || (n[c] = o[c])
                                }
                            return n
                        }
                    },
                    M = function(e) {
                        if (!w.isObject(e)) return {};
                        if (y) return y(e);
                        x.prototype = e;
                        var t = new x;
                        return x.prototype = null, t
                    },
                    S = function(e) {
                        return function(t) {
                            return null == t ? void 0 : t[e]
                        }
                    },
                    T = Math.pow(2, 53) - 1,
                    C = S("length"),
                    A = function(e) {
                        var t = C(e);
                        return "number" == typeof t && t >= 0 && T >= t
                    };
                w.each = w.forEach = function(e, t, n) {
                    t = _(t, n);
                    var i, r;
                    if (A(e))
                        for (i = 0, r = e.length; r > i; i++) t(e[i], i, e);
                    else {
                        var o = w.keys(e);
                        for (i = 0, r = o.length; r > i; i++) t(e[o[i]], o[i], e)
                    }
                    return e
                }, w.map = w.collect = function(e, t, n) {
                    t = b(t, n);
                    for (var i = !A(e) && w.keys(e), r = (i || e).length, o = Array(r), a = 0; r > a; a++) {
                        var s = i ? i[a] : a;
                        o[a] = t(e[s], s, e)
                    }
                    return o
                }, w.reduce = w.foldl = w.inject = e(1), w.reduceRight = w.foldr = e(-1), w.find = w.detect = function(e, t, n) {
                    var i;
                    return i = A(e) ? w.findIndex(e, t, n) : w.findKey(e, t, n), void 0 !== i && -1 !== i ? e[i] : void 0
                }, w.filter = w.select = function(e, t, n) {
                    var i = [];
                    return t = b(t, n), w.each(e, function(e, n, r) {
                        t(e, n, r) && i.push(e)
                    }), i
                }, w.reject = function(e, t, n) {
                    return w.filter(e, w.negate(b(t)), n)
                }, w.every = w.all = function(e, t, n) {
                    t = b(t, n);
                    for (var i = !A(e) && w.keys(e), r = (i || e).length, o = 0; r > o; o++) {
                        var a = i ? i[o] : o;
                        if (!t(e[a], a, e)) return !1
                    }
                    return !0
                }, w.some = w.any = function(e, t, n) {
                    t = b(t, n);
                    for (var i = !A(e) && w.keys(e), r = (i || e).length, o = 0; r > o; o++) {
                        var a = i ? i[o] : o;
                        if (t(e[a], a, e)) return !0
                    }
                    return !1
                }, w.contains = w.includes = w.include = function(e, t, n, i) {
                    return A(e) || (e = w.values(e)), ("number" != typeof n || i) && (n = 0), w.indexOf(e, t, n) >= 0
                }, w.invoke = function(e, t) {
                    var n = f.call(arguments, 2),
                        i = w.isFunction(t);
                    return w.map(e, function(e) {
                        var r = i ? t : e[t];
                        return null == r ? r : r.apply(e, n)
                    })
                }, w.pluck = function(e, t) {
                    return w.map(e, w.property(t))
                }, w.where = function(e, t) {
                    return w.filter(e, w.matcher(t))
                }, w.findWhere = function(e, t) {
                    return w.find(e, w.matcher(t))
                }, w.max = function(e, t, n) {
                    var i, r, o = -(1 / 0),
                        a = -(1 / 0);
                    if (null == t && null != e) {
                        e = A(e) ? e : w.values(e);
                        for (var s = 0, l = e.length; l > s; s++) i = e[s], i > o && (o = i)
                    } else t = b(t, n), w.each(e, function(e, n, i) {
                        r = t(e, n, i), (r > a || r === -(1 / 0) && o === -(1 / 0)) && (o = e, a = r)
                    });
                    return o
                }, w.min = function(e, t, n) {
                    var i, r, o = 1 / 0,
                        a = 1 / 0;
                    if (null == t && null != e) {
                        e = A(e) ? e : w.values(e);
                        for (var s = 0, l = e.length; l > s; s++) i = e[s], o > i && (o = i)
                    } else t = b(t, n), w.each(e, function(e, n, i) {
                        r = t(e, n, i), (a > r || r === 1 / 0 && o === 1 / 0) && (o = e, a = r)
                    });
                    return o
                }, w.shuffle = function(e) {
                    for (var t, n = A(e) ? e : w.values(e), i = n.length, r = Array(i), o = 0; i > o; o++) t = w.random(0, o), t !== o && (r[o] = r[t]), r[t] = n[o];
                    return r
                }, w.sample = function(e, t, n) {
                    return null == t || n ? (A(e) || (e = w.values(e)), e[w.random(e.length - 1)]) : w.shuffle(e).slice(0, Math.max(0, t))
                }, w.sortBy = function(e, t, n) {
                    return t = b(t, n), w.pluck(w.map(e, function(e, n, i) {
                        return {
                            value: e,
                            index: n,
                            criteria: t(e, n, i)
                        }
                    }).sort(function(e, t) {
                        var n = e.criteria,
                            i = t.criteria;
                        if (n !== i) {
                            if (n > i || void 0 === n) return 1;
                            if (i > n || void 0 === i) return -1
                        }
                        return e.index - t.index
                    }), "value")
                };
                var P = function(e) {
                    return function(t, n, i) {
                        var r = {};
                        return n = b(n, i), w.each(t, function(i, o) {
                            var a = n(i, o, t);
                            e(r, i, a)
                        }), r
                    }
                };
                w.groupBy = P(function(e, t, n) {
                    w.has(e, n) ? e[n].push(t) : e[n] = [t]
                }), w.indexBy = P(function(e, t, n) {
                    e[n] = t
                }), w.countBy = P(function(e, t, n) {
                    w.has(e, n) ? e[n]++ : e[n] = 1
                }), w.toArray = function(e) {
                    return e ? w.isArray(e) ? f.call(e) : A(e) ? w.map(e, w.identity) : w.values(e) : []
                }, w.size = function(e) {
                    return null == e ? 0 : A(e) ? e.length : w.keys(e).length
                }, w.partition = function(e, t, n) {
                    t = b(t, n);
                    var i = [],
                        r = [];
                    return w.each(e, function(e, n, o) {
                        (t(e, n, o) ? i : r).push(e)
                    }), [i, r]
                }, w.first = w.head = w.take = function(e, t, n) {
                    return null != e ? null == t || n ? e[0] : w.initial(e, e.length - t) : void 0
                }, w.initial = function(e, t, n) {
                    return f.call(e, 0, Math.max(0, e.length - (null == t || n ? 1 : t)))
                }, w.last = function(e, t, n) {
                    return null != e ? null == t || n ? e[e.length - 1] : w.rest(e, Math.max(0, e.length - t)) : void 0
                }, w.rest = w.tail = w.drop = function(e, t, n) {
                    return f.call(e, null == t || n ? 1 : t)
                }, w.compact = function(e) {
                    return w.filter(e, w.identity)
                };
                var D = function(e, t, n, i) {
                    for (var r = [], o = 0, a = i || 0, s = C(e); s > a; a++) {
                        var l = e[a];
                        if (A(l) && (w.isArray(l) || w.isArguments(l))) {
                            t || (l = D(l, t, n));
                            var c = 0,
                                h = l.length;
                            for (r.length += h; h > c;) r[o++] = l[c++]
                        } else n || (r[o++] = l)
                    }
                    return r
                };
                w.flatten = function(e, t) {
                    return D(e, t, !1)
                }, w.without = function(e) {
                    return w.difference(e, f.call(arguments, 1))
                }, w.uniq = w.unique = function(e, t, n, i) {
                    w.isBoolean(t) || (i = n, n = t, t = !1), null != n && (n = b(n, i));
                    for (var r = [], o = [], a = 0, s = C(e); s > a; a++) {
                        var l = e[a],
                            c = n ? n(l, a, e) : l;
                        t ? (a && o === c || r.push(l), o = c) : n ? w.contains(o, c) || (o.push(c), r.push(l)) : w.contains(r, l) || r.push(l)
                    }
                    return r
                }, w.union = function() {
                    return w.uniq(D(arguments, !0, !0))
                }, w.intersection = function(e) {
                    for (var t = [], n = arguments.length, i = 0, r = C(e); r > i; i++) {
                        var o = e[i];
                        if (!w.contains(t, o)) {
                            for (var a = 1; n > a && w.contains(arguments[a], o); a++);
                            a === n && t.push(o)
                        }
                    }
                    return t
                }, w.difference = function(e) {
                    var t = D(arguments, !0, !0, 1);
                    return w.filter(e, function(e) {
                        return !w.contains(t, e)
                    })
                }, w.zip = function() {
                    return w.unzip(arguments)
                }, w.unzip = function(e) {
                    for (var t = e && w.max(e, C).length || 0, n = Array(t), i = 0; t > i; i++) n[i] = w.pluck(e, i);
                    return n
                }, w.object = function(e, t) {
                    for (var n = {}, i = 0, r = C(e); r > i; i++) t ? n[e[i]] = t[i] : n[e[i][0]] = e[i][1];
                    return n
                }, w.findIndex = i(1), w.findLastIndex = i(-1), w.sortedIndex = function(e, t, n, i) {
                    n = b(n, i, 1);
                    for (var r = n(t), o = 0, a = C(e); a > o;) {
                        var s = Math.floor((o + a) / 2);
                        n(e[s]) < r ? o = s + 1 : a = s
                    }
                    return o
                }, w.indexOf = r(1, w.findIndex, w.sortedIndex), w.lastIndexOf = r(-1, w.findLastIndex), w.range = function(e, t, n) {
                    null == t && (t = e || 0, e = 0), n = n || 1;
                    for (var i = Math.max(Math.ceil((t - e) / n), 0), r = Array(i), o = 0; i > o; o++, e += n) r[o] = e;
                    return r
                };
                var L = function(e, t, n, i, r) {
                    if (!(i instanceof t)) return e.apply(n, r);
                    var o = M(e.prototype),
                        a = e.apply(o, r);
                    return w.isObject(a) ? a : o
                };
                w.bind = function(e, t) {
                    if (g && e.bind === g) return g.apply(e, f.call(arguments, 1));
                    if (!w.isFunction(e)) throw new TypeError("Bind must be called on a function");
                    var n = f.call(arguments, 2),
                        i = function() {
                            return L(e, i, t, this, n.concat(f.call(arguments)))
                        };
                    return i
                }, w.partial = function(e) {
                    var t = f.call(arguments, 1),
                        n = function() {
                            for (var i = 0, r = t.length, o = Array(r), a = 0; r > a; a++) o[a] = t[a] === w ? arguments[i++] : t[a];
                            for (; i < arguments.length;) o.push(arguments[i++]);
                            return L(e, n, this, this, o)
                        };
                    return n
                }, w.bindAll = function(e) {
                    var t, n, i = arguments.length;
                    if (1 >= i) throw new Error("bindAll must be passed function names");
                    for (t = 1; i > t; t++) n = arguments[t], e[n] = w.bind(e[n], e);
                    return e
                }, w.memoize = function(e, t) {
                    var n = function(i) {
                        var r = n.cache,
                            o = "" + (t ? t.apply(this, arguments) : i);
                        return w.has(r, o) || (r[o] = e.apply(this, arguments)), r[o]
                    };
                    return n.cache = {}, n
                }, w.delay = function(e, t) {
                    var n = f.call(arguments, 2);
                    return setTimeout(function() {
                        return e.apply(null, n)
                    }, t)
                }, w.defer = w.partial(w.delay, w, 1), w.throttle = function(e, t, n) {
                    var i, r, o, a = null,
                        s = 0;
                    n || (n = {});
                    var l = function() {
                        s = n.leading === !1 ? 0 : w.now(), a = null, o = e.apply(i, r), a || (i = r = null)
                    };
                    return function() {
                        var c = w.now();
                        s || n.leading !== !1 || (s = c);
                        var h = t - (c - s);
                        return i = this, r = arguments, 0 >= h || h > t ? (a && (clearTimeout(a), a = null), s = c, o = e.apply(i, r), a || (i = r = null)) : a || n.trailing === !1 || (a = setTimeout(l, h)), o
                    }
                }, w.debounce = function(e, t, n) {
                    var i, r, o, a, s, l = function() {
                        var c = w.now() - a;
                        t > c && c >= 0 ? i = setTimeout(l, t - c) : (i = null, n || (s = e.apply(o, r), i || (o = r = null)))
                    };
                    return function() {
                        o = this, r = arguments, a = w.now();
                        var c = n && !i;
                        return i || (i = setTimeout(l, t)), c && (s = e.apply(o, r), o = r = null), s
                    }
                }, w.wrap = function(e, t) {
                    return w.partial(t, e)
                }, w.negate = function(e) {
                    return function() {
                        return !e.apply(this, arguments)
                    }
                }, w.compose = function() {
                    var e = arguments,
                        t = e.length - 1;
                    return function() {
                        for (var n = t, i = e[t].apply(this, arguments); n--;) i = e[n].call(this, i);
                        return i
                    }
                }, w.after = function(e, t) {
                    return function() {
                        return --e < 1 ? t.apply(this, arguments) : void 0
                    }
                }, w.before = function(e, t) {
                    var n;
                    return function() {
                        return --e > 0 && (n = t.apply(this, arguments)), 1 >= e && (t = null), n
                    }
                }, w.once = w.partial(w.before, 2);
                var R = !{
                        toString: null
                    }.propertyIsEnumerable("toString"),
                    O = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
                w.keys = function(e) {
                    if (!w.isObject(e)) return [];
                    if (v) return v(e);
                    var t = [];
                    for (var n in e) w.has(e, n) && t.push(n);
                    return R && o(e, t), t
                }, w.allKeys = function(e) {
                    if (!w.isObject(e)) return [];
                    var t = [];
                    for (var n in e) t.push(n);
                    return R && o(e, t), t
                }, w.values = function(e) {
                    for (var t = w.keys(e), n = t.length, i = Array(n), r = 0; n > r; r++) i[r] = e[t[r]];
                    return i
                }, w.mapObject = function(e, t, n) {
                    t = b(t, n);
                    for (var i, r = w.keys(e), o = r.length, a = {}, s = 0; o > s; s++) i = r[s], a[i] = t(e[i], i, e);
                    return a
                }, w.pairs = function(e) {
                    for (var t = w.keys(e), n = t.length, i = Array(n), r = 0; n > r; r++) i[r] = [t[r], e[t[r]]];
                    return i
                }, w.invert = function(e) {
                    for (var t = {}, n = w.keys(e), i = 0, r = n.length; r > i; i++) t[e[n[i]]] = n[i];
                    return t
                }, w.functions = w.methods = function(e) {
                    var t = [];
                    for (var n in e) w.isFunction(e[n]) && t.push(n);
                    return t.sort()
                }, w.extend = E(w.allKeys), w.extendOwn = w.assign = E(w.keys), w.findKey = function(e, t, n) {
                    t = b(t, n);
                    for (var i, r = w.keys(e), o = 0, a = r.length; a > o; o++)
                        if (i = r[o], t(e[i], i, e)) return i
                }, w.pick = function(e, t, n) {
                    var i, r, o = {},
                        a = e;
                    if (null == a) return o;
                    w.isFunction(t) ? (r = w.allKeys(a), i = _(t, n)) : (r = D(arguments, !1, !1, 1), i = function(e, t, n) {
                        return t in n
                    }, a = Object(a));
                    for (var s = 0, l = r.length; l > s; s++) {
                        var c = r[s],
                            h = a[c];
                        i(h, c, a) && (o[c] = h)
                    }
                    return o
                }, w.omit = function(e, t, n) {
                    if (w.isFunction(t)) t = w.negate(t);
                    else {
                        var i = w.map(D(arguments, !1, !1, 1), String);
                        t = function(e, t) {
                            return !w.contains(i, t)
                        }
                    }
                    return w.pick(e, t, n)
                }, w.defaults = E(w.allKeys, !0), w.create = function(e, t) {
                    var n = M(e);
                    return t && w.extendOwn(n, t), n
                }, w.clone = function(e) {
                    return w.isObject(e) ? w.isArray(e) ? e.slice() : w.extend({}, e) : e
                }, w.tap = function(e, t) {
                    return t(e), e
                }, w.isMatch = function(e, t) {
                    var n = w.keys(t),
                        i = n.length;
                    if (null == e) return !i;
                    for (var r = Object(e), o = 0; i > o; o++) {
                        var a = n[o];
                        if (t[a] !== r[a] || !(a in r)) return !1
                    }
                    return !0
                };
                var N = function(e, t, n, i) {
                    if (e === t) return 0 !== e || 1 / e === 1 / t;
                    if (null == e || null == t) return e === t;
                    e instanceof w && (e = e._wrapped), t instanceof w && (t = t._wrapped);
                    var r = d.call(e);
                    if (r !== d.call(t)) return !1;
                    switch (r) {
                        case "[object RegExp]":
                        case "[object String]":
                            return "" + e == "" + t;
                        case "[object Number]":
                            return +e !== +e ? +t !== +t : 0 === +e ? 1 / +e === 1 / t : +e === +t;
                        case "[object Date]":
                        case "[object Boolean]":
                            return +e === +t
                    }
                    var o = "[object Array]" === r;
                    if (!o) {
                        if ("object" != typeof e || "object" != typeof t) return !1;
                        var a = e.constructor,
                            s = t.constructor;
                        if (a !== s && !(w.isFunction(a) && a instanceof a && w.isFunction(s) && s instanceof s) && "constructor" in e && "constructor" in t) return !1
                    }
                    n = n || [], i = i || [];
                    for (var l = n.length; l--;)
                        if (n[l] === e) return i[l] === t;
                    if (n.push(e), i.push(t), o) {
                        if (l = e.length, l !== t.length) return !1;
                        for (; l--;)
                            if (!N(e[l], t[l], n, i)) return !1
                    } else {
                        var c, h = w.keys(e);
                        if (l = h.length, w.keys(t).length !== l) return !1;
                        for (; l--;)
                            if (c = h[l], !w.has(t, c) || !N(e[c], t[c], n, i)) return !1
                    }
                    return n.pop(), i.pop(), !0
                };
                w.isEqual = function(e, t) {
                    return N(e, t)
                }, w.isEmpty = function(e) {
                    return null == e ? !0 : A(e) && (w.isArray(e) || w.isString(e) || w.isArguments(e)) ? 0 === e.length : 0 === w.keys(e).length
                }, w.isElement = function(e) {
                    return !(!e || 1 !== e.nodeType)
                }, w.isArray = m || function(e) {
                    return "[object Array]" === d.call(e)
                }, w.isObject = function(e) {
                    var t = typeof e;
                    return "function" === t || "object" === t && !!e
                }, w.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function(e) {
                    w["is" + e] = function(t) {
                        return d.call(t) === "[object " + e + "]"
                    }
                }), w.isArguments(arguments) || (w.isArguments = function(e) {
                    return w.has(e, "callee")
                }), "function" != typeof / . / && "object" != typeof Int8Array && (w.isFunction = function(e) {
                    return "function" == typeof e || !1
                }), w.isFinite = function(e) {
                    return isFinite(e) && !isNaN(parseFloat(e))
                }, w.isNaN = function(e) {
                    return w.isNumber(e) && e !== +e
                }, w.isBoolean = function(e) {
                    return e === !0 || e === !1 || "[object Boolean]" === d.call(e)
                }, w.isNull = function(e) {
                    return null === e
                }, w.isUndefined = function(e) {
                    return void 0 === e
                }, w.has = function(e, t) {
                    return null != e && p.call(e, t)
                }, w.noConflict = function() {
                    return a._ = s, this
                }, w.identity = function(e) {
                    return e
                }, w.constant = function(e) {
                    return function() {
                        return e
                    }
                }, w.noop = function() {}, w.property = S, w.propertyOf = function(e) {
                    return null == e ? function() {} : function(t) {
                        return e[t]
                    }
                }, w.matcher = w.matches = function(e) {
                    return e = w.extendOwn({}, e),
                        function(t) {
                            return w.isMatch(t, e)
                        }
                }, w.times = function(e, t, n) {
                    var i = Array(Math.max(0, e));
                    t = _(t, n, 1);
                    for (var r = 0; e > r; r++) i[r] = t(r);
                    return i
                }, w.random = function(e, t) {
                    return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1))
                }, w.now = Date.now || function() {
                    return (new Date).getTime()
                };
                var U = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#x27;",
                        "`": "&#x60;"
                    },
                    F = w.invert(U),
                    k = function(e) {
                        var t = function(t) {
                                return e[t]
                            },
                            n = "(?:" + w.keys(e).join("|") + ")",
                            i = RegExp(n),
                            r = RegExp(n, "g");
                        return function(e) {
                            return e = null == e ? "" : "" + e, i.test(e) ? e.replace(r, t) : e
                        }
                    };
                w.escape = k(U), w.unescape = k(F), w.result = function(e, t, n) {
                    var i = null == e ? void 0 : e[t];
                    return void 0 === i && (i = n), w.isFunction(i) ? i.call(e) : i
                };
                var H = 0;
                w.uniqueId = function(e) {
                    var t = ++H + "";
                    return e ? e + t : t
                }, w.templateSettings = {
                    evaluate: /<%([\s\S]+?)%>/g,
                    interpolate: /<%=([\s\S]+?)%>/g,
                    escape: /<%-([\s\S]+?)%>/g
                };
                var I = /(.)^/,
                    V = {
                        "'": "'",
                        "\\": "\\",
                        "\r": "r",
                        "\n": "n",
                        "\u2028": "u2028",
                        "\u2029": "u2029"
                    },
                    z = /\\|'|\r|\n|\u2028|\u2029/g,
                    B = function(e) {
                        return "\\" + V[e]
                    };
                w.template = function(e, t, n) {
                    !t && n && (t = n), t = w.defaults({}, t, w.templateSettings);
                    var i = RegExp([(t.escape || I).source, (t.interpolate || I).source, (t.evaluate || I).source].join("|") + "|$", "g"),
                        r = 0,
                        o = "__p+='";
                    e.replace(i, function(t, n, i, a, s) {
                        return o += e.slice(r, s).replace(z, B), r = s + t.length, n ? o += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'" : i ? o += "'+\n((__t=(" + i + "))==null?'':__t)+\n'" : a && (o += "';\n" + a + "\n__p+='"), t
                    }), o += "';\n", t.variable || (o = "with(obj||{}){\n" + o + "}\n"), o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
                    try {
                        var a = new Function(t.variable || "obj", "_", o)
                    } catch (s) {
                        throw s.source = o, s
                    }
                    var l = function(e) {
                            return a.call(this, e, w)
                        },
                        c = t.variable || "obj";
                    return l.source = "function(" + c + "){\n" + o + "}", l
                }, w.chain = function(e) {
                    var t = w(e);
                    return t._chain = !0, t
                };
                var j = function(e, t) {
                    return e._chain ? w(t).chain() : t
                };
                w.mixin = function(e) {
                    w.each(w.functions(e), function(t) {
                        var n = w[t] = e[t];
                        w.prototype[t] = function() {
                            var e = [this._wrapped];
                            return u.apply(e, arguments), j(this, n.apply(w, e))
                        }
                    })
                }, w.mixin(w), w.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(e) {
                    var t = l[e];
                    w.prototype[e] = function() {
                        var n = this._wrapped;
                        return t.apply(n, arguments), "shift" !== e && "splice" !== e || 0 !== n.length || delete n[0], j(this, n)
                    }
                }), w.each(["concat", "join", "slice"], function(e) {
                    var t = l[e];
                    w.prototype[e] = function() {
                        return j(this, t.apply(this._wrapped, arguments))
                    }
                }), w.prototype.value = function() {
                    return this._wrapped
                }, w.prototype.valueOf = w.prototype.toJSON = w.prototype.value, w.prototype.toString = function() {
                    return "" + this._wrapped
                }, "function" == typeof define && define.amd && define("underscore", [], function() {
                    return w
                })
            }).call(this)
        }, {}
    ],
    8: [
        function(e, t, n) {
            function i(e) {
                var t = window.innerWidth,
                    n = window.innerHeight;
                this.scene.setAspectRatio(t / n), this.renderer.setSize(t, n)
            }

            function r(e) {
                68 === e.keyCode && (this.toggleGUIMode(), this.scene.toggleHelpers())
            }
            var o = e("24"),
                a = e("9"),
                s = e("21"),
                l = e("61"),
                c = e("16"),
                h = function(e) {
                    this.scene = e.scene, this.renderer = new THREE.WebGLRenderer({
                        antialias: !0,
                        alpha: !0
                    }), this.clearColor = new THREE.Color(16777215), this.renderer.setClearColor(this.clearColor), this.renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1.5 : 1), this.clock = new THREE.Clock, this.lensFlarePlugin = new l(this.renderer), $(window).resize(i.bind(this)).on("keyup", r.bind(this))
                };
            h.prototype = {
                start: function(e) {
                    var t = e.width(),
                        n = e.height();
                    this.renderer.setSize(t, n), e.append(this.renderer.domElement), this.scene.setAspectRatio(t / n), window.pointer = new THREE.Vector2, $("body").on("mousemove", _.bind(function(e) {
                        window.pointer.x = 2 * (e.clientX / t) - 1, window.pointer.y = 1 - 2 * (e.clientY / n)
                    }, this)), this.scene.setRendererSize(t, n), this.scene.initHelpers(), this.scene.toggleHelpers(), this.toggleGUIMode(), a.FPS && this.initStats(), this.update()
                },
                initStats: function() {
                    var e = new o;
                    e.domElement.style.position = "absolute", e.domElement.style.left = "0px", e.domElement.style.top = "0px", document.body.appendChild(e.domElement), this.stats = e
                },
                showStatusBar: function() {
                    "undefined" != typeof window.StatusBar && (StatusBar.styleDefault(), StatusBar.overlaysWebView(!0), StatusBar.show())
                },
                hideStatusBar: function() {
                    "undefined" != typeof window.StatusBar && StatusBar.hide()
                },
                update: function() {
                    var e = {
                        delta: 0,
                        elapsed: 0
                    };
                    return function() {
                        var t = void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
                        e.delta = this.clock.getDelta(), e.elapsed = this.clock.getElapsedTime(), this.paused || (requestAnimationFrame(this.update.bind(this)), a.FPS && this.stats.begin(), TWEEN.update(t), s.updateTimers(e), this.scene.update(e), this.scene.render(this.renderer, e), this.lensFlarePlugin.render(this.scene, this.scene.camera, this.renderer.domElement.width, this.renderer.domElement.height), a.FPS && this.stats.end())
                    }
                }(),
                pause: function() {
                    this.clock.stop(), this.paused = !0
                },
                resume: function() {
                    this.clock.start(), this.paused = !1, this.update()
                },
                onLeaveTab: function() {
                    this.pause(), c.isMute() || (c.toggleMute(), this.audioShouldResume = !0)
                },
                onFocusTab: function() {
                    this.resume(), this.audioShouldResume && (c.toggleMute(), this.audioShouldResume = !1)
                },
                toggleGUIMode: function() {
                    this.stats && $(this.stats.domElement).toggle()
                },
                setMode: function(e) {
                    TWEEN.Easing.Quadratic.InOut
                }
            }, t.exports = h
        }, {
            16: 16,
            21: 21,
            24: 24,
            61: 61,
            9: 9
        }
    ],
    9: [
        function(e, t, n) {
            var i = {
                FPS: !1,
                AUDIO: !0,
                models: {
                    exterior: "jfc-ext.js",
                    interior: "jfc-int.js",
                    door: "jfc-door.js",
                    tire: "wheels/jfc-tire.js",
                    rim: "wheels/jfc-rim.js",
                    screw: "wheels/jfc-screw.js",
                    logo: "wheels/jfc-logo.js",
                    headlights: "jfc-headlights.js",
                    tunnel: "tunnel.js",
                    camera_auto: "JFC_USP_MS_Parcours_Camera.js",
                    camera_transition: "JFC_Camera_Inter_Exter.js"
                }
            };
            t.exports = i
        }, {}
    ],
    10: [
        function(e, t, n) {
            var i = e("8"),
                r = e("16");
            e("12");
            var o = e("65"),
                a = function(e) {
                    i.call(this, e), this.tweens = {
                        clearColor: new TWEEN.Tween
                    }, this.isHome = !0, this.scene.controls.enablePinch(), this.handleSceneEvents()
                };
            a.inherit(i, {
                start: function() {
                    i.prototype.start.apply(this, arguments), this.initMainView(), window.isMobile || _.defer(function() {
                        r.playMusic()
                    })
                },
                handleSceneEvents: function() {
                    this.scene.addEventListener("showInterior", function() {
                        this.view.showInterior()
                    }.bind(this)), this.scene.addEventListener("showHud", function() {
                        this.view.showHud()
                    }.bind(this)), this.scene.addEventListener("hideInterior", function() {
                        this.view.hideInterior()
                    }.bind(this)), this.scene.controls.addEventListener("move", function() {
                        this.view.onMove()
                    }.bind(this)), this.scene.controls.addEventListener("moveEnd", function() {
                        this.view.onMoveEnd()
                    }.bind(this)), this.scene.addEventListener("changeMode", function(e) {
                        var t = e.mode;
                        this.setMode(e.mode), this.isHome || ("day" === t ? r.setDayMode() : r.setNightMode())
                    }.bind(this))
                },
                initMainView: function() {
                    this.context = {}, this.view = new o({
                        container: $("body"),
                        context: this.context
                    }), this.view.on("toggleLights", function() {
                        this.scene.toggleLights(), "day" === this.scene.mode ? r.setDayMode() : r.setNightMode()
                    }, this), this.view.on("toggleSound", function() {
                        r.toggleMute(), !window.isMobile || r.isMute() || r.musicStarted || r.playMusic()
                    }, this), this.view.on("toggleStartStop", function() {
                        this.scene.toggleCameraMode(), this.scene.toggleCarMoving()
                    }, this), this.view.on("toggleView", function() {
                        this.scene.toggleView()
                    }, this), this.view.on("showInterior", function() {
                        this.scene.toggleView()
                    }, this), this.view.on("hideInterior", function() {
                        this.scene.toggleView()
                    }, this), this.view.on("showHome", function() {
                        this.scene.hideHotspots(), this.scene.controls.horizontalOnly = !0, this.scene.controls.reset(), this.scene.controls.tweenDistance(10), this.scene.controls.lookAt(new THREE.Vector3(0, .15, 0), 800), this.scene.setMode("day"), this.scene.controls.disablePinch(), this.showStatusBar()
                    }, this), this.view.on("showConfigurator", function() {
                        this.scene.showHotspots("exterior"), this.scene.controls.horizontalOnly = !1, this.scene.controls.enablePinch(), this.hideStatusBar()
                    }, this), this.view.on("pause", function() {
                        this.pause(), this.scene.controls.enabled = !1
                    }, this), this.view.on("resume", function() {
                        this.resume(), this.scene.controls.enabled = !0
                    }, this), this.view.showConfigurator()
                },
                update: function() {
                    i.prototype.update.call(this), this.renderer.setClearColor(this.scene.skyColor)
                }
            }), t.exports = a
        }, {
            12: 12,
            16: 16,
            65: 65,
            8: 8
        }
    ],
    11: [
        function(e, t, n) {
            t.exports = {
                exterior: ["jfc-ext.js", 1601554],
                interior: ["jfc-int.js", 2909955],
                door: ["jfc-door.js", 374175],
                tire: ["wheels/jfc-tire.js", 42387],
                rim: ["wheels/jfc-rim.js", 237572],
                screw: ["wheels/jfc-screw.js", 5032],
                logo: ["wheels/jfc-logo.js", 5729],
                headlights: ["jfc-headlights.js", 525905],
                tunnel: ["tunnel.js", 419170],
                camera_auto: ["JFC_USP_MS_Parcours_Camera.js", 361526],
                camera_transition: ["JFC_Camera_Inter_Exter.js", 35082]
            }
        }, {}
    ],
    12: [
        function(e, t, n) {
            ! function() {
                (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["about.html"] = function() {
                    function e(e, t, n, i, r) {
                        var o = null,
                            a = null,
                            s = "";
                        try {
                            s += '<div>\n  <div class="inner">\n    <div class="exit js-exit"></div>\n    <div class="content">\n      <div class="content-inner">\n        <div class="title">3D</div>\n        <div class="description">This is a WebGL car visualizer prototype showcasing the New Renault Espace 2015.<br>\n        <a target="_blank" href="http://www.littleworkshop.fr/espace.html">Read more about this project</a></div>\n        <div class="credits">\n          <div class="credit">\n            <div class="job">Design &amp; Project Lead</div>\n            <div class="name"><a target="_blank" href="http://www.renault.fr">Renault</a></div>\n          </div>\n          <div class="credit">\n            <div class="job">Development</div>\n            <div class="name"><a target="_blank" href="http://www.littleworkshop.fr">Little Workshop</a></div>\n          </div>\n          <div class="credit">\n            <div class="job">Models &amp; Animations</div>\n            <div class="name"><a target="_blank" href="http://www.kylotonngames.com/">Kylotonn Games</a></div>\n          </div>\n          <div class="credit">\n            <div class="job">Source Assets</div>\n            <div class="name"><a target="_blank" href="http://en.lumiscaphe.com/">Lumiscaphe</a></div>\n          </div>\n          <div class="credit">\n            <div class="job">Sound Design</div>\n            <div class="name"><a target="_blank" href="http://www.sixiemeson.com/en/">Sixime Son</a></div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>', r(null, s)
                        } catch (l) {
                            r(i.handleError(l, o, a))
                        }
                    }
                    return {
                        root: e
                    }
                }()
            }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["colors.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div>\n  <div class="exit js-exit"></div>\n  <div class="picker js-scroller">\n      <div class="scroller">\n        <div class="js-color color color-0" data-id="0"><div class="color-name">Black<br> Nacr</div></div>\n        <div class="js-color color color-1" data-id="1"><div class="color-name">Gris<br> Platine</div></div>\n        <div class="js-color color color-2 current" data-id="2"><div class="color-name">Gris<br> Cassiope</div></div>\n        <div class="js-color color color-3" data-id="3"><div class="color-name">Noir<br> toil</div></div>\n        <div class="js-color color color-4" data-id="4"><div class="color-name">Blanc<br> Glacier</div></div>\n        <div class="js-color color color-5" data-id="5"><div class="color-name">Beige<br> Dune</div></div>\n        <div class="js-color color color-6" data-id="6"><div class="color-name">Bleu<br> Cleste</div></div>\n        <div class="js-color color color-7" data-id="7"><div class="color-name">Marron<br> Glac</div></div>\n        <div class="js-color color color-8" data-id="8"><div class="color-name">Noir<br> Amethyste</div></div>\n      </div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["comparator.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="inner">\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["engines.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div>\n    <div class="top"></div>\n    <div class="spinners">\n      <div class="left">\n        <div class="spinner js-spinner"></div>\n        <div class="gradient"></div>\n      </div>\n      <div class="right">\n        <div class="spinner js-spinner"></div>\n        <div class="gradient"></div>\n      </div>\n    </div>\n    <div class="bottom"></div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["finance.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="finance">\n  <div class="title js-title"><span class="js-amount">536,31 </span> x <span class="js-months">84 mth</span></div>\n\n  <div class="slider-container">\n    <div class="slider js-slider slider-3" data-min="10" data-max="2000" data-suffix="">\n      <div class="handle js-handle">\n        <div class="tooltip js-tooltip">536,31 </div>\n      </div>\n      <div class="bar">\n        <div class="fill js-fill"></div>\n      </div>\n    </div>\n    <div class="text">\n      <div class="legend">Monthly amount</div>\n      <div class="value js-max">2.000 / mth</div>\n    </div>\n  </div>\n\n  <div class="slider-container">\n    <div class="slider js-slider slider-3" data-min="1" data-max="120" data-suffix="mth">\n      <div class="handle js-handle">\n        <div class="tooltip js-tooltip">84 mth</div>\n      </div>\n      <div class="bar">\n        <div class="fill js-fill"></div>\n      </div>\n    </div>\n    <div class="text">\n      <div class="legend">Number of months</div>\n      <div class="value js-max">120 mth</div>\n    </div>\n  </div>\n\n  <div class="slider-container">\n    <div class="slider js-slider slider-3" data-min="0" data-max="20000" data-suffix="">\n      <div class="handle js-handle">\n        <div class="tooltip js-tooltip">2.000 </div>\n      </div>\n      <div class="bar">\n        <div class="fill js-fill"></div>\n      </div>\n    </div>\n    <div class="text">\n      <div class="legend">Contribution</div>\n      <div class="value js-max">20.000 </div>\n    </div>\n  </div>\n\n  <div class="bottom"></div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["home.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="home">\n  <div class="inner">\n    <div class="scroller">\n      <div class="block-title"></div>\n      <div class="configure js-configure"></div>\n      <div class="block-content js-content">\n        <div class="tabs"></div>\n        <div class="filters">\n          <div class="choose js-choose"></div>\n          <div class="filters-panel"></div>\n        </div>\n        <div class="range"></div>\n        <div class="comparator"></div>\n      </div>\n    </div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["hud.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div>\n  <div class="main-title">3D <span></span></div>\n  <div class="lights-toggle js-lights-toggle permanent"></div>\n  <div class="sound-toggle js-sound-toggle permanent show-from-interior"></div>\n  <div class="camera-toggle js-camera-toggle permanent"></div>\n  <div class="view-toggle js-view-toggle"></div>\n<!--   <div class="logo day permanent show-from-interior"></div> -->\n  <!-- <div class="logo night permanent show-from-interior"></div> -->\n  <div class="about-block">\n      </div>\n  <!-- <div class="about-toggle js-about-toggle"></div> -->\n  <!-- <div class="share"></div> -->\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["interior.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div>\n  <div class="exit js-exit"></div>\n  <div class="picker js-scroller">\n      <div class="scroller">\n\n      </div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["main.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="main">\n  <div class="js-hud-container hud"></div>\n  <div class="js-interior-container interior"></div>\n  <div class="js-about-container about"></div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["menu.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="menu">\n  <div class="bar"></div>\n  <div class="inner">\n    <div class="menu-main"></div>\n    <div class="signup"></div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["panel.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="panel">\n  <div class="home js-home"></div>\n  <div class="block-nav">\n    <div class="inner">\n      <div class="help"></div>\n    </div>\n  </div>\n  <div class="block-name js-block-name">\n    <div class="inner">\n      <div class="top">\n        <div class="name">Renault <span>ESPACE</span></div>\n        <div class="model">Intens Energy TCe 200 EDC</div>\n        <div class="availability">Available in store <span>1.25 km</span> around your location</div>\n      </div>\n      <div class="bottom">\n        <div>As configured 41 520.00 </div>\n        <div class="monthly-rate js-finance-toggle"><span class="js-finance-title">536.31  per month</span> <div class="arrow"></div></div>\n        <div class="legal-mentions">\n          Credit commitment must be repaid. <br>\n          Check your repayment capacity before commiting.\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class="block-edit">\n    <div class="inner">\n      <div>\n        <div class="title">Build me up!</div>\n        <div class="config-menu">\n          <div class="js-color-toggle color"></div>\n          <div class="js-wheels-toggle wheels"></div>\n          <div class="js-view-toggle interior"></div>\n        </div>\n        <div class="hood js-hood"></div>\n        <div class="actions"></div>\n      </div>\n    </div>\n  </div>\n  <div class="block-finance">\n    <div class="inner">\n      <div class="js-finance-container"></div>\n      <div class="legal js-legal">\n        <div class="scroller">\n            <p>For 41 520  credit, 80 monthly (excluding insurance, excluding service contract) to the fixed APR of 4.99%. Total amount owed by the borrower. Details of your credit: the optional insurance for a vehicle priced at 41 520  with a contribution of 2 000  , a financed amount of 0. Cost of Credit: 0 (of which 0 application fee included in the monthly payment & er). Borrowing rate 0%.</p>\n            <p>For 41 520  credit, 80 monthly (excluding insurance, excluding service contract) to the fixed APR of 4.99%. Total amount owed by the borrower. Details of your credit: the optional insurance for a vehicle priced at 41 520  with a contribution of 2 000  , a financed amount of 0. Cost of Credit: 0 (of which 0 application fee included in the monthly payment & er). Borrowing rate 0%.</p>\n            <p>For 41 520  credit, 80 monthly (excluding insurance, excluding service contract) to the fixed APR of 4.99%. Total amount owed by the borrower. Details of your credit: the optional insurance for a vehicle priced at 41 520  with a contribution of 2 000  , a financed amount of 0. Cost of Credit: 0 (of which 0 application fee included in the monthly payment & er). Borrowing rate 0%.</p>\n            <p>For 41 520  credit, 80 monthly (excluding insurance, excluding service contract) to the fixed APR of 4.99%. Total amount owed by the borrower. Details of your credit: the optional insurance for a vehicle priced at 41 520  with a contribution of 2 000  , a financed amount of 0. Cost of Credit: 0 (of which 0 application fee included in the monthly payment & er). Borrowing rate 0%.</p>\n            <p>For 41 520  credit, 80 monthly (excluding insurance, excluding service contract) to the fixed APR of 4.99%. Total amount owed by the borrower. Details of your credit: the optional insurance for a vehicle priced at 41 520  with a contribution of 2 000  , a financed amount of 0. Cost of Credit: 0 (of which 0 application fee included in the monthly payment & er). Borrowing rate 0%.</p>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["review.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="inner">\n  <div class="exit js-exit"></div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["topbar.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div class="topbar">\n  <div class="burger js-menu-button"></div>\n  <div class="logo"></div>\n  <div class="notifications"></div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }(),
                function() {
                    (window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})["wheels.html"] = function() {
                        function e(e, t, n, i, r) {
                            var o = null,
                                a = null,
                                s = "";
                            try {
                                s += '<div>\n  <div class="exit js-exit"></div>\n  <div class="picker js-scroller">\n      <div class="scroller">\n        <div class="js-wheel wheel wheel-0 current" data-id="0"></div>\n        <div class="js-wheel wheel wheel-1" data-id="1"></div>\n        <div class="js-wheel wheel wheel-2" data-id="2"></div>\n      </div>\n  </div>\n</div>', r(null, s)
                            } catch (l) {
                                r(i.handleError(l, o, a))
                            }
                        }
                        return {
                            root: e
                        }
                    }()
                }()
        }, {}
    ],
    13: [
        function(e, t, n) {
            t.exports = {
                car: [
                    ["envmap/dark/negx-blurry.jpg", 46766],
                    ["envmap/dark/negx.jpg", 47092],
                    ["envmap/dark/negy-blurry.jpg", 4723],
                    ["envmap/dark/negy.jpg", 5722],
                    ["envmap/dark/negz-blurry.jpg", 45543],
                    ["envmap/dark/negz.jpg", 45637],
                    ["envmap/dark/posx-blurry.jpg", 46238],
                    ["envmap/dark/posx.jpg", 47092],
                    ["envmap/dark/posy-blurry.jpg", 22151],
                    ["envmap/dark/posy.jpg", 13622],
                    ["envmap/dark/posz-blurry.jpg", 45849],
                    ["envmap/dark/posz.jpg", 46363],
                    ["envmap/interior/negx.jpg", 51589],
                    ["envmap/interior/negy.jpg", 45672],
                    ["envmap/interior/negz.jpg", 47747],
                    ["envmap/interior/posx.jpg", 49853],
                    ["envmap/interior/posy.jpg", 16261],
                    ["envmap/interior/posz.jpg", 42222],
                    ["envmap/light/negx-blurry.jpg", 21260],
                    ["envmap/light/negx.jpg", 14021],
                    ["envmap/light/negy-blurry.jpg", 4723],
                    ["envmap/light/negy.jpg", 5722],
                    ["envmap/light/negz-blurry.jpg", 20962],
                    ["envmap/light/negz.jpg", 13668],
                    ["envmap/light/posx-blurry.jpg", 22005],
                    ["envmap/light/posx.jpg", 14070],
                    ["envmap/light/posy-blurry.jpg", 22151],
                    ["envmap/light/posy.jpg", 13622],
                    ["envmap/light/posz-blurry.jpg", 21027],
                    ["envmap/light/posz.jpg", 13696],
                    ["exterior/JFC_Body.png", 594238],
                    ["exterior/JFC_Body_EM.png", 24067],
                    ["exterior/JFC_Body_Mask.png", 169126],
                    ["exterior/JFC_Ext_Carrosserie_Mask.png", 71345],
                    ["exterior/frontplate.png", 6255],
                    ["exterior/rearplate.png", 7068],
                    ["flare.png", 118463],
                    ["headlights/JFC_Optic.png", 118484],
                    ["headlights/JFC_Optic_EM.png", 41296],
                    ["headlights/JFC_Optic_EM_2.png", 44694],
                    ["headlights/JFC_Optic_Mask.png", 33559],
                    ["headlights/JFC_Optic_NM.png", 123273],
                    ["headlights/JFC_Optic_SM.png", 46243],
                    ["hotspot.png", 6442],
                    ["interior/JFC_Int_Back.jpg", 109199],
                    ["interior/JFC_Int_Back_EM.png", 4449],
                    ["interior/JFC_Int_Back_Mask.png", 29471],
                    ["interior/JFC_Int_Back_SM.png", 208197],
                    ["interior/JFC_Int_Carrosserie_Mask.png", 21443],
                    ["interior/JFC_Int_Front.jpg", 374649],
                    ["interior/JFC_Int_Front_EM.png", 44556],
                    ["interior/JFC_Int_Front_Mask.png", 48882],
                    ["normalmap/JFC_Body_NM.png", 75880],
                    ["normalmap/JFC_Int_Back_NM.png", 1311425],
                    ["normalmap/JFC_Int_Front_NM.png", 3853352],
                    ["shadow/JFC_Ground_Wheel_AO.png", 9958],
                    ["shadow/car-shadow.png", 31150],
                    ["wheels/int/JFC_Rim_Int.jpg", 4924],
                    ["wheels/int/JFC_Rim_Int_Mask.png", 17871],
                    ["wheels/int/JFC_Rim_Int_NM.png", 19720],
                    ["wheels/rim/JFC_Rim_01.jpg", 43414],
                    ["wheels/rim/JFC_Rim_01_Mask.png", 49496],
                    ["wheels/rim/JFC_Rim_01_NM.png", 342879],
                    ["wheels/tire/JFC_Tire.jpg", 9554],
                    ["wheels/tire/JFC_Tire_NM.png", 67321]
                ],
                env: [
                    ["TARMAC2.jpg", 431627],
                    ["c-glow.png", 4910],
                    ["car-shadow.png", 19081],
                    ["glow.png", 172646],
                    ["ground-lightmap.png", 20944],
                    ["particle.png", 2581],
                    ["pattern.png", 252034],
                    ["pattern_night.png", 162726],
                    ["rearglow.png", 196750],
                    ["vignetting.png", 53713]
                ],
                lensflare: [
                    ["Flare_Pentagone.png", 4117],
                    ["HALO_SOFT_1.png", 12045],
                    ["Halo_Star_Blur.png", 29106],
                    ["lensflare2.png", 2107],
                    ["lensflare3_alpha.png", 3657],
                    ["lensflare_1.png", 33343]
                ]
            }
        }, {}
    ],
    14: [
        function(e, t, n) {
            var i = function(e) {
                THREE.Animation.call(this, e.node, e.data), e.sequences && this.initSequences(e.sequences), this.started = !1, this.ended = !1
            };
            i.inherit(THREE.Animation, {
                initSequences: function(e) {
                    this.sequences = _.object(_.map(e, function(e, t) {
                        var n = {};
                        return n.start = e[0] / this.data.fps, n.end = e[1] / this.data.fps, n.duration = n.end - n.start, [t, n]
                    }, this)), this.currentSequence = _.keys(this.sequences)[0]
                },
                play: function(e) {
                    THREE.Animation.prototype.play.call(this, e), this.started = !0
                },
                playSequence: function(e) {
                    var t = this.currentSequence = this.sequences[e];
                    this.play(t.start), this.ended = !1
                },
                update: function(e) {
                    var t = this.currentSequence;
                    this.ended ? e = 0 : t && this.currentTime > t.end && (this.currentTime = t.end, this.ended = !0), THREE.Animation.prototype.update.call(this, e)
                }
            }), t.exports = i
        }, {}
    ],
    15: [
        function(e, t, n) {
            function i(e, t, n) {
                var i = new jQuery.Deferred;
                return h.addEventListener("fileload", function() {
                    f[e] = {
                        instance: h.createInstance(e),
                        defaultVolume: n
                    }, i.resolve()
                }.bind(this)), h.registerSound(t, e), i.promise()
            }

            function r() {
                try {
                    var e = $.when.apply(null, _.map(p, function(e, t) {
                        return i(t, p[t])
                    }))
                } catch (t) {
                    console.error(t)
                }
                return e
            }

            function o() {
                try {
                    var e = $.when.apply(null, _.map(d, function(e, t) {
                        return i(t, d[t], .3)
                    }))
                } catch (t) {
                    console.error(t)
                }
                return e
            }

            function a(e, t, n, i) {
                var r = l(e);
                n = n || r.defaultVolume, c.tween(t).onUpdate(function(e) {
                    var t = e * n;
                    r.instance.volume = i ? n - t : t
                })
            }

            function s(e, t) {
                l(e).instance.volume = t
            }

            function l(e) {
                if (!u) throw new Error("Audio assets have not finished loading.");
                if (void 0 === e) throw new Error("id is undefined");
                return f[e]
            }
            var c = e("21"),
                h = e("23");
            h.alternateExtensions = ["mp3"];
            var u = !1,
                f = {},
                d = {
                    exterior: "audio/loops/base.mp3",
                    interior: "audio/loops/base-interior.mp3",
                    top: "audio/loops/top.mp3"
                },
                p = {
                    engine: "audio/sfx/engine.mp3",
                    opendoor: "audio/sfx/opendoor.mp3",
                    closedoor: "audio/sfx/closedoor.mp3",
                    spot: "audio/sfx/spot.mp3",
                    day: "audio/sfx/day.mp3",
                    night: "audio/sfx/night.mp3",
                    woosh: "audio/sfx/woosh.mp3"
                },
                m = {
                    mute: !1,
                    load: function() {
                        return $.when(r(), o()).done(function() {
                            u = !0
                        })
                    },
                    play: function(e) {
                        var t = l(e);
                        t.instance.play({
                            volume: t.defaultVolume,
                            pan: 1e-4
                        })
                    },
                    loop: function(e) {
                        var t = l(e);
                        t.instance.play({
                            volume: t.defaultVolume,
                            loop: -1,
                            pan: 1e-4
                        })
                    },
                    stop: function(e) {
                        var t = l(e);
                        t.instance.stop()
                    },
                    fadeIn: function(e, t, n) {
                        a(e, t, n)
                    },
                    fadeOut: function(e, t, n) {
                        a(e, t, n, !0)
                    },
                    setVolume: function(e, t) {
                        s(e, t)
                    },
                    toggleMute: function() {
                        this.mute = !this.mute, h.setMute(this.mute)
                    }
                };
            t.exports = m
        }, {
            21: 21,
            23: 23
        }
    ],
    16: [
        function(e, t, n) {
            var i = e("15"),
                r = e("21"),
                o = {
                    musicStarted: !1,
                    toggleMute: function() {
                        i.toggleMute()
                    },
                    isMute: function() {
                        return i.mute
                    },
                    preloadAll: function() {
                        return i.load()
                    },
                    playMusic: function() {
                        this.musicStarted = !0, i.loop("exterior"), i.loop("interior"), i.fadeIn("exterior", 4e3), i.setVolume("interior", 0)
                    },
                    enterCar: function() {
                        i.fadeIn("interior", 500), i.fadeOut("exterior", 500)
                    },
                    exitCar: function() {
                        i.fadeIn("exterior", 500), i.fadeOut("interior", 500)
                    },
                    startCar: function() {
                        i.fadeOut("exterior", 1e3), i.play("engine"), r.delay(1500, function() {
                            i.setVolume("top", .6), i.loop("top")
                        })
                    },
                    stopCar: function() {
                        i.fadeOut("top", 2e3), i.fadeIn("exterior", 4e3), r.delay(2e3, function() {
                            i.stop("top")
                        })
                    },
                    openDoor: function() {
                        i.play("opendoor"), r.delay(3200, function() {
                            i.play("closedoor")
                        })
                    },
                    setDayMode: function() {
                        i.play("day")
                    },
                    setNightMode: function() {
                        i.play("night")
                    },
                    takePicture: function() {
                        i.play("save")
                    },
                    spotLight: function() {
                        i.play("spot")
                    },
                    moveCamera: function() {
                        i.play("woosh")
                    }
                };
            t.exports = o
        }, {
            15: 15,
            21: 21
        }
    ],
    17: [
        function(e, t, n) {
            var i = [12633286, 9869980, 6250851, 0, 14278111, 8223348, 8033437, 3617584, 1970978];
            t.exports = i
        }, {}
    ],
    18: [
        function(e, t, n) {
            var i = function(e) {
                THREE.EventDispatcher.call(this), this.camera = e.camera, this.objects = [], $("body").on("tap", this.onTap.bind(this))
            };
            i.inherit(THREE.EventDispatcher, {
                add: function(e) {
                    this.objects.push(e)
                },
                remove: function(e) {
                    for (var t = 0; t < this.objects.length; t++) {
                        var n = this.objects[t].id;
                        if (n === e.id) {
                            this.objects.splice(t, 1);
                            break
                        }
                    }
                },
                clear: function() {
                    this.objects = []
                },
                onTap: function(e) {
                    var t = 2 * (e.pageX / window.WIDTH) - 1,
                        n = 1 - 2 * (e.pageY / window.HEIGHT),
                        i = this.hitTest(t, n);
                    i && this.dispatchEvent({
                        type: "pick",
                        object: i
                    })
                },
                hitTest: function(e, t) {
                    var n = new THREE.Vector3(e, t, 1),
                        i = n.unproject(this.camera),
                        r = new THREE.Raycaster(this.camera.position, i.sub(this.camera.position).normalize()),
                        o = r.intersectObjects(this.objects);
                    if (o.length > 0) {
                        var a = o[0].object;
                        if (void 0 === a.pickable || void 0 !== a.pickable && a.pickable) return o[0].object
                    }
                    return null
                },
                update: function(e) {
                    var t = this.hitTest(window.mouseX, window.mouseY);
                    t ? document.body.style.cursor = "pointer" : document.body.style.cursor = "auto"
                }
            }), t.exports = i
        }, {}
    ],
    19: [
        function(e, t, n) {
            function i(e, t, n) {
                return e + (t - e) * n
            }

            function r(e, t, n) {
                var r, o;
                if (e > t) {
                    var a = t + s - e,
                        l = e - t;
                    a > l ? (r = e, o = t) : (r = e, o = t + s)
                } else {
                    var a = t - e,
                        l = e + s - t;
                    a > l ? (r = e + s, o = t) : (r = e, o = t)
                }
                return i(r, o, n) % s
            }
            var o = e("21"),
                a = e("3"),
                s = 2 * Math.PI,
                l = function(e) {
                    THREE.EventDispatcher.call(this), this.enabled = !0, this.camera = e.camera, this.$container = $("body"), this.mouse = new THREE.Vector2, this.mouseOnDown = new THREE.Vector2, this.rotation = new THREE.Vector2, this.target = new THREE.Vector2, this.targetOnDown = new THREE.Vector2, this.distance = e.distance || 8, this.originalDistance = this.distance, this.lookAtTarget = new THREE.Vector3, this.dampFactor = e.damp || 1e3, this.origin = e.origin || new THREE.Vector3(0, 0, 0), this.clampY = e.clampY || Math.PI, this.reverse = void 0 !== e.reverse ? e.reverse : !1, this.fixedDistance = void 0 !== e.fixedDistance ? e.fixedDistance : !1, this.horizontalOnly = !1, this.setupEvents(), this.zoomSpeed = .5, this.zoomEnabled = void 0 !== e.zoom ? e.zoom : !0, this.hammer = new a($("body")[0]), this.hammer.get("pinch").set({
                        enable: !1
                    }), this.maxDistance = e.maxDistance || 10, this.minDistance = e.minDistance || 4, this.hammer.on("pinchstart", function(e) {
                        var t = this.distance;
                        this.hammer.on("pinchmove", function(e) {
                            this.distance = t / e.scale, this.distance = this.distance > this.maxDistance ? this.maxDistance : this.distance, this.distance = this.distance < this.minDistance ? this.minDistance : this.distance
                        }.bind(this))
                    }.bind(this)), this.autoRotate = !1, this.autoRotationSpeed = -.002, this.locked = !1, this.lockRotation = new THREE.Vector2, this.tweens = {
                        rotation: new TWEEN.Tween,
                        target: new TWEEN.Tween,
                        distance: new TWEEN.Tween
                    }
                };
            l.inherit(THREE.EventDispatcher, {
                enablePinch: function() {
                    this.hammer.get("pinch").set({
                        enable: !0
                    })
                },
                disablePinch: function() {
                    this.hammer.get("pinch").set({
                        enable: !1
                    })
                },
                setupEvents: function() {
                    this.$container.on("mouseover", function() {
                        this.overRenderer = !0
                    }, !1), this.$container.on("mouseout", function() {
                        this.overRenderer = !1
                    }, !1), this.$container.on("mousedown.orbit touchstart.orbit", _.bind(function(e) {
                        this.enabled && ($("body").on("mousemove.orbit touchmove.orbit", _.bind(this.onMove, this)), $("body").on("mouseup touchend", _.bind(this.onMoveEnd, this)), this.$container.on("mouseout", _.bind(this.onMouseOut, this)), "touchstart" === e.type ? (this.mouseOnDown.x = e.originalEvent.touches[0].clientX, this.mouseOnDown.y = -e.originalEvent.touches[0].clientY) : (this.mouseOnDown.x = e.clientX, this.mouseOnDown.y = -e.clientY), this.reverse && (this.mouseOnDown.y *= -1), this.targetOnDown.copy(this.target))
                    }, this)), this.$container.on("mousewheel MozMousePixelScroll", _.bind(function(e) {
                        if (this.enabled && this.zoomEnabled) {
                            e.preventDefault();
                            var t = e.originalEvent.deltaY ? .025 * -e.originalEvent.deltaY : .025 * -e.originalEvent.detail;
                            this.zoom(t)
                        }
                    }, this))
                },
                onMove: function(e) {
                    var t = new THREE.Vector2;
                    return function(e) {
                        if (this.horizontalOnly || e.preventDefault(), this.autoRotate && (this.autoRotate = !1, this.autoRotateNeedsResume = !0), this.autoRotateTimer && this.autoRotateTimer.stop(), !("touchmove" === e.type && e.originalEvent.touches.length > 1)) {
                            "touchmove" === e.type ? (this.mouse.x = e.originalEvent.touches[0].clientX, this.mouse.y = -e.originalEvent.touches[0].clientY) : (this.mouse.x = e.clientX, this.mouse.y = -e.clientY), this.reverse && (this.mouse.y *= -1);
                            var n = this.distance / this.dampFactor;
                            t.subVectors(this.mouse, this.mouseOnDown).multiplyScalar(n), this.target.addVectors(this.targetOnDown, t), this.dispatchEvent({
                                type: "move"
                            })
                        }
                    }
                }(),
                onMoveEnd: function() {
                    $("body").off("mousemove.orbit touchmove mouseup touchend"), this.$container.off("mouseout"), this.autoRotateNeedsResume && (this.autoRotateTimer = o.delay(2e3, function() {
                        this.autoRotate = !0
                    }, this)), this.locked && this.setTargetRotation(this.lockRotation), this.dispatchEvent({
                        type: "moveEnd"
                    })
                },
                onMouseOut: function() {
                    $("body").off("mousemove.orbit"), this.$container.off("mouseout")
                },
                zoom: function(e) {
                    this.zoomEnabled && (this.distance -= e, this.distance = this.distance > this.maxDistance ? this.maxDistance : this.distance, this.distance = this.distance < this.minDistance ? this.minDistance : this.distance)
                },
                setRotation: function(e) {
                    this.rotation.copy(e), this.setTargetRotation(e)
                },
                setTargetRotation: function(e) {
                    this.target.copy(e)
                },
                start: function(e, t) {
                    this.started || (this.enabled = "phone" !== window.mode, this.started = !0)
                },
                orbitTo: function() {
                    var e = new THREE.Vector3,
                        t = new THREE.Vector3(0, 0, 0),
                        n = new THREE.Vector3(1, 0, 0),
                        a = new THREE.Vector3(0, 1, 0),
                        l = new THREE.Vector3;
                    return function(c, h, u) {
                        var f = new $.Deferred;
                        u = void 0 !== u ? u : TWEEN.Easing.Quartic.Out, e.subVectors(c, this.origin).normalize();
                        var d = (new THREE.Vector2).copy(this.rotation),
                            p = a.angleTo(e);
                        l.crossVectors(a, e).normalize(), e.applyAxisAngle(l, Math.PI / 2 - p);
                        var m = n.angleTo(e);
                        e.z < 0 && (m = s - m);
                        var v = {
                            x: m,
                            y: p
                        };
                        if (h > 0) {
                            var g = new THREE.Vector2;
                            o.tween(h, u).onUpdate(function(e) {
                                g.x = r(d.x, v.x, e), g.y = i(d.y, v.y, e), this.setRotation(g)
                            }.bind(this)).onComplete(function() {
                                f.resolve()
                            }), this.fixedDistance || this.tweens.distance.reset(this).to({
                                distance: c.distanceTo(t)
                            }, h).easing(u).start()
                        } else this.setRotation(v), this.fixedDistance || (this.distance = c.distanceTo(t));
                        return f.promise()
                    }
                }(),
                lookAt: function(e, t) {
                    this.tweens.target.reset(this.origin).to({
                        x: e.x,
                        y: e.y,
                        z: e.z
                    }, t).easing(TWEEN.Easing.Quartic.Out).start()
                },
                lock: function() {
                    this.locked = !0, this.lockRotation.copy(this.rotation), this.dampFactor *= 8
                },
                unlock: function() {
                    this.locked = !1, this.dampFactor /= 8
                },
                reset: function() {
                    this.resetting = !0,
                        o.delay(1e3, function() {
                            this.resetting = !1
                        }, this)
                },
                tweenDistance: function(e) {
                    var t = this.distance,
                        n = e - t;
                    o.tween(1200, TWEEN.Easing.Quartic.Out).onUpdate(function(e) {
                        this.distance = t + e * n
                    }.bind(this))
                },
                update: function(e) {
                    this.autoRotate && (this.target.x += this.autoRotationSpeed), this.target.x > s ? this.target.x -= s : this.target.x < 0 && (this.target.x = s + this.target.x), this.target.y = THREE.Math.clamp(this.target.y, 0, this.clampY), this.horizontalOnly && (this.target.y = 1.5), this.resetting && (this.target.x = .9828, this.target.y = 1.5), this.rotation.x = r(this.rotation.x, this.target.x, .1), this.rotation.y = i(this.rotation.y, this.target.y, .1);
                    var t = this.rotation.x,
                        n = this.rotation.y,
                        o = Math.sin(n);
                    if (this.camera.position.x = Math.cos(t) * o, this.camera.position.y = Math.cos(n), this.camera.position.z = Math.sin(t) * o, this.camera.position.setLength(this.distance), this.reverse) {
                        var a = (new THREE.Vector3).copy(this.camera.position).setLength(.1);
                        this.lookAtTarget.copy(this.camera.position).add(a).add(this.origin), this.camera.position.add(this.origin)
                    } else this.camera.position.add(this.origin), this.lookAtTarget.copy(this.origin);
                    this.camera.lookAt(this.lookAtTarget)
                }
            }), t.exports = l
        }, {
            21: 21,
            3: 3
        }
    ],
    20: [
        function(e, t, n) {
            var i = function(e) {
                e = _.extend({}, {
                    duration: 1e3,
                    repeat: !1,
                    onStart: function() {},
                    onEnd: function() {}
                }, e), this.duration = e.duration, this.repeat = e.repeat, this.startCallback = e.onStart, this.endCallback = e.onEnd, this.reset()
            };
            i.inherit(Object, {
                reset: function() {
                    return this.started = !1, this.paused = !1, this.ended = !1, this.elapsedTime = 0, this
                },
                start: function() {
                    return this.started || this.ended ? this : (this.started = !0, this.startCallback(), this)
                },
                stop: function() {
                    return this.started ? this.reset() : this
                },
                pause: function() {
                    return this.paused = !0, this
                },
                resume: function() {
                    return this.paused = !1, this
                },
                update: function(e) {
                    return !this.started || this.paused || this.ended ? this : (this.elapsedTime += 1e3 * e.delta, this.elapsedTime > this.duration && (this.endCallback(), this.ended = !0), this)
                }
            }), t.exports = i
        }, {}
    ],
    21: [
        function(e, t, n) {
            function i(e) {
                var t = e[0],
                    n = e[1];
                m[t] = n, v += n
            }

            function r(e, t) {
                e.forEach(function(e) {
                    i([t + "/" + e[0], e[1]])
                })
            }

            function o() {
                _.each(y, function(e) {
                    e(g)
                })
            }

            function a(e) {
                g += m[e] / v, o()
            }
            var s = e("11"),
                l = e("13"),
                c = e("20"),
                h = {
                    _timers: {}
                },
                u = e("9").models,
                f = {},
                d = {},
                p = {},
                m = {},
                v = 0,
                g = 0,
                y = [];
            h.onLoadingProgress = function(e) {
                y.push(e)
            }, h.load = function(e) {
                var t = e.models,
                    n = e.textureBundles,
                    o = [];
                return m = {}, v = 0, g = 0, t && (_.each(s, function(e, n) {
                    _.include(t, n) && i(e)
                }), o.push(h.loadMeshes(t))), n && (_.each(l, function(e, t) {
                    _.include(n, t) && r(e, t)
                }), o.push(h.loadTextureBundles(e.textureBundles))), o
            }, h.loadMesh = function(e) {
                if (!_.has(u, e)) throw "Unknown mesh id: " + e;
                if (_.has(f, e)) return (new $.Deferred).resolve(f[e]).promise();
                var t = u[e];
                return $.ajax({
                    url: "models/" + t,
                    dataType: "text"
                }).pipe(function(n) {
                    return f[e] = n, a(t), n
                })
            }, h.loadMeshes = function(e) {
                return $.when.apply($, _.map(e, h.loadMesh))
            }, h.loadAllMeshes = function() {
                return h.loadMeshes(_.keys(u))
            }, h.parseMeshData = function(e) {
                if (!_.has(f, e)) throw "No JSON found for id: " + e;
                var t, n = new THREE.JSONLoader,
                    i = JSON.parse(f[e]),
                    r = n.parse(i, "./textures/");
                t = r.materials.length > 1 ? new THREE.MeshFaceMaterial(r.materials) : r.materials[0], d[e] = {
                    geometry: r.geometry,
                    material: t
                }
            }, h.getMeshData = function(e) {
                return _.has(d, e) || h.parseMeshData(e), d[e]
            }, h.loadTexture = function(e) {
                var t = new $.Deferred;
                return _.has(p, e) ? t.resolve(p[e]) : THREE.ImageUtils.loadTexture("textures/" + e, THREE.UVMapping, function(n) {
                    p[e] = n, a(e), t.resolve(n)
                }), t.promise()
            }, h.loadTextures = function(e) {
                return $.when.apply($, _.map(e, h.loadTexture))
            }, h.loadTextureBundle = function(e) {
                if (!_.has(l, e)) throw "Unknown bundle: " + e;
                var t = l[e].map(function(t) {
                    return e + "/" + t[0]
                });
                return h.loadTextures(t)
            }, h.loadTextureBundles = function(e) {
                return $.when.apply($, _.map(e, h.loadTextureBundle))
            }, h.loadAllTextures = function() {
                return h.loadTextureBundles(_.keys(l))
            }, h.getTexture = function(e) {
                if (!_.has(p, e)) throw "Texture not found: " + e;
                return p[e]
            }, h.getTextureCube = function(e, t) {
                var n = new THREE.CubeTexture(t.map(function(t) {
                    var n = e.endsWith("/") ? e + t : e + "/" + t;
                    return h.getTexture(n).image
                }));
                return n.format = THREE.RGBFormat, n.flipY = !1, n.needsUpdate = !0, n
            }, h.loadMeshTextures = function(e) {
                var t = _.find(e, function(e) {
                    return !_.has(u, e)
                });
                if (t) throw "Unknown mesh id: " + t;
                var n = _.uniq(_.map(e, function(e) {
                    return u[e].texture
                }));
                return h.loadTextures(n)
            }, h.getMeshTexture = function(e) {
                if (!_.has(u, e)) throw "Unknown mesh id: " + e;
                return h.getTexture(u[e].texture)
            }, h.getRandomInt = function(e, t) {
                return Math.floor(Math.random() * (t - e)) + e
            }, h.getRandomFloat = function(e, t) {
                return Math.random() * (t - e) + e
            }, h.getRandomFromArray = function(e) {
                return e[Math.floor(Math.random() * e.length)]
            }, h.pad = function(e, t, n) {
                return n = n || "0", e += "", e.length >= t ? e : new Array(t - e.length + 1).join(n) + e
            }, h.delay = function(e, t, n) {
                var i = _.uniqueId("timer_"),
                    r = new c({
                        duration: e,
                        onEnd: function() {
                            t.call(n), delete h._timers[i]
                        }
                    }).start();
                return h._timers[i] = r, r
            }, h.repeat = function(e, t, n, i) {
                h.delay(t, function() {
                    n.call(i), e > 1 && h.repeat(e - 1, t, n, i)
                }, i)
            }, h.updateTimers = function(e) {
                _.each(h._timers, function(t) {
                    t.update(e)
                })
            }, h.tween = function(e, t) {
                var n = new TWEEN.Tween({
                    progress: 0
                });
                return n.to({
                    progress: 1
                }, e).easing(void 0 !== t ? t : TWEEN.Easing.Linear.None).start(), n
            }, h.parseBones = function(e, t) {
                var n, i = [];
                if (e && void 0 !== e.bones) {
                    for (var r, o, a, s, l, c = 0, h = e.bones.length; h > c; ++c) o = e.bones[c], a = o.pos, s = o.rotq, l = o.scl, r = t ? new THREE.Object3D : new THREE.Bone(this), i.push(r), r.name = o.name, r.position.set(a[0], a[1], a[2]), r.quaternion.set(s[0], s[1], s[2], s[3]), void 0 !== l ? r.scale.set(l[0], l[1], l[2]) : r.scale.set(1, 1, 1);
                    for (var c = 0, h = e.bones.length; h > c; ++c) o = e.bones[c], -1 !== o.parent ? i[o.parent].add(i[c]) : n = i[c]
                }
                return n
            }, h.createDebugCube = function(e) {
                var t = new THREE.BoxGeometry(e, e, e),
                    n = new THREE.MeshBasicMaterial({
                        color: 16711935,
                        wireframe: !0,
                        depthTest: !1
                    }),
                    i = new THREE.Mesh(t, n);
                return i
            }, t.exports = h
        }, {
            11: 11,
            13: 13,
            20: 20,
            9: 9
        }
    ],
    22: [
        function(e, t, n) {
            (function(n) {
                jQuery = n.jQuery = e("4");
                (function(e, t, n) {
                    ! function(e, t) {
                        "use strict";
                        var n, i, r, o = "._tap",
                            a = "._tapActive",
                            s = "tap",
                            l = "clientX clientY screenX screenY pageX pageY".split(" "),
                            c = {
                                count: 0,
                                event: 0
                            },
                            h = function(e, n) {
                                var i = n.originalEvent,
                                    r = t.Event(i);
                                r.type = e;
                                for (var o = 0, a = l.length; a > o; o++) r[l[o]] = n[l[o]];
                                return r
                            },
                            u = function(e) {
                                if (e.isTrigger) return !1;
                                var n = c.event,
                                    i = Math.abs(e.pageX - n.pageX),
                                    r = Math.abs(e.pageY - n.pageY),
                                    o = Math.max(i, r);
                                return e.timeStamp - n.timeStamp < t.tap.TIME_DELTA && o < t.tap.POSITION_DELTA && (!n.touches || 1 === c.count) && p.isTracking
                            },
                            f = function(e) {
                                if (!r) return !1;
                                var n = Math.abs(e.pageX - r.pageX),
                                    i = Math.abs(e.pageY - r.pageY),
                                    o = Math.max(n, i);
                                return Math.abs(e.timeStamp - r.timeStamp) < 750 && o < t.tap.POSITION_DELTA
                            },
                            d = function(e) {
                                if (0 === e.type.indexOf("touch")) {
                                    e.touches = e.originalEvent.changedTouches;
                                    for (var t = e.touches[0], n = 0, i = l.length; i > n; n++) e[l[n]] = t[l[n]]
                                }
                                e.timeStamp = Date.now ? Date.now() : +new Date
                            },
                            p = {
                                isEnabled: !1,
                                isTracking: !1,
                                enable: function() {
                                    p.isEnabled || (p.isEnabled = !0, n = t(e.body).on("touchstart" + o, p.onStart).on("mousedown" + o, p.onStart).on("click" + o, p.onClick))
                                },
                                disable: function() {
                                    p.isEnabled && (p.isEnabled = !1, n.off(o))
                                },
                                onStart: function(e) {
                                    e.isTrigger || (d(e), t.tap.LEFT_BUTTON_ONLY && !e.touches && 1 !== e.which || (e.touches && (c.count = e.touches.length), p.isTracking || !e.touches && f(e) || (p.isTracking = !0, c.event = e, e.touches ? (r = e, n.on("touchend" + o + a, p.onEnd).on("touchcancel" + o + a, p.onCancel)) : n.on("mouseup" + o + a, p.onEnd))))
                                },
                                onEnd: function(e) {
                                    var n;
                                    e.isTrigger || (d(e), u(e) && (n = h(s, e), i = n, t(c.event.target).trigger(n)), p.onCancel(e))
                                },
                                onCancel: function(e) {
                                    e && "touchcancel" === e.type && e.preventDefault(), p.isTracking = !1, n.off(a)
                                },
                                onClick: function(e) {
                                    return !e.isTrigger && i && i.isDefaultPrevented() && i.target === e.target && i.pageX === e.pageX && i.pageY === e.pageY && e.timeStamp - i.timeStamp < 750 ? (i = null, !1) : void 0
                                }
                            };
                        t(e).ready(p.enable), t.tap = {
                            POSITION_DELTA: 10,
                            TIME_DELTA: 400,
                            LEFT_BUTTON_ONLY: !0
                        }
                    }(document, jQuery)
                }).call(n, t, void 0, void 0)
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {
            4: 4
        }
    ],
    23: [
        function(e, t, n) {
            window.createjs = window.createjs || {},
                function() {
                    var e = createjs.SoundJS = createjs.SoundJS || {};
                    e.version = "NEXT", e.buildDate = "Tue, 19 May 2015 17:26:59 GMT"
                }(), this.createjs = this.createjs || {}, createjs.extend = function(e, t) {
                "use strict";

                function n() {
                    this.constructor = e
                }
                return n.prototype = t.prototype, e.prototype = new n
            }, this.createjs = this.createjs || {}, createjs.promote = function(e, t) {
                "use strict";
                var n = e.prototype,
                    i = Object.getPrototypeOf && Object.getPrototypeOf(n) || n.__proto__;
                if (i) {
                    n[(t += "_") + "constructor"] = i.constructor;
                    for (var r in i) n.hasOwnProperty(r) && "function" == typeof i[r] && (n[t + r] = i[r])
                }
                return e
            }, this.createjs = this.createjs || {}, createjs.indexOf = function(e, t) {
                "use strict";
                for (var n = 0, i = e.length; i > n; n++)
                    if (t === e[n]) return n;
                return -1
            }, this.createjs = this.createjs || {},
                function() {
                    "use strict";
                    createjs.proxy = function(e, t) {
                        var n = Array.prototype.slice.call(arguments, 2);
                        return function() {
                            return e.apply(t, Array.prototype.slice.call(arguments, 0).concat(n))
                        }
                    }
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        throw "BrowserDetect cannot be instantiated"
                    }
                    var t = e.agent = window.navigator.userAgent;
                    e.isWindowPhone = t.indexOf("IEMobile") > -1 || t.indexOf("Windows Phone") > -1, e.isFirefox = t.indexOf("Firefox") > -1, e.isOpera = null != window.opera, e.isChrome = t.indexOf("Chrome") > -1, e.isIOS = (t.indexOf("iPod") > -1 || t.indexOf("iPhone") > -1 || t.indexOf("iPad") > -1) && !e.isWindowPhone, e.isAndroid = t.indexOf("Android") > -1 && !e.isWindowPhone, e.isBlackberry = t.indexOf("Blackberry") > -1, createjs.BrowserDetect = e
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        this._listeners = null, this._captureListeners = null
                    }
                    var t = e.prototype;
                    e.initialize = function(e) {
                        e.addEventListener = t.addEventListener, e.on = t.on, e.removeEventListener = e.off = t.removeEventListener, e.removeAllEventListeners = t.removeAllEventListeners, e.hasEventListener = t.hasEventListener, e.dispatchEvent = t.dispatchEvent, e._dispatchEvent = t._dispatchEvent, e.willTrigger = t.willTrigger
                    }, t.addEventListener = function(e, t, n) {
                        var i;
                        i = n ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {};
                        var r = i[e];
                        return r && this.removeEventListener(e, t, n), r = i[e], r ? r.push(t) : i[e] = [t], t
                    }, t.on = function(e, t, n, i, r, o) {
                        return t.handleEvent && (n = n || t, t = t.handleEvent), n = n || this, this.addEventListener(e, function(e) {
                            t.call(n, e, r), i && e.remove()
                        }, o)
                    }, t.removeEventListener = function(e, t, n) {
                        var i = n ? this._captureListeners : this._listeners;
                        if (i) {
                            var r = i[e];
                            if (r)
                                for (var o = 0, a = r.length; a > o; o++)
                                    if (r[o] == t) {
                                        1 == a ? delete i[e] : r.splice(o, 1);
                                        break
                                    }
                        }
                    }, t.off = t.removeEventListener, t.removeAllEventListeners = function(e) {
                        e ? (this._listeners && delete this._listeners[e], this._captureListeners && delete this._captureListeners[e]) : this._listeners = this._captureListeners = null
                    }, t.dispatchEvent = function(e) {
                        if ("string" == typeof e) {
                            var t = this._listeners;
                            if (!t || !t[e]) return !1;
                            e = new createjs.Event(e)
                        } else e.target && e.clone && (e = e.clone());
                        try {
                            e.target = this
                        } catch (n) {}
                        if (e.bubbles && this.parent) {
                            for (var i = this, r = [i]; i.parent;) r.push(i = i.parent);
                            var o, a = r.length;
                            for (o = a - 1; o >= 0 && !e.propagationStopped; o--) r[o]._dispatchEvent(e, 1 + (0 == o));
                            for (o = 1; a > o && !e.propagationStopped; o++) r[o]._dispatchEvent(e, 3)
                        } else this._dispatchEvent(e, 2);
                        return e.defaultPrevented
                    }, t.hasEventListener = function(e) {
                        var t = this._listeners,
                            n = this._captureListeners;
                        return !!(t && t[e] || n && n[e])
                    }, t.willTrigger = function(e) {
                        for (var t = this; t;) {
                            if (t.hasEventListener(e)) return !0;
                            t = t.parent
                        }
                        return !1
                    }, t.toString = function() {
                        return "[EventDispatcher]"
                    }, t._dispatchEvent = function(e, t) {
                        var n, i = 1 == t ? this._captureListeners : this._listeners;
                        if (e && i) {
                            var r = i[e.type];
                            if (!r || !(n = r.length)) return;
                            try {
                                e.currentTarget = this
                            } catch (o) {}
                            try {
                                e.eventPhase = t
                            } catch (o) {}
                            e.removed = !1, r = r.slice();
                            for (var a = 0; n > a && !e.immediatePropagationStopped; a++) {
                                var s = r[a];
                                s.handleEvent ? s.handleEvent(e) : s(e), e.removed && (this.off(e.type, s, 1 == t), e.removed = !1)
                            }
                        }
                    }, createjs.EventDispatcher = e
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.type = e, this.target = null, this.currentTarget = null, this.eventPhase = 0, this.bubbles = !!t, this.cancelable = !!n, this.timeStamp = (new Date).getTime(), this.defaultPrevented = !1, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.removed = !1
                    }
                    var t = e.prototype;
                    t.preventDefault = function() {
                        this.defaultPrevented = this.cancelable && !0
                    }, t.stopPropagation = function() {
                        this.propagationStopped = !0
                    }, t.stopImmediatePropagation = function() {
                        this.immediatePropagationStopped = this.propagationStopped = !0
                    }, t.remove = function() {
                        this.removed = !0
                    }, t.clone = function() {
                        return new e(this.type, this.bubbles, this.cancelable)
                    }, t.set = function(e) {
                        for (var t in e) this[t] = e[t];
                        return this
                    }, t.toString = function() {
                        return "[Event (type=" + this.type + ")]"
                    }, createjs.Event = e
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.Event_constructor("error"), this.title = e, this.message = t, this.data = n
                    }
                    var t = createjs.extend(e, createjs.Event);
                    t.clone = function() {
                        return new createjs.ErrorEvent(this.title, this.message, this.data)
                    }, createjs.ErrorEvent = createjs.promote(e, "Event")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t) {
                        this.Event_constructor("progress"), this.loaded = e, this.total = null == t ? 1 : t, this.progress = 0 == t ? 0 : this.loaded / this.total
                    }
                    var t = createjs.extend(e, createjs.Event);
                    t.clone = function() {
                        return new createjs.ProgressEvent(this.loaded, this.total)
                    }, createjs.ProgressEvent = createjs.promote(e, "Event")
                }(window), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        this.src = null, this.type = null, this.id = null, this.maintainOrder = !1, this.callback = null, this.data = null, this.method = createjs.LoadItem.GET, this.values = null, this.headers = null, this.withCredentials = !1, this.mimeType = null, this.crossOrigin = null, this.loadTimeout = n.LOAD_TIMEOUT_DEFAULT
                    }
                    var t = e.prototype = {},
                        n = e;
                    n.LOAD_TIMEOUT_DEFAULT = 8e3, n.create = function(t) {
                        if ("string" == typeof t) {
                            var i = new e;
                            return i.src = t, i
                        }
                        if (t instanceof n) return t;
                        if (t instanceof Object && t.src) return null == t.loadTimeout && (t.loadTimeout = n.LOAD_TIMEOUT_DEFAULT), t;
                        throw new Error("Type not recognized.")
                    }, t.set = function(e) {
                        for (var t in e) this[t] = e[t];
                        return this
                    }, createjs.LoadItem = n
                }(),
                function() {
                    var e = {};
                    e.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i, e.RELATIVE_PATT = /^[.\/]*?\//i, e.EXTENSION_PATT = /\/?[^\/]+\.(\w{1,5})$/i, e.parseURI = function(t) {
                        var n = {
                            absolute: !1,
                            relative: !1
                        };
                        if (null == t) return n;
                        var i = t.indexOf("?");
                        i > -1 && (t = t.substr(0, i));
                        var r;
                        return e.ABSOLUTE_PATT.test(t) ? n.absolute = !0 : e.RELATIVE_PATT.test(t) && (n.relative = !0), (r = t.match(e.EXTENSION_PATT)) && (n.extension = r[1].toLowerCase()), n
                    }, e.formatQueryString = function(e, t) {
                        if (null == e) throw new Error("You must specify data.");
                        var n = [];
                        for (var i in e) n.push(i + "=" + escape(e[i]));
                        return t && (n = n.concat(t)), n.join("&")
                    }, e.buildPath = function(e, t) {
                        if (null == t) return e;
                        var n = [],
                            i = e.indexOf("?");
                        if (-1 != i) {
                            var r = e.slice(i + 1);
                            n = n.concat(r.split("&"))
                        }
                        return -1 != i ? e.slice(0, i) + "?" + this._formatQueryString(t, n) : e + "?" + this._formatQueryString(t, n)
                    }, e.isCrossDomain = function(e) {
                        var t = document.createElement("a");
                        t.href = e.src;
                        var n = document.createElement("a");
                        n.href = location.href;
                        var i = "" != t.hostname && (t.port != n.port || t.protocol != n.protocol || t.hostname != n.hostname);
                        return i
                    }, e.isLocal = function(e) {
                        var t = document.createElement("a");
                        return t.href = e.src, "" == t.hostname && "file:" == t.protocol
                    }, e.isBinary = function(e) {
                        switch (e) {
                            case createjs.AbstractLoader.IMAGE:
                            case createjs.AbstractLoader.BINARY:
                                return !0;
                            default:
                                return !1
                        }
                    }, e.isImageTag = function(e) {
                        return e instanceof HTMLImageElement
                    }, e.isAudioTag = function(e) {
                        return window.HTMLAudioElement ? e instanceof HTMLAudioElement : !1
                    }, e.isVideoTag = function(e) {
                        return window.HTMLVideoElement ? e instanceof HTMLVideoElement : !1
                    }, e.isText = function(e) {
                        switch (e) {
                            case createjs.AbstractLoader.TEXT:
                            case createjs.AbstractLoader.JSON:
                            case createjs.AbstractLoader.MANIFEST:
                            case createjs.AbstractLoader.XML:
                            case createjs.AbstractLoader.CSS:
                            case createjs.AbstractLoader.SVG:
                            case createjs.AbstractLoader.JAVASCRIPT:
                            case createjs.AbstractLoader.SPRITESHEET:
                                return !0;
                            default:
                                return !1
                        }
                    }, e.getTypeByExtension = function(e) {
                        if (null == e) return createjs.AbstractLoader.TEXT;
                        switch (e.toLowerCase()) {
                            case "jpeg":
                            case "jpg":
                            case "gif":
                            case "png":
                            case "webp":
                            case "bmp":
                                return createjs.AbstractLoader.IMAGE;
                            case "ogg":
                            case "mp3":
                            case "webm":
                                return createjs.AbstractLoader.SOUND;
                            case "mp4":
                            case "webm":
                            case "ts":
                                return createjs.AbstractLoader.VIDEO;
                            case "json":
                                return createjs.AbstractLoader.JSON;
                            case "xml":
                                return createjs.AbstractLoader.XML;
                            case "css":
                                return createjs.AbstractLoader.CSS;
                            case "js":
                                return createjs.AbstractLoader.JAVASCRIPT;
                            case "svg":
                                return createjs.AbstractLoader.SVG;
                            default:
                                return createjs.AbstractLoader.TEXT
                        }
                    }, createjs.RequestUtils = e
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.EventDispatcher_constructor(), this.loaded = !1, this.canceled = !1, this.progress = 0, this.type = n, this.resultFormatter = null, this._item = e ? createjs.LoadItem.create(e) : null, this._preferXHR = t, this._result = null, this._rawResult = null, this._loadedItems = null, this._tagSrcAttribute = null, this._tag = null
                    }
                    var t = createjs.extend(e, createjs.EventDispatcher),
                        n = e;
                    n.POST = "POST", n.GET = "GET", n.BINARY = "binary", n.CSS = "css", n.IMAGE = "image", n.JAVASCRIPT = "javascript", n.JSON = "json", n.JSONP = "jsonp", n.MANIFEST = "manifest", n.SOUND = "sound", n.VIDEO = "video", n.SPRITESHEET = "spritesheet", n.SVG = "svg", n.TEXT = "text", n.XML = "xml", t.getItem = function() {
                        return this._item
                    }, t.getResult = function(e) {
                        return e ? this._rawResult : this._result
                    }, t.getTag = function() {
                        return this._tag
                    }, t.setTag = function(e) {
                        this._tag = e
                    }, t.load = function() {
                        this._createRequest(), this._request.on("complete", this, this), this._request.on("progress", this, this), this._request.on("loadStart", this, this), this._request.on("abort", this, this), this._request.on("timeout", this, this), this._request.on("error", this, this);
                        var e = new createjs.Event("initialize");
                        e.loader = this._request, this.dispatchEvent(e), this._request.load()
                    }, t.cancel = function() {
                        this.canceled = !0, this.destroy()
                    }, t.destroy = function() {
                        this._request && (this._request.removeAllEventListeners(), this._request.destroy()), this._request = null, this._item = null, this._rawResult = null, this._result = null, this._loadItems = null, this.removeAllEventListeners()
                    }, t.getLoadedItems = function() {
                        return this._loadedItems
                    }, t._createRequest = function() {
                        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute)
                    }, t._createTag = function() {
                        return null
                    }, t._sendLoadStart = function() {
                        this._isCanceled() || this.dispatchEvent("loadstart")
                    }, t._sendProgress = function(e) {
                        if (!this._isCanceled()) {
                            var t = null;
                            "number" == typeof e ? (this.progress = e, t = new createjs.ProgressEvent(this.progress)) : (t = e, this.progress = e.loaded / e.total, t.progress = this.progress, (isNaN(this.progress) || 1 / 0 == this.progress) && (this.progress = 0)), this.hasEventListener("progress") && this.dispatchEvent(t)
                        }
                    }, t._sendComplete = function() {
                        if (!this._isCanceled()) {
                            this.loaded = !0;
                            var e = new createjs.Event("complete");
                            e.rawResult = this._rawResult, null != this._result && (e.result = this._result), this.dispatchEvent(e)
                        }
                    }, t._sendError = function(e) {
                        !this._isCanceled() && this.hasEventListener("error") && (null == e && (e = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")), this.dispatchEvent(e))
                    }, t._isCanceled = function() {
                        return !(null != window.createjs && !this.canceled)
                    }, t.resultFormatter = null, t.handleEvent = function(e) {
                        switch (e.type) {
                            case "complete":
                                this._rawResult = e.target._response;
                                var t = this.resultFormatter && this.resultFormatter(this),
                                    n = this;
                                t instanceof Function ? t(function(e) {
                                    n._result = e, n._sendComplete()
                                }) : (this._result = t || this._rawResult, this._sendComplete());
                                break;
                            case "progress":
                                this._sendProgress(e);
                                break;
                            case "error":
                                this._sendError(e);
                                break;
                            case "loadstart":
                                this._sendLoadStart();
                                break;
                            case "abort":
                            case "timeout":
                                this._isCanceled() || this.dispatchEvent(e.type)
                        }
                    }, t.buildPath = function(e, t) {
                        return createjs.RequestUtils.buildPath(e, t)
                    }, t.toString = function() {
                        return "[PreloadJS AbstractLoader]"
                    }, createjs.AbstractLoader = createjs.promote(e, "EventDispatcher")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.AbstractLoader_constructor(e, t, n), this.resultFormatter = this._formatResult, this._tagSrcAttribute = "src"
                    }
                    var t = createjs.extend(e, createjs.AbstractLoader);
                    t.load = function() {
                        this._tag || (this._tag = this._createTag(this._item.src)), this._tag.preload = "auto", this._tag.load(), this.AbstractLoader_load()
                    }, t._createTag = function() {}, t._createRequest = function() {
                        this._request = this._preferXHR ? new createjs.XHRRequest(this._item) : new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute)
                    }, t._formatResult = function(e) {
                        return this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), this._tag.onstalled = null, this._preferXHR && (e.getTag().src = e.getResult(!0)), e.getTag()
                    }, createjs.AbstractMediaLoader = createjs.promote(e, "AbstractLoader")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";
                    var e = function(e) {
                            this._item = e
                        },
                        t = createjs.extend(e, createjs.EventDispatcher);
                    t.load = function() {}, t.destroy = function() {}, t.cancel = function() {}, createjs.AbstractRequest = createjs.promote(e, "EventDispatcher")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.AbstractRequest_constructor(e), this._tag = t, this._tagSrcAttribute = n, this._loadedHandler = createjs.proxy(this._handleTagComplete, this), this._addedToDOM = !1, this._startTagVisibility = null
                    }
                    var t = createjs.extend(e, createjs.AbstractRequest);
                    t.load = function() {
                        this._tag.onload = createjs.proxy(this._handleTagComplete, this), this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this), this._tag.onerror = createjs.proxy(this._handleError, this);
                        var e = new createjs.Event("initialize");
                        e.loader = this._tag, this.dispatchEvent(e), this._hideTag(), this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout), this._tag[this._tagSrcAttribute] = this._item.src, null == this._tag.parentNode && (window.document.body.appendChild(this._tag), this._addedToDOM = !0)
                    }, t.destroy = function() {
                        this._clean(), this._tag = null, this.AbstractRequest_destroy()
                    }, t._handleReadyStateChange = function() {
                        clearTimeout(this._loadTimeout);
                        var e = this._tag;
                        ("loaded" == e.readyState || "complete" == e.readyState) && this._handleTagComplete()
                    }, t._handleError = function() {
                        this._clean(), this.dispatchEvent("error")
                    }, t._handleTagComplete = function() {
                        this._rawResult = this._tag, this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult, this._clean(), this._showTag(), this.dispatchEvent("complete")
                    }, t._handleTimeout = function() {
                        this._clean(), this.dispatchEvent(new createjs.Event("timeout"))
                    }, t._clean = function() {
                        this._tag.onload = null, this._tag.onreadystatechange = null, this._tag.onerror = null, this._addedToDOM && null != this._tag.parentNode && this._tag.parentNode.removeChild(this._tag), clearTimeout(this._loadTimeout)
                    }, t._hideTag = function() {
                        this._startTagVisibility = this._tag.style.visibility, this._tag.style.visibility = "hidden"
                    }, t._showTag = function() {
                        this._tag.style.visibility = this._startTagVisibility
                    }, t._handleStalled = function() {}, createjs.TagRequest = createjs.promote(e, "AbstractRequest")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n) {
                        this.AbstractRequest_constructor(e), this._tag = t, this._tagSrcAttribute = n, this._loadedHandler = createjs.proxy(this._handleTagComplete, this)
                    }
                    var t = createjs.extend(e, createjs.TagRequest);
                    t.load = function() {
                        var e = createjs.proxy(this._handleStalled, this);
                        this._stalledCallback = e;
                        var t = createjs.proxy(this._handleProgress, this);
                        this._handleProgress = t, this._tag.addEventListener("stalled", e), this._tag.addEventListener("progress", t), this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, !1), this.TagRequest_load()
                    }, t._handleReadyStateChange = function() {
                        clearTimeout(this._loadTimeout);
                        var e = this._tag;
                        ("loaded" == e.readyState || "complete" == e.readyState) && this._handleTagComplete()
                    }, t._handleStalled = function() {}, t._handleProgress = function(e) {
                        if (e && !(e.loaded > 0 && 0 == e.total)) {
                            var t = new createjs.ProgressEvent(e.loaded, e.total);
                            this.dispatchEvent(t)
                        }
                    }, t._clean = function() {
                        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler), this._tag.removeEventListener("stalled", this._stalledCallback), this._tag.removeEventListener("progress", this._progressCallback), this.TagRequest__clean()
                    }, createjs.MediaTagRequest = createjs.promote(e, "TagRequest")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e) {
                        this.AbstractRequest_constructor(e), this._request = null, this._loadTimeout = null, this._xhrLevel = 1, this._response = null, this._rawResponse = null, this._canceled = !1, this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this), this._handleProgressProxy = createjs.proxy(this._handleProgress, this), this._handleAbortProxy = createjs.proxy(this._handleAbort, this), this._handleErrorProxy = createjs.proxy(this._handleError, this), this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this), this._handleLoadProxy = createjs.proxy(this._handleLoad, this), this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this), !this._createXHR(e)
                    }
                    var t = createjs.extend(e, createjs.AbstractRequest);
                    e.ACTIVEX_VERSIONS = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], t.getResult = function(e) {
                        return e && this._rawResponse ? this._rawResponse : this._response
                    }, t.cancel = function() {
                        this.canceled = !0, this._clean(), this._request.abort()
                    }, t.load = function() {
                        if (null == this._request) return void this._handleError();
                        this._request.addEventListener("loadstart", this._handleLoadStartProxy, !1), this._request.addEventListener("progress", this._handleProgressProxy, !1), this._request.addEventListener("abort", this._handleAbortProxy, !1), this._request.addEventListener("error", this._handleErrorProxy, !1), this._request.addEventListener("timeout", this._handleTimeoutProxy, !1), this._request.addEventListener("load", this._handleLoadProxy, !1), this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, !1), 1 == this._xhrLevel && (this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout));
                        try {
                            this._item.values && this._item.method != createjs.AbstractLoader.GET ? this._item.method == createjs.AbstractLoader.POST && this._request.send(createjs.RequestUtils.formatQueryString(this._item.values)) : this._request.send()
                        } catch (e) {
                            this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, e))
                        }
                    }, t.setResponseType = function(e) {
                        this._request.responseType = e
                    }, t.getAllResponseHeaders = function() {
                        return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null
                    }, t.getResponseHeader = function(e) {
                        return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(e) : null
                    }, t._handleProgress = function(e) {
                        if (e && !(e.loaded > 0 && 0 == e.total)) {
                            var t = new createjs.ProgressEvent(e.loaded, e.total);
                            this.dispatchEvent(t)
                        }
                    }, t._handleLoadStart = function() {
                        clearTimeout(this._loadTimeout), this.dispatchEvent("loadstart")
                    }, t._handleAbort = function(e) {
                        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, e))
                    }, t._handleError = function(e) {
                        this._clean(), this.dispatchEvent(new createjs.ErrorEvent(e.message))
                    }, t._handleReadyStateChange = function() {
                        4 == this._request.readyState && this._handleLoad()
                    }, t._handleLoad = function() {
                        if (!this.loaded) {
                            this.loaded = !0;
                            var e = this._checkError();
                            if (e) return void this._handleError(e);
                            this._response = this._getResponse(), this._clean(), this.dispatchEvent(new createjs.Event("complete"))
                        }
                    }, t._handleTimeout = function(e) {
                        this._clean(), this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, e))
                    }, t._checkError = function() {
                        var e = parseInt(this._request.status);
                        switch (e) {
                            case 404:
                            case 0:
                                return new Error(e)
                        }
                        return null
                    }, t._getResponse = function() {
                        if (null != this._response) return this._response;
                        if (null != this._request.response) return this._request.response;
                        try {
                            if (null != this._request.responseText) return this._request.responseText
                        } catch (e) {}
                        try {
                            if (null != this._request.responseXML) return this._request.responseXML
                        } catch (e) {}
                        return null
                    }, t._createXHR = function(e) {
                        var t = createjs.RequestUtils.isCrossDomain(e),
                            n = {},
                            i = null;
                        if (window.XMLHttpRequest) i = new XMLHttpRequest, t && void 0 === i.withCredentials && window.XDomainRequest && (i = new XDomainRequest);
                        else {
                            for (var r = 0, o = s.ACTIVEX_VERSIONS.length; o > r; r++) {
                                s.ACTIVEX_VERSIONS[r];
                                try {
                                    i = new ActiveXObject(axVersions);
                                    break
                                } catch (a) {}
                            }
                            if (null == i) return !1
                        }
                        null == e.mimeType && createjs.RequestUtils.isText(e.type) && (e.mimeType = "text/plain; charset=utf-8"), e.mimeType && i.overrideMimeType && i.overrideMimeType(e.mimeType), this._xhrLevel = "string" == typeof i.responseType ? 2 : 1;
                        var l = null;
                        if (l = e.method == createjs.AbstractLoader.GET ? createjs.RequestUtils.buildPath(e.src, e.values) : e.src, i.open(e.method || createjs.AbstractLoader.GET, l, !0), t && i instanceof XMLHttpRequest && 1 == this._xhrLevel && (n.Origin = location.origin), e.values && e.method == createjs.AbstractLoader.POST && (n["Content-Type"] = "application/x-www-form-urlencoded"), t || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest"), e.headers)
                            for (var c in e.headers) n[c] = e.headers[c];
                        for (c in n) i.setRequestHeader(c, n[c]);
                        return i instanceof XMLHttpRequest && void 0 !== e.withCredentials && (i.withCredentials = e.withCredentials), this._request = i, !0
                    }, t._clean = function() {
                        clearTimeout(this._loadTimeout), this._request.removeEventListener("loadstart", this._handleLoadStartProxy), this._request.removeEventListener("progress", this._handleProgressProxy), this._request.removeEventListener("abort", this._handleAbortProxy), this._request.removeEventListener("error", this._handleErrorProxy), this._request.removeEventListener("timeout", this._handleTimeoutProxy), this._request.removeEventListener("load", this._handleLoadProxy), this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy)
                    }, t.toString = function() {
                        return "[PreloadJS XHRRequest]"
                    }, createjs.XHRRequest = createjs.promote(e, "AbstractRequest")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t) {
                        this.AbstractMediaLoader_constructor(e, t, createjs.AbstractLoader.SOUND), createjs.RequestUtils.isAudioTag(e) ? this._tag = e : createjs.RequestUtils.isAudioTag(e.src) ? this._tag = e : createjs.RequestUtils.isAudioTag(e.tag) && (this._tag = createjs.RequestUtils.isAudioTag(e) ? e : e.src), null != this._tag && (this._preferXHR = !1)
                    }
                    var t = createjs.extend(e, createjs.AbstractMediaLoader),
                        n = e;
                    n.canLoadItem = function(e) {
                        return e.type == createjs.AbstractLoader.SOUND
                    }, t._createTag = function(e) {
                        var t = document.createElement("audio");
                        return t.autoplay = !1, t.preload = "none", t.src = e, t
                    }, createjs.SoundLoader = createjs.promote(e, "AbstractMediaLoader")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";
                    var e = function() {
                            this.interrupt = null, this.delay = null, this.offset = null, this.loop = null, this.volume = null, this.pan = null, this.startTime = null, this.duration = null
                        },
                        t = e.prototype = {},
                        n = e;
                    n.create = function(e) {
                        if (e instanceof n || e instanceof Object) {
                            var t = new createjs.PlayPropsConfig;
                            return t.set(e), t
                        }
                        throw new Error("Type not recognized.")
                    }, t.set = function(e) {
                        for (var t in e) this[t] = e[t];
                        return this
                    }, t.toString = function() {
                        return "[PlayPropsConfig]"
                    }, createjs.PlayPropsConfig = n
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        throw "Sound cannot be instantiated"
                    }

                    function t(e, t) {
                        this.init(e, t)
                    }
                    var n = e;
                    n.INTERRUPT_ANY = "any", n.INTERRUPT_EARLY = "early", n.INTERRUPT_LATE = "late", n.INTERRUPT_NONE = "none", n.PLAY_INITED = "playInited", n.PLAY_SUCCEEDED = "playSucceeded", n.PLAY_INTERRUPTED = "playInterrupted", n.PLAY_FINISHED = "playFinished", n.PLAY_FAILED = "playFailed", n.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"], n.EXTENSION_MAP = {
                        m4a: "mp4"
                    }, n.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([\/.]*?(?:[^?]+)?\/)?((?:[^\/?]+)\.(\w+))(?:\?(\S+)?)?$/, n.defaultInterruptBehavior = n.INTERRUPT_NONE, n.alternateExtensions = [], n.activePlugin = null, n._masterVolume = 1, Object.defineProperty(n, "volume", {
                        get: function() {
                            return this._masterVolume
                        },
                        set: function(e) {
                            if (null == Number(e)) return !1;
                            if (e = Math.max(0, Math.min(1, e)), n._masterVolume = e, !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(e))
                                for (var t = this._instances, i = 0, r = t.length; r > i; i++) t[i].setMasterVolume(e)
                        }
                    }), n._masterMute = !1,
                        Object.defineProperty(n, "muted", {
                            get: function() {
                                return this._masterMute
                            },
                            set: function(e) {
                                if (null == e) return !1;
                                if (this._masterMute = e, !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(e))
                                    for (var t = this._instances, n = 0, i = t.length; i > n; n++) t[n].setMasterMute(e);
                                return !0
                            }
                        }), Object.defineProperty(n, "capabilities", {
                        get: function() {
                            return null == n.activePlugin ? null : n.activePlugin._capabilities
                        },
                        set: function() {
                            return !1
                        }
                    }), n._pluginsRegistered = !1, n._lastID = 0, n._instances = [], n._idHash = {}, n._preloadHash = {}, n._defaultPlayPropsHash = {}, n.addEventListener = null, n.removeEventListener = null, n.removeAllEventListeners = null, n.dispatchEvent = null, n.hasEventListener = null, n._listeners = null, createjs.EventDispatcher.initialize(n), n.getPreloadHandlers = function() {
                        return {
                            callback: createjs.proxy(n.initLoad, n),
                            types: ["sound"],
                            extensions: n.SUPPORTED_EXTENSIONS
                        }
                    }, n._handleLoadComplete = function(e) {
                        var t = e.target.getItem().src;
                        if (n._preloadHash[t])
                            for (var i = 0, r = n._preloadHash[t].length; r > i; i++) {
                                var o = n._preloadHash[t][i];
                                if (n._preloadHash[t][i] = !0, n.hasEventListener("fileload")) {
                                    var e = new createjs.Event("fileload");
                                    e.src = o.src, e.id = o.id, e.data = o.data, e.sprite = o.sprite, n.dispatchEvent(e)
                                }
                            }
                    }, n._handleLoadError = function(e) {
                        var t = e.target.getItem().src;
                        if (n._preloadHash[t])
                            for (var i = 0, r = n._preloadHash[t].length; r > i; i++) {
                                var o = n._preloadHash[t][i];
                                if (n._preloadHash[t][i] = !1, n.hasEventListener("fileerror")) {
                                    var e = new createjs.Event("fileerror");
                                    e.src = o.src, e.id = o.id, e.data = o.data, e.sprite = o.sprite, n.dispatchEvent(e)
                                }
                            }
                    }, n._registerPlugin = function(e) {
                        return e.isSupported() ? (n.activePlugin = new e, !0) : !1
                    }, n.registerPlugins = function(e) {
                        n._pluginsRegistered = !0;
                        for (var t = 0, i = e.length; i > t; t++)
                            if (n._registerPlugin(e[t])) return !0;
                        return !1
                    }, n.initializeDefaultPlugins = function() {
                        return null != n.activePlugin ? !0 : n._pluginsRegistered ? !1 : !!n.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])
                    }, n.isReady = function() {
                        return null != n.activePlugin
                    }, n.getCapabilities = function() {
                        return null == n.activePlugin ? null : n.activePlugin._capabilities
                    }, n.getCapability = function(e) {
                        return null == n.activePlugin ? null : n.activePlugin._capabilities[e]
                    }, n.initLoad = function(e) {
                        return n._registerSound(e)
                    }, n._registerSound = function(e) {
                        if (!n.initializeDefaultPlugins()) return !1;
                        var i;
                        if (e.src instanceof Object ? (i = n._parseSrc(e.src), i.src = e.path + i.src) : i = n._parsePath(e.src), null == i) return !1;
                        e.src = i.src, e.type = "sound";
                        var r = e.data,
                            o = null;
                        if (null != r && (isNaN(r.channels) ? isNaN(r) || (o = parseInt(r)) : o = parseInt(r.channels), r.audioSprite))
                            for (var a, s = r.audioSprite.length; s--;) a = r.audioSprite[s], n._idHash[a.id] = {
                                src: e.src,
                                startTime: parseInt(a.startTime),
                                duration: parseInt(a.duration)
                            }, a.defaultPlayProps && (n._defaultPlayPropsHash[a.id] = createjs.PlayPropsConfig.create(a.defaultPlayProps));
                        null != e.id && (n._idHash[e.id] = {
                            src: e.src
                        });
                        var l = n.activePlugin.register(e);
                        return t.create(e.src, o), null != r && isNaN(r) ? e.data.channels = o || t.maxPerChannel() : e.data = o || t.maxPerChannel(), l.type && (e.type = l.type), e.defaultPlayProps && (n._defaultPlayPropsHash[e.src] = createjs.PlayPropsConfig.create(e.defaultPlayProps)), l
                    }, n.registerSound = function(e, t, i, r, o) {
                        var a = {
                            src: e,
                            id: t,
                            data: i,
                            defaultPlayProps: o
                        };
                        e instanceof Object && e.src && (r = t, a = e), a = createjs.LoadItem.create(a), a.path = r, null == r || a.src instanceof Object || (a.src = r + e);
                        var s = n._registerSound(a);
                        if (!s) return !1;
                        if (n._preloadHash[a.src] || (n._preloadHash[a.src] = []), n._preloadHash[a.src].push(a), 1 == n._preloadHash[a.src].length) s.on("complete", createjs.proxy(this._handleLoadComplete, this)), s.on("error", createjs.proxy(this._handleLoadError, this)), n.activePlugin.preload(s);
                        else if (1 == n._preloadHash[a.src][0]) return !0;
                        return a
                    }, n.registerSounds = function(e, t) {
                        var n = [];
                        e.path && (t ? t += e.path : t = e.path, e = e.manifest);
                        for (var i = 0, r = e.length; r > i; i++) n[i] = createjs.Sound.registerSound(e[i].src, e[i].id, e[i].data, t, e[i].defaultPlayProps);
                        return n
                    }, n.removeSound = function(e, i) {
                        if (null == n.activePlugin) return !1;
                        e instanceof Object && e.src && (e = e.src);
                        var r;
                        if (e instanceof Object ? r = n._parseSrc(e) : (e = n._getSrcById(e).src, r = n._parsePath(e)), null == r) return !1;
                        e = r.src, null != i && (e = i + e);
                        for (var o in n._idHash) n._idHash[o].src == e && delete n._idHash[o];
                        return t.removeSrc(e), delete n._preloadHash[e], n.activePlugin.removeSound(e), !0
                    }, n.removeSounds = function(e, t) {
                        var n = [];
                        e.path && (t ? t += e.path : t = e.path, e = e.manifest);
                        for (var i = 0, r = e.length; r > i; i++) n[i] = createjs.Sound.removeSound(e[i].src, t);
                        return n
                    }, n.removeAllSounds = function() {
                        n._idHash = {}, n._preloadHash = {}, t.removeAll(), n.activePlugin && n.activePlugin.removeAllSounds()
                    }, n.loadComplete = function(e) {
                        if (!n.isReady()) return !1;
                        var t = n._parsePath(e);
                        return e = t ? n._getSrcById(t.src).src : n._getSrcById(e).src, void 0 == n._preloadHash[e] ? !1 : 1 == n._preloadHash[e][0]
                    }, n._parsePath = function(e) {
                        "string" != typeof e && (e = e.toString());
                        var t = e.match(n.FILE_PATTERN);
                        if (null == t) return !1;
                        for (var i = t[4], r = t[5], o = n.capabilities, a = 0; !o[r];)
                            if (r = n.alternateExtensions[a++], a > n.alternateExtensions.length) return null;
                        e = e.replace("." + t[5], "." + r);
                        var s = {
                            name: i,
                            src: e,
                            extension: r
                        };
                        return s
                    }, n._parseSrc = function(e) {
                        var t = {
                                name: void 0,
                                src: void 0,
                                extension: void 0
                            },
                            i = n.capabilities;
                        for (var r in e)
                            if (e.hasOwnProperty(r) && i[r]) {
                                t.src = e[r], t.extension = r;
                                break
                            }
                        if (!t.src) return !1;
                        var o = t.src.lastIndexOf("/");
                        return t.name = -1 != o ? t.src.slice(o + 1) : t.src, t
                    }, n.play = function(e, t, i, r, o, a, s, l, c) {
                        var h;
                        h = createjs.PlayPropsConfig.create(t instanceof Object || t instanceof createjs.PlayPropsConfig ? t : {
                            interrupt: t,
                            delay: i,
                            offset: r,
                            loop: o,
                            volume: a,
                            pan: s,
                            startTime: l,
                            duration: c
                        });
                        var u = n.createInstance(e, h.startTime, h.duration),
                            f = n._playInstance(u, h);
                        return f || u._playFailed(), u
                    }, n.createInstance = function(e, i, r) {
                        if (!n.initializeDefaultPlugins()) return new createjs.DefaultSoundInstance(e, i, r);
                        var o = n._defaultPlayPropsHash[e];
                        e = n._getSrcById(e);
                        var a = n._parsePath(e.src),
                            s = null;
                        return null != a && null != a.src ? (t.create(a.src), null == i && (i = e.startTime), s = n.activePlugin.create(a.src, i, r || e.duration), o = o || n._defaultPlayPropsHash[a.src], o && s.applyPlayProps(o)) : s = new createjs.DefaultSoundInstance(e, i, r), s.uniqueId = n._lastID++, s
                    }, n.stop = function() {
                        for (var e = this._instances, t = e.length; t--;) e[t].stop()
                    }, n.setVolume = function(e) {
                        if (null == Number(e)) return !1;
                        if (e = Math.max(0, Math.min(1, e)), n._masterVolume = e, !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(e))
                            for (var t = this._instances, i = 0, r = t.length; r > i; i++) t[i].setMasterVolume(e)
                    }, n.getVolume = function() {
                        return this._masterVolume
                    }, n.setMute = function(e) {
                        if (null == e) return !1;
                        if (this._masterMute = e, !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(e))
                            for (var t = this._instances, n = 0, i = t.length; i > n; n++) t[n].setMasterMute(e);
                        return !0
                    }, n.getMute = function() {
                        return this._masterMute
                    }, n.setDefaultPlayProps = function(e, t) {
                        e = n._getSrcById(e), n._defaultPlayPropsHash[n._parsePath(e.src).src] = createjs.PlayPropsConfig.create(t)
                    }, n.getDefaultPlayProps = function(e) {
                        return e = n._getSrcById(e), n._defaultPlayPropsHash[n._parsePath(e.src).src]
                    }, n._playInstance = function(e, t) {
                        var i = n._defaultPlayPropsHash[e.src] || {};
                        if (null == t.interrupt && (t.interrupt = i.interrupt || n.defaultInterruptBehavior), null == t.delay && (t.delay = i.delay || 0), null == t.offset && (t.offset = e.getPosition()), null == t.loop && (t.loop = e.loop), null == t.volume && (t.volume = e.volume), null == t.pan && (t.pan = e.pan), 0 == t.delay) {
                            var r = n._beginPlaying(e, t);
                            if (!r) return !1
                        } else {
                            var o = setTimeout(function() {
                                n._beginPlaying(e, t)
                            }, t.delay);
                            e.delayTimeoutId = o
                        }
                        return this._instances.push(e), !0
                    }, n._beginPlaying = function(e, n) {
                        if (!t.add(e, n.interrupt)) return !1;
                        var i = e._beginPlaying(n);
                        if (!i) {
                            var r = createjs.indexOf(this._instances, e);
                            return r > -1 && this._instances.splice(r, 1), !1
                        }
                        return !0
                    }, n._getSrcById = function(e) {
                        return n._idHash[e] || {
                                src: e
                            }
                    }, n._playFinished = function(e) {
                        t.remove(e);
                        var n = createjs.indexOf(this._instances, e);
                        n > -1 && this._instances.splice(n, 1)
                    }, createjs.Sound = e, t.channels = {}, t.create = function(e, n) {
                        var i = t.get(e);
                        return null == i ? (t.channels[e] = new t(e, n), !0) : !1
                    }, t.removeSrc = function(e) {
                        var n = t.get(e);
                        return null == n ? !1 : (n._removeAll(), delete t.channels[e], !0)
                    }, t.removeAll = function() {
                        for (var e in t.channels) t.channels[e]._removeAll();
                        t.channels = {}
                    }, t.add = function(e, n) {
                        var i = t.get(e.src);
                        return null == i ? !1 : i._add(e, n)
                    }, t.remove = function(e) {
                        var n = t.get(e.src);
                        return null == n ? !1 : (n._remove(e), !0)
                    }, t.maxPerChannel = function() {
                        return i.maxDefault
                    }, t.get = function(e) {
                        return t.channels[e]
                    };
                    var i = t.prototype;
                    i.constructor = t, i.src = null, i.max = null, i.maxDefault = 100, i.length = 0, i.init = function(e, t) {
                        this.src = e, this.max = t || this.maxDefault, -1 == this.max && (this.max = this.maxDefault), this._instances = []
                    }, i._get = function(e) {
                        return this._instances[e]
                    }, i._add = function(e, t) {
                        return this._getSlot(t, e) ? (this._instances.push(e), this.length++, !0) : !1
                    }, i._remove = function(e) {
                        var t = createjs.indexOf(this._instances, e);
                        return -1 == t ? !1 : (this._instances.splice(t, 1), this.length--, !0)
                    }, i._removeAll = function() {
                        for (var e = this.length - 1; e >= 0; e--) this._instances[e].stop()
                    }, i._getSlot = function(t) {
                        var n, i;
                        if (t != e.INTERRUPT_NONE && (i = this._get(0), null == i)) return !0;
                        for (var r = 0, o = this.max; o > r; r++) {
                            if (n = this._get(r), null == n) return !0;
                            if (n.playState == e.PLAY_FINISHED || n.playState == e.PLAY_INTERRUPTED || n.playState == e.PLAY_FAILED) {
                                i = n;
                                break
                            }
                            t != e.INTERRUPT_NONE && (t == e.INTERRUPT_EARLY && n.getPosition() < i.getPosition() || t == e.INTERRUPT_LATE && n.getPosition() > i.getPosition()) && (i = n)
                        }
                        return null != i ? (i._interrupt(), this._remove(i), !0) : !1
                    }, i.toString = function() {
                        return "[Sound SoundChannel]"
                    }
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";
                    var e = function(e, t, n, i) {
                            this.EventDispatcher_constructor(), this.src = e, this.uniqueId = -1, this.playState = null, this.delayTimeoutId = null, this._volume = 1, Object.defineProperty(this, "volume", {
                                get: this.getVolume,
                                set: this.setVolume
                            }), this._pan = 0, Object.defineProperty(this, "pan", {
                                get: this.getPan,
                                set: this.setPan
                            }), this._startTime = Math.max(0, t || 0), Object.defineProperty(this, "startTime", {
                                get: this.getStartTime,
                                set: this.setStartTime
                            }), this._duration = Math.max(0, n || 0), Object.defineProperty(this, "duration", {
                                get: this.getDuration,
                                set: this.setDuration
                            }), this._playbackResource = null, Object.defineProperty(this, "playbackResource", {
                                get: this.getPlaybackResource,
                                set: this.setPlaybackResource
                            }), i !== !1 && i !== !0 && this.setPlaybackResource(i), this._position = 0, Object.defineProperty(this, "position", {
                                get: this.getPosition,
                                set: this.setPosition
                            }), this._loop = 0, Object.defineProperty(this, "loop", {
                                get: this.getLoop,
                                set: this.setLoop
                            }), this._muted = !1, Object.defineProperty(this, "muted", {
                                get: this.getMuted,
                                set: this.setMuted
                            }), this._paused = !1, Object.defineProperty(this, "paused", {
                                get: this.getPaused,
                                set: this.setPaused
                            })
                        },
                        t = createjs.extend(e, createjs.EventDispatcher);
                    t.play = function(e, t, n, i, r, o) {
                        var a;
                        return a = createjs.PlayPropsConfig.create(e instanceof Object || e instanceof createjs.PlayPropsConfig ? e : {
                            interrupt: e,
                            delay: t,
                            offset: n,
                            loop: i,
                            volume: r,
                            pan: o
                        }), this.playState == createjs.Sound.PLAY_SUCCEEDED ? (this.applyPlayProps(a), void(this._paused && this.setPaused(!1))) : (this._cleanUp(), createjs.Sound._playInstance(this, a), this)
                    }, t.stop = function() {
                        return this._position = 0, this._paused = !1, this._handleStop(), this._cleanUp(), this.playState = createjs.Sound.PLAY_FINISHED, this
                    }, t.destroy = function() {
                        this._cleanUp(), this.src = null, this.playbackResource = null, this.removeAllEventListeners()
                    }, t.applyPlayProps = function(e) {
                        return null != e.offset && this.setPosition(e.offset), null != e.loop && this.setLoop(e.loop), null != e.volume && this.setVolume(e.volume), null != e.pan && this.setPan(e.pan), null != e.startTime && (this.setStartTime(e.startTime), this.setDuration(e.duration)), this
                    }, t.toString = function() {
                        return "[AbstractSoundInstance]"
                    }, t.getPaused = function() {
                        return this._paused
                    }, t.setPaused = function(e) {
                        return e !== !0 && e !== !1 || this._paused == e || 1 == e && this.playState != createjs.Sound.PLAY_SUCCEEDED ? void 0 : (this._paused = e, e ? this._pause() : this._resume(), clearTimeout(this.delayTimeoutId), this)
                    }, t.setVolume = function(e) {
                        return e == this._volume ? this : (this._volume = Math.max(0, Math.min(1, e)), this._muted || this._updateVolume(), this)
                    }, t.getVolume = function() {
                        return this._volume
                    }, t.setMuted = function(e) {
                        return e === !0 || e === !1 ? (this._muted = e, this._updateVolume(), this) : void 0
                    }, t.getMuted = function() {
                        return this._muted
                    }, t.setPan = function(e) {
                        return e == this._pan ? this : (this._pan = Math.max(-1, Math.min(1, e)), this._updatePan(), this)
                    }, t.getPan = function() {
                        return this._pan
                    }, t.getPosition = function() {
                        return this._paused || this.playState != createjs.Sound.PLAY_SUCCEEDED || (this._position = this._calculateCurrentPosition()), this._position
                    }, t.setPosition = function(e) {
                        return this._position = Math.max(0, e), this.playState == createjs.Sound.PLAY_SUCCEEDED && this._updatePosition(), this
                    }, t.getStartTime = function() {
                        return this._startTime
                    }, t.setStartTime = function(e) {
                        return e == this._startTime ? this : (this._startTime = Math.max(0, e || 0), this._updateStartTime(), this)
                    }, t.getDuration = function() {
                        return this._duration
                    }, t.setDuration = function(e) {
                        return e == this._duration ? this : (this._duration = Math.max(0, e || 0), this._updateDuration(), this)
                    }, t.setPlaybackResource = function(e) {
                        return this._playbackResource = e, 0 == this._duration && this._setDurationFromSource(), this
                    }, t.getPlaybackResource = function() {
                        return this._playbackResource
                    }, t.getLoop = function() {
                        return this._loop
                    }, t.setLoop = function(e) {
                        null != this._playbackResource && (0 != this._loop && 0 == e ? this._removeLooping(e) : 0 == this._loop && 0 != e && this._addLooping(e)), this._loop = e
                    }, t._sendEvent = function(e) {
                        var t = new createjs.Event(e);
                        this.dispatchEvent(t)
                    }, t._cleanUp = function() {
                        clearTimeout(this.delayTimeoutId), this._handleCleanUp(), this._paused = !1, createjs.Sound._playFinished(this)
                    }, t._interrupt = function() {
                        this._cleanUp(), this.playState = createjs.Sound.PLAY_INTERRUPTED, this._sendEvent("interrupted")
                    }, t._beginPlaying = function(e) {
                        return this.setPosition(e.offset), this.setLoop(e.loop), this.setVolume(e.volume), this.setPan(e.pan), null != e.startTime && (this.setStartTime(e.startTime), this.setDuration(e.duration)), null != this._playbackResource && this._position < this._duration ? (this._paused = !1, this._handleSoundReady(), this.playState = createjs.Sound.PLAY_SUCCEEDED, this._sendEvent("succeeded"), !0) : (this._playFailed(), !1)
                    }, t._playFailed = function() {
                        this._cleanUp(), this.playState = createjs.Sound.PLAY_FAILED, this._sendEvent("failed")
                    }, t._handleSoundComplete = function() {
                        return this._position = 0, 0 != this._loop ? (this._loop--, this._handleLoop(), void this._sendEvent("loop")) : (this._cleanUp(), this.playState = createjs.Sound.PLAY_FINISHED, void this._sendEvent("complete"))
                    }, t._handleSoundReady = function() {}, t._updateVolume = function() {}, t._updatePan = function() {}, t._updateStartTime = function() {}, t._updateDuration = function() {}, t._setDurationFromSource = function() {}, t._calculateCurrentPosition = function() {}, t._updatePosition = function() {}, t._removeLooping = function() {}, t._addLooping = function() {}, t._pause = function() {}, t._resume = function() {}, t._handleStop = function() {}, t._handleCleanUp = function() {}, t._handleLoop = function() {}, createjs.AbstractSoundInstance = createjs.promote(e, "EventDispatcher"), createjs.DefaultSoundInstance = createjs.AbstractSoundInstance
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";
                    var e = function() {
                            this._capabilities = null, this._loaders = {}, this._audioSources = {}, this._soundInstances = {}, this._volume = 1, this._loaderClass, this._soundInstanceClass
                        },
                        t = e.prototype;
                    e._capabilities = null, e.isSupported = function() {
                        return !0
                    }, t.register = function(e) {
                        var t = this._loaders[e.src];
                        return t && !t.canceled ? this._loaders[e.src] : (this._audioSources[e.src] = !0, this._soundInstances[e.src] = [], t = new this._loaderClass(e), t.on("complete", createjs.proxy(this._handlePreloadComplete, this)), this._loaders[e.src] = t, t)
                    }, t.preload = function(e) {
                        e.on("error", createjs.proxy(this._handlePreloadError, this)), e.load()
                    }, t.isPreloadStarted = function(e) {
                        return null != this._audioSources[e]
                    }, t.isPreloadComplete = function(e) {
                        return !(null == this._audioSources[e] || 1 == this._audioSources[e])
                    }, t.removeSound = function(e) {
                        if (this._soundInstances[e]) {
                            for (var t = this._soundInstances[e].length; t--;) {
                                var n = this._soundInstances[e][t];
                                n.destroy()
                            }
                            delete this._soundInstances[e], delete this._audioSources[e], this._loaders[e] && this._loaders[e].destroy(), delete this._loaders[e]
                        }
                    }, t.removeAllSounds = function() {
                        for (var e in this._audioSources) this.removeSound(e)
                    }, t.create = function(e, t, n) {
                        this.isPreloadStarted(e) || this.preload(this.register(e));
                        var i = new this._soundInstanceClass(e, t, n, this._audioSources[e]);
                        return this._soundInstances[e].push(i), i
                    }, t.setVolume = function(e) {
                        return this._volume = e, this._updateVolume(), !0
                    }, t.getVolume = function() {
                        return this._volume
                    }, t.setMute = function() {
                        return this._updateVolume(), !0
                    }, t.toString = function() {
                        return "[AbstractPlugin]"
                    }, t._handlePreloadComplete = function(e) {
                        var t = e.target.getItem().src;
                        this._audioSources[t] = e.result;
                        for (var n = 0, i = this._soundInstances[t].length; i > n; n++) {
                            var r = this._soundInstances[t][n];
                            r.setPlaybackResource(this._audioSources[t])
                        }
                    }, t._handlePreloadError = function() {}, t._updateVolume = function() {}, createjs.AbstractPlugin = e
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e) {
                        this.AbstractLoader_constructor(e, !0, createjs.AbstractLoader.SOUND)
                    }
                    var t = createjs.extend(e, createjs.AbstractLoader);
                    e.context = null, t.toString = function() {
                        return "[WebAudioLoader]"
                    }, t._createRequest = function() {
                        this._request = new createjs.XHRRequest(this._item, !1), this._request.setResponseType("arraybuffer")
                    }, t._sendComplete = function() {
                        e.context.decodeAudioData(this._rawResult, createjs.proxy(this._handleAudioDecoded, this), createjs.proxy(this._sendError, this))
                    }, t._handleAudioDecoded = function(e) {
                        this._result = e, this.AbstractLoader__sendComplete()
                    }, createjs.WebAudioLoader = createjs.promote(e, "AbstractLoader")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, i, r) {
                        this.AbstractSoundInstance_constructor(e, t, i, r), this.gainNode = n.context.createGain(), this.panNode = n.context.createPanner(), this.panNode.panningModel = n._panningModel, this.panNode.connect(this.gainNode), this.sourceNode = null, this._soundCompleteTimeout = null, this._sourceNodeNext = null, this._playbackStartTime = 0, this._endedHandler = createjs.proxy(this._handleSoundComplete, this)
                    }
                    var t = createjs.extend(e, createjs.AbstractSoundInstance),
                        n = e;
                    n.context = null, n.destinationNode = null, n._panningModel = "equalpower", t.destroy = function() {
                        this.AbstractSoundInstance_destroy(), this.panNode.disconnect(0), this.panNode = null, this.gainNode.disconnect(0), this.gainNode = null
                    }, t.toString = function() {
                        return "[WebAudioSoundInstance]"
                    }, t._updatePan = function() {
                        this.panNode.setPosition(this._pan, 0, -.5)
                    }, t._removeLooping = function() {
                        this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)
                    }, t._addLooping = function() {
                        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
                    }, t._setDurationFromSource = function() {
                        this._duration = 1e3 * this.playbackResource.duration
                    }, t._handleCleanUp = function() {
                        this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED && (this.sourceNode = this._cleanUpAudioNode(this.sourceNode), this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)), 0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0), clearTimeout(this._soundCompleteTimeout), this._playbackStartTime = 0
                    }, t._cleanUpAudioNode = function(e) {
                        return e && (e.stop(0), e.disconnect(0), e = null), e
                    }, t._handleSoundReady = function() {
                        this.gainNode.connect(n.destinationNode);
                        var e = .001 * this._duration,
                            t = .001 * this._position;
                        t > e && (t = e), this.sourceNode = this._createAndPlayAudioNode(n.context.currentTime - e, t), this._playbackStartTime = this.sourceNode.startTime - t, this._soundCompleteTimeout = setTimeout(this._endedHandler, 1e3 * (e - t)), 0 != this._loop && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
                    }, t._createAndPlayAudioNode = function(e, t) {
                        var i = n.context.createBufferSource();
                        i.buffer = this.playbackResource, i.connect(this.panNode);
                        var r = .001 * this._duration;
                        return i.startTime = e + r, i.start(i.startTime, t + .001 * this._startTime, r - t), i
                    }, t._pause = function() {
                        this._position = 1e3 * (n.context.currentTime - this._playbackStartTime), this.sourceNode = this._cleanUpAudioNode(this.sourceNode), this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext), 0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0), clearTimeout(this._soundCompleteTimeout)
                    }, t._resume = function() {
                        this._handleSoundReady()
                    }, t._updateVolume = function() {
                        var e = this._muted ? 0 : this._volume;
                        e != this.gainNode.gain.value && (this.gainNode.gain.value = e)
                    }, t._calculateCurrentPosition = function() {
                        return 1e3 * (n.context.currentTime - this._playbackStartTime)
                    }, t._updatePosition = function() {
                        this.sourceNode = this._cleanUpAudioNode(this.sourceNode), this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext), clearTimeout(this._soundCompleteTimeout), this._paused || this._handleSoundReady()
                    }, t._handleLoop = function() {
                        this._cleanUpAudioNode(this.sourceNode), this.sourceNode = this._sourceNodeNext, this._playbackStartTime = this.sourceNode.startTime, this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0), this._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration)
                    }, t._updateDuration = function() {
                        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._pause(), this._resume())
                    }, createjs.WebAudioSoundInstance = createjs.promote(e, "AbstractSoundInstance")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        this.AbstractPlugin_constructor(), this._panningModel = n._panningModel, this.context = n.context, this.dynamicsCompressorNode = this.context.createDynamicsCompressor(), this.dynamicsCompressorNode.connect(this.context.destination), this.gainNode = this.context.createGain(), this.gainNode.connect(this.dynamicsCompressorNode), createjs.WebAudioSoundInstance.destinationNode = this.gainNode, this._capabilities = n._capabilities, this._loaderClass = createjs.WebAudioLoader, this._soundInstanceClass = createjs.WebAudioSoundInstance, this._addPropsToClasses()
                    }
                    var t = createjs.extend(e, createjs.AbstractPlugin),
                        n = e;
                    n._capabilities = null, n._panningModel = "equalpower", n.context = null, n.isSupported = function() {
                        var e = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;
                        return "file:" != location.protocol || e || this._isFileXHRSupported() ? (n._generateCapabilities(), null != n.context) : !1
                    }, n.playEmptySound = function() {
                        if (null != n.context) {
                            var e = n.context.createBufferSource();
                            e.buffer = n.context.createBuffer(1, 1, 22050), e.connect(n.context.destination), e.start(0, 0, 0)
                        }
                    }, n._isFileXHRSupported = function() {
                        var e = !0,
                            t = new XMLHttpRequest;
                        try {
                            t.open("GET", "WebAudioPluginTest.fail", !1)
                        } catch (n) {
                            return e = !1
                        }
                        t.onerror = function() {
                            e = !1
                        }, t.onload = function() {
                            e = 404 == this.status || 200 == this.status || 0 == this.status && "" != this.response
                        };
                        try {
                            t.send()
                        } catch (n) {
                            e = !1
                        }
                        return e
                    }, n._generateCapabilities = function() {
                        if (null == n._capabilities) {
                            var e = document.createElement("audio");
                            if (null == e.canPlayType) return null;
                            if (null == n.context)
                                if (window.AudioContext) n.context = new AudioContext;
                                else {
                                    if (!window.webkitAudioContext) return null;
                                    n.context = new webkitAudioContext
                                }
                            n._compatibilitySetUp(), n.playEmptySound(), n._capabilities = {
                                panning: !0,
                                volume: !0,
                                tracks: -1
                            };
                            for (var t = createjs.Sound.SUPPORTED_EXTENSIONS, i = createjs.Sound.EXTENSION_MAP, r = 0, o = t.length; o > r; r++) {
                                var a = t[r],
                                    s = i[a] || a;
                                n._capabilities[a] = "no" != e.canPlayType("audio/" + a) && "" != e.canPlayType("audio/" + a) || "no" != e.canPlayType("audio/" + s) && "" != e.canPlayType("audio/" + s)
                            }
                            n.context.destination.numberOfChannels < 2 && (n._capabilities.panning = !1)
                        }
                    }, n._compatibilitySetUp = function() {
                        if (n._panningModel = "equalpower", !n.context.createGain) {
                            n.context.createGain = n.context.createGainNode;
                            var e = n.context.createBufferSource();
                            e.__proto__.start = e.__proto__.noteGrainOn, e.__proto__.stop = e.__proto__.noteOff, n._panningModel = 0
                        }
                    }, t.toString = function() {
                        return "[WebAudioPlugin]"
                    }, t._addPropsToClasses = function() {
                        var e = this._soundInstanceClass;
                        e.context = this.context, e.destinationNode = this.gainNode, e._panningModel = this._panningModel, this._loaderClass.context = this.context
                    }, t._updateVolume = function() {
                        var e = createjs.Sound._masterMute ? 0 : this._volume;
                        e != this.gainNode.gain.value && (this.gainNode.gain.value = e)
                    }, createjs.WebAudioPlugin = createjs.promote(e, "AbstractPlugin")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        throw "HTMLAudioTagPool cannot be instantiated"
                    }

                    function t() {
                        this._tags = []
                    }
                    var n = e;
                    n._tags = {}, n._tagPool = new t, n._tagUsed = {}, n.get = function(e) {
                        var t = n._tags[e];
                        return null == t ? (t = n._tags[e] = n._tagPool.get(), t.src = e) : n._tagUsed[e] ? (t = n._tagPool.get(), t.src = e) : n._tagUsed[e] = !0, t
                    }, n.set = function(e, t) {
                        t == n._tags[e] ? n._tagUsed[e] = !1 : n._tagPool.set(t)
                    }, n.remove = function(e) {
                        var t = n._tags[e];
                        return null == t ? !1 : (n._tagPool.set(t), delete n._tags[e], delete n._tagUsed[e], !0)
                    }, n.getDuration = function(e) {
                        var t = n._tags[e];
                        return null == t ? 0 : 1e3 * t.duration
                    }, createjs.HTMLAudioTagPool = e;
                    var i = t.prototype;
                    i.constructor = t, i.get = function() {
                        var e;
                        return e = 0 == this._tags.length ? this._createTag() : this._tags.pop(), null == e.parentNode && document.body.appendChild(e), e
                    }, i.set = function(e) {
                        var t = createjs.indexOf(this._tags, e); - 1 == t && (this._tags.src = null, this._tags.push(e))
                    }, i.toString = function() {
                        return "[TagPool]"
                    }, i._createTag = function() {
                        var e = document.createElement("audio");
                        return e.autoplay = !1, e.preload = "none", e
                    }
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e(e, t, n, i) {
                        this.AbstractSoundInstance_constructor(e, t, n, i), this._audioSpriteStopTime = null, this._delayTimeoutId = null, this._endedHandler = createjs.proxy(this._handleSoundComplete, this), this._readyHandler = createjs.proxy(this._handleTagReady, this), this._stalledHandler = createjs.proxy(this._playFailed, this), this._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this), this._loopHandler = createjs.proxy(this._handleSoundComplete, this), n ? this._audioSpriteStopTime = .001 * (t + n) : this._duration = createjs.HTMLAudioTagPool.getDuration(this.src)
                    }
                    var t = createjs.extend(e, createjs.AbstractSoundInstance);
                    t.setMasterVolume = function() {
                        this._updateVolume()
                    }, t.setMasterMute = function() {
                        this._updateVolume()
                    }, t.toString = function() {
                        return "[HTMLAudioSoundInstance]"
                    }, t._removeLooping = function() {
                        null != this._playbackResource && (this._playbackResource.loop = !1, this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
                    }, t._addLooping = function() {
                        null == this._playbackResource || this._audioSpriteStopTime || (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.loop = !0)
                    }, t._handleCleanUp = function() {
                        var e = this._playbackResource;
                        if (null != e) {
                            e.pause(), e.loop = !1, e.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), e.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1), e.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), e.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), e.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1);
                            try {
                                e.currentTime = this._startTime
                            } catch (t) {}
                            createjs.HTMLAudioTagPool.set(this.src, e), this._playbackResource = null
                        }
                    }, t._beginPlaying = function(e) {
                        return this._playbackResource = createjs.HTMLAudioTagPool.get(this.src), this.AbstractSoundInstance__beginPlaying(e)
                    }, t._handleSoundReady = function() {
                        if (4 !== this._playbackResource.readyState) {
                            var e = this._playbackResource;
                            return e.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1), e.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), e.preload = "auto", void e.load()
                        }
                        this._updateVolume(), this._playbackResource.currentTime = .001 * (this._startTime + this._position), this._audioSpriteStopTime ? this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1) : (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), 0 != this._loop && (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.loop = !0)), this._playbackResource.play()
                    }, t._handleTagReady = function() {
                        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1), this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1), this._handleSoundReady()
                    }, t._pause = function() {
                        this._playbackResource.pause()
                    }, t._resume = function() {
                        this._playbackResource.play()
                    }, t._updateVolume = function() {
                        if (null != this._playbackResource) {
                            var e = this._muted || createjs.Sound._masterMute ? 0 : this._volume * createjs.Sound._masterVolume;
                            e != this._playbackResource.volume && (this._playbackResource.volume = e)
                        }
                    }, t._calculateCurrentPosition = function() {
                        return 1e3 * this._playbackResource.currentTime - this._startTime
                    }, t._updatePosition = function() {
                        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1);
                        try {
                            this._playbackResource.currentTime = .001 * (this._position + this._startTime)
                        } catch (e) {
                            this._handleSetPositionSeek(null)
                        }
                    }, t._handleSetPositionSeek = function() {
                        null != this._playbackResource && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
                    }, t._handleAudioSpriteLoop = function() {
                        this._playbackResource.currentTime <= this._audioSpriteStopTime || (this._playbackResource.pause(), 0 == this._loop ? this._handleSoundComplete(null) : (this._position = 0, this._loop--, this._playbackResource.currentTime = .001 * this._startTime, this._paused || this._playbackResource.play(), this._sendEvent("loop")))
                    }, t._handleLoop = function() {
                        0 == this._loop && (this._playbackResource.loop = !1, this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
                    }, t._updateStartTime = function() {
                        this._audioSpriteStopTime = .001 * (this._startTime + this._duration), this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1))
                    }, t._updateDuration = function() {
                        this._audioSpriteStopTime = .001 * (this._startTime + this._duration), this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1), this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1))
                    }, createjs.HTMLAudioSoundInstance = createjs.promote(e, "AbstractSoundInstance")
                }(), this.createjs = this.createjs || {},
                function() {
                    "use strict";

                    function e() {
                        this.AbstractPlugin_constructor(), this.defaultNumChannels = 2, this._capabilities = n._capabilities, this._loaderClass = createjs.SoundLoader, this._soundInstanceClass = createjs.HTMLAudioSoundInstance
                    }
                    var t = createjs.extend(e, createjs.AbstractPlugin),
                        n = e;
                    n.MAX_INSTANCES = 30, n._AUDIO_READY = "canplaythrough", n._AUDIO_ENDED = "ended", n._AUDIO_SEEKED = "seeked", n._AUDIO_STALLED = "stalled", n._TIME_UPDATE = "timeupdate", n._capabilities = null, n.isSupported = function() {
                        return n._generateCapabilities(), null != n._capabilities
                    }, n._generateCapabilities = function() {
                        if (null == n._capabilities) {
                            var e = document.createElement("audio");
                            if (null == e.canPlayType) return null;
                            n._capabilities = {
                                panning: !1,
                                volume: !0,
                                tracks: -1
                            };
                            for (var t = createjs.Sound.SUPPORTED_EXTENSIONS, i = createjs.Sound.EXTENSION_MAP, r = 0, o = t.length; o > r; r++) {
                                var a = t[r],
                                    s = i[a] || a;
                                n._capabilities[a] = "no" != e.canPlayType("audio/" + a) && "" != e.canPlayType("audio/" + a) || "no" != e.canPlayType("audio/" + s) && "" != e.canPlayType("audio/" + s)
                            }
                        }
                    }, t.register = function(e) {
                        var t = createjs.HTMLAudioTagPool.get(e.src),
                            n = this.AbstractPlugin_register(e);
                        return n.setTag(t), n
                    }, t.removeSound = function(e) {
                        this.AbstractPlugin_removeSound(e), createjs.HTMLAudioTagPool.remove(e)
                    }, t.create = function(e, t, n) {
                        var i = this.AbstractPlugin_create(e, t, n);
                        return i.setPlaybackResource(null), i
                    }, t.toString = function() {
                        return "[HTMLAudioPlugin]"
                    }, t.setVolume = t.getVolume = t.setMute = null, createjs.HTMLAudioPlugin = createjs.promote(e, "AbstractPlugin")
                }(), "object" == typeof t && (t.exports = window.createjs.Sound);
        }, {}
    ],
    24: [
        function(e, t, n) {
            var i = function() {
                var e = Date.now(),
                    t = e,
                    n = 0,
                    i = 1 / 0,
                    r = 0,
                    o = 0,
                    a = 1 / 0,
                    s = 0,
                    l = 0,
                    c = 0,
                    h = document.createElement("div");
                h.id = "stats", h.addEventListener("mousedown", function(e) {
                    e.preventDefault(), y(++c % 2)
                }, !1), h.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
                var u = document.createElement("div");
                u.id = "fps", u.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", h.appendChild(u);
                var f = document.createElement("div");
                f.id = "fpsText", f.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", f.innerHTML = "FPS", u.appendChild(f);
                var d = document.createElement("div");
                for (d.id = "fpsGraph", d.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", u.appendChild(d); 74 > d.children.length;) {
                    var p = document.createElement("span");
                    p.style.cssText = "width:1px;height:30px;float:left;background-color:#113", d.appendChild(p)
                }
                var m = document.createElement("div");
                m.id = "ms", m.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", h.appendChild(m);
                var v = document.createElement("div");
                v.id = "msText", v.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", v.innerHTML = "MS", m.appendChild(v);
                var g = document.createElement("div");
                for (g.id = "msGraph", g.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", m.appendChild(g); 74 > g.children.length;) p = document.createElement("span"), p.style.cssText = "width:1px;height:30px;float:left;background-color:#131", g.appendChild(p);
                var y = function(e) {
                    switch (c = e) {
                        case 0:
                            u.style.display = "block", m.style.display = "none";
                            break;
                        case 1:
                            u.style.display = "none", m.style.display = "block"
                    }
                };
                return {
                    REVISION: 12,
                    domElement: h,
                    setMode: y,
                    begin: function() {
                        e = Date.now()
                    },
                    end: function() {
                        var c = Date.now();
                        n = c - e, i = Math.min(i, n), r = Math.max(r, n), v.textContent = n + " MS (" + i + "-" + r + ")";
                        var h = Math.min(30, 30 - 30 * (n / 200));
                        return g.appendChild(g.firstChild).style.height = h + "px", l++, c > t + 1e3 && (o = Math.round(1e3 * l / (c - t)), a = Math.min(a, o), s = Math.max(s, o), f.textContent = o + " FPS (" + a + "-" + s + ")", h = Math.min(30, 30 - 30 * (o / 100)), d.appendChild(d.firstChild).style.height = h + "px", t = c, l = 0), c
                    },
                    update: function() {
                        e = this.end()
                    }
                }
            };
            "object" == typeof t && (t.exports = i)
        }, {}
    ],
    25: [
        function(e, t, n) {
            var i = {
                REVISION: "71"
            };
            "object" == typeof t && (t.exports = i), void 0 === Math.sign && (Math.sign = function(e) {
                return 0 > e ? -1 : e > 0 ? 1 : +e
            }), i.log = function() {
                console.log.apply(console, arguments)
            }, i.warn = function() {
                console.warn.apply(console, arguments)
            }, i.error = function() {
                console.error.apply(console, arguments)
            }, i.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, i.CullFaceNone = 0, i.CullFaceBack = 1, i.CullFaceFront = 2, i.CullFaceFrontBack = 3, i.FrontFaceDirectionCW = 0, i.FrontFaceDirectionCCW = 1, i.BasicShadowMap = 0, i.PCFShadowMap = 1, i.PCFSoftShadowMap = 2, i.FrontSide = 0, i.BackSide = 1, i.DoubleSide = 2, i.NoShading = 0, i.FlatShading = 1, i.SmoothShading = 2, i.NoColors = 0, i.FaceColors = 1, i.VertexColors = 2, i.NoBlending = 0, i.NormalBlending = 1, i.AdditiveBlending = 2, i.SubtractiveBlending = 3, i.MultiplyBlending = 4, i.CustomBlending = 5, i.AddEquation = 100, i.SubtractEquation = 101, i.ReverseSubtractEquation = 102, i.MinEquation = 103, i.MaxEquation = 104, i.ZeroFactor = 200, i.OneFactor = 201, i.SrcColorFactor = 202, i.OneMinusSrcColorFactor = 203, i.SrcAlphaFactor = 204, i.OneMinusSrcAlphaFactor = 205, i.DstAlphaFactor = 206, i.OneMinusDstAlphaFactor = 207, i.DstColorFactor = 208, i.OneMinusDstColorFactor = 209, i.SrcAlphaSaturateFactor = 210, i.MultiplyOperation = 0, i.MixOperation = 1, i.AddOperation = 2, i.UVMapping = 300, i.CubeReflectionMapping = 301, i.CubeRefractionMapping = 302, i.EquirectangularReflectionMapping = 303, i.EquirectangularRefractionMapping = 304, i.SphericalReflectionMapping = 305, i.RepeatWrapping = 1e3, i.ClampToEdgeWrapping = 1001, i.MirroredRepeatWrapping = 1002, i.NearestFilter = 1003, i.NearestMipMapNearestFilter = 1004, i.NearestMipMapLinearFilter = 1005, i.LinearFilter = 1006, i.LinearMipMapNearestFilter = 1007, i.LinearMipMapLinearFilter = 1008, i.UnsignedByteType = 1009, i.ByteType = 1010, i.ShortType = 1011, i.UnsignedShortType = 1012, i.IntType = 1013, i.UnsignedIntType = 1014, i.FloatType = 1015, i.HalfFloatType = 1025, i.UnsignedShort4444Type = 1016, i.UnsignedShort5551Type = 1017, i.UnsignedShort565Type = 1018, i.AlphaFormat = 1019, i.RGBFormat = 1020, i.RGBAFormat = 1021, i.LuminanceFormat = 1022, i.LuminanceAlphaFormat = 1023, i.RGBEFormat = i.RGBAFormat, i.RGB_S3TC_DXT1_Format = 2001, i.RGBA_S3TC_DXT1_Format = 2002, i.RGBA_S3TC_DXT3_Format = 2003, i.RGBA_S3TC_DXT5_Format = 2004, i.RGB_PVRTC_4BPPV1_Format = 2100, i.RGB_PVRTC_2BPPV1_Format = 2101, i.RGBA_PVRTC_4BPPV1_Format = 2102, i.RGBA_PVRTC_2BPPV1_Format = 2103, i.Projector = function() {
                i.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
                    i.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
                }, this.unprojectVector = function(e, t) {
                    i.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
                }, this.pickingRay = function(e, t) {
                    i.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, i.CanvasRenderer = function() {
                i.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
            }, i.Color = function(e) {
                return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(e)
            }, i.Color.prototype = {
                constructor: i.Color,
                r: 1,
                g: 1,
                b: 1,
                set: function(e) {
                    return e instanceof i.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setHex: function(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function(e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                },
                setHSL: function(e, t, n) {
                    if (0 === t) this.r = this.g = this.b = n;
                    else {
                        var i = function(e, t, n) {
                                return 0 > n && (n += 1), n > 1 && (n -= 1), 1 / 6 > n ? e + 6 * (t - e) * n : .5 > n ? t : 2 / 3 > n ? e + 6 * (t - e) * (2 / 3 - n) : e
                            },
                            r = .5 >= n ? n * (1 + t) : n + t - n * t,
                            o = 2 * n - r;
                        this.r = i(o, r, e + 1 / 3), this.g = i(o, r, e), this.b = i(o, r, e - 1 / 3)
                    }
                    return this
                },
                setStyle: function(e) {
                    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) {
                        var t = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e);
                        return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, this
                    }
                    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) {
                        var t = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e);
                        return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, this
                    }
                    if (/^\#([0-9a-f]{6})$/i.test(e)) {
                        var t = /^\#([0-9a-f]{6})$/i.exec(e);
                        return this.setHex(parseInt(t[1], 16)), this
                    }
                    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) {
                        var t = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e);
                        return this.setHex(parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3], 16)), this
                    }
                    return /^(\w+)$/i.test(e) ? (this.setHex(i.ColorKeywords[e]), this) : void 0
                },
                copy: function(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function(e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function(e, t) {
                    void 0 === t && (t = 2);
                    var n = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                },
                convertGammaToLinear: function() {
                    var e = this.r,
                        t = this.g,
                        n = this.b;
                    return this.r = e * e, this.g = t * t, this.b = n * n, this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(e) {
                    var t, n, i = e || {
                                h: 0,
                                s: 0,
                                l: 0
                            },
                        r = this.r,
                        o = this.g,
                        a = this.b,
                        s = Math.max(r, o, a),
                        l = Math.min(r, o, a),
                        c = (l + s) / 2;
                    if (l === s) t = 0, n = 0;
                    else {
                        var h = s - l;
                        switch (n = .5 >= c ? h / (s + l) : h / (2 - s - l), s) {
                            case r:
                                t = (o - a) / h + (a > o ? 6 : 0);
                                break;
                            case o:
                                t = (a - r) / h + 2;
                                break;
                            case a:
                                t = (r - o) / h + 4
                        }
                        t /= 6
                    }
                    return i.h = t, i.s = n, i.l = c, i
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(e, t, n) {
                    var i = this.getHSL();
                    return i.h += e, i.s += t, i.l += n, this.setHSL(i.h, i.s, i.l), this
                },
                add: function(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function(e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                multiply: function(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                equals: function(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function(e) {
                    return this.r = e[0], this.g = e[1], this.b = e[2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                },
                clone: function() {
                    return (new i.Color).setRGB(this.r, this.g, this.b)
                }
            }, i.ColorKeywords = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            }, i.Quaternion = function(e, t, n, i) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }, i.Quaternion.prototype = {
                constructor: i.Quaternion,
                _x: 0,
                _y: 0,
                _z: 0,
                _w: 0,
                get x() {
                    return this._x
                },
                set x(e) {
                    this._x = e, this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(e) {
                    this._y = e, this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(e) {
                    this._z = e, this.onChangeCallback()
                },
                get w() {
                    return this._w
                },
                set w(e) {
                    this._w = e, this.onChangeCallback()
                },
                set: function(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                copy: function(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
                },
                setFromEuler: function(e, t) {
                    if (e instanceof i.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var n = Math.cos(e._x / 2),
                        r = Math.cos(e._y / 2),
                        o = Math.cos(e._z / 2),
                        a = Math.sin(e._x / 2),
                        s = Math.sin(e._y / 2),
                        l = Math.sin(e._z / 2);
                    return "XYZ" === e.order ? (this._x = a * r * o + n * s * l, this._y = n * s * o - a * r * l, this._z = n * r * l + a * s * o, this._w = n * r * o - a * s * l) : "YXZ" === e.order ? (this._x = a * r * o + n * s * l, this._y = n * s * o - a * r * l, this._z = n * r * l - a * s * o, this._w = n * r * o + a * s * l) : "ZXY" === e.order ? (this._x = a * r * o - n * s * l, this._y = n * s * o + a * r * l, this._z = n * r * l + a * s * o, this._w = n * r * o - a * s * l) : "ZYX" === e.order ? (this._x = a * r * o - n * s * l, this._y = n * s * o + a * r * l, this._z = n * r * l - a * s * o, this._w = n * r * o + a * s * l) : "YZX" === e.order ? (this._x = a * r * o + n * s * l, this._y = n * s * o + a * r * l, this._z = n * r * l - a * s * o, this._w = n * r * o - a * s * l) : "XZY" === e.order && (this._x = a * r * o - n * s * l, this._y = n * s * o - a * r * l, this._z = n * r * l + a * s * o, this._w = n * r * o + a * s * l), t !== !1 && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(e, t) {
                    var n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(e) {
                    var t, n = e.elements,
                        i = n[0],
                        r = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        l = n[9],
                        c = n[2],
                        h = n[6],
                        u = n[10],
                        f = i + s + u;
                    return f > 0 ? (t = .5 / Math.sqrt(f + 1), this._w = .25 / t, this._x = (h - l) * t, this._y = (o - c) * t, this._z = (a - r) * t) : i > s && i > u ? (t = 2 * Math.sqrt(1 + i - s - u), this._w = (h - l) / t, this._x = .25 * t, this._y = (r + a) / t, this._z = (o + c) / t) : s > u ? (t = 2 * Math.sqrt(1 + s - i - u), this._w = (o - c) / t, this._x = (r + a) / t, this._y = .25 * t, this._z = (l + h) / t) : (t = 2 * Math.sqrt(1 + u - i - s), this._w = (a - r) / t, this._x = (o + c) / t, this._y = (l + h) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var e, t, n = 1e-6;
                    return function(r, o) {
                        return void 0 === e && (e = new i.Vector3), t = r.dot(o) + 1, n > t ? (t = 0, Math.abs(r.x) > Math.abs(r.z) ? e.set(-r.y, r.x, 0) : e.set(0, -r.z, r.y)) : e.crossVectors(r, o), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize(), this
                    }
                }(),
                inverse: function() {
                    return this.conjugate().normalize(), this
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                multiplyQuaternions: function(e, t) {
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + o * a + i * l - r * s, this._y = i * c + o * s + r * a - n * l, this._z = r * c + o * l + n * s - i * a, this._w = o * c - n * a - i * s - r * l, this.onChangeCallback(), this
                },
                multiplyVector3: function(e) {
                    return i.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
                },
                slerp: function(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * e._w + n * e._x + i * e._y + r * e._z;
                    if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                    var s = Math.acos(a),
                        l = Math.sqrt(1 - a * a);
                    if (Math.abs(l) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (i + this._y), this._z = .5 * (r + this._z), this;
                    var c = Math.sin((1 - t) * s) / l,
                        h = Math.sin(t * s) / l;
                    return this._w = o * c + this._w * h, this._x = n * c + this._x * h, this._y = i * c + this._y * h, this._z = r * c + this._z * h, this.onChangeCallback(), this
                },
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                onChange: function(e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function() {},
                clone: function() {
                    return new i.Quaternion(this._x, this._y, this._z, this._w)
                }
            }, i.Quaternion.slerp = function(e, t, n, i) {
                return n.copy(e).slerp(t, i)
            }, i.Vector2 = function(e, t) {
                this.x = e || 0, this.y = t || 0
            }, i.Vector2.prototype = {
                constructor: i.Vector2,
                set: function(e, t) {
                    return this.x = e, this.y = t, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function(e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function(e) {
                    if (0 !== e) {
                        var t = 1 / e;
                        this.x *= t, this.y *= t
                    } else this.x = 0, this.y = 0;
                    return this
                },
                min: function(e) {
                    return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
                },
                max: function(e) {
                    return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
                },
                clamp: function(e, t) {
                    return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(n, r) {
                        return void 0 === e && (e = new i.Vector2, t = new i.Vector2), e.set(n, n), t.set(r, r), this.clamp(e, t)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                setLength: function(e) {
                    var t = this.length();
                    return 0 !== t && e !== t && this.multiplyScalar(e / t), this
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e), this
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromAttribute: function(e, t, n) {
                    return void 0 === n && (n = 0), t = t * e.itemSize + n, this.x = e.array[t], this.y = e.array[t + 1], this
                },
                clone: function() {
                    return new i.Vector2(this.x, this.y)
                }
            }, i.Vector3 = function(e, t, n) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0
            }, i.Vector3.prototype = {
                constructor: i.Vector3,
                set: function(e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                },
                multiplyVectors: function(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: function() {
                    var e;
                    return function(t) {
                        return t instanceof i.Euler == !1 && i.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === e && (e = new i.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
                    }
                }(),
                applyAxisAngle: function() {
                    var e;
                    return function(t, n) {
                        return void 0 === e && (e = new i.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, n)), this
                    }
                }(),
                applyMatrix3: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i + r[12], this.y = r[1] * t + r[5] * n + r[9] * i + r[13], this.z = r[2] * t + r[6] * n + r[10] * i + r[14], this
                },
                applyProjection: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this
                },
                applyQuaternion: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        o = e.y,
                        a = e.z,
                        s = e.w,
                        l = s * t + o * i - a * n,
                        c = s * n + a * t - r * i,
                        h = s * i + r * n - o * t,
                        u = -r * t - o * n - a * i;
                    return this.x = l * s + u * -r + c * -a - h * -o, this.y = c * s + u * -o + h * -r - l * -a, this.z = h * s + u * -a + l * -o - c * -r, this
                },
                project: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new i.Matrix4), e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyProjection(e)
                    }
                }(),
                unproject: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new i.Matrix4), e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyProjection(e)
                    }
                }(),
                transformDirection: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize(), this
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function(e) {
                    if (0 !== e) {
                        var t = 1 / e;
                        this.x *= t, this.y *= t, this.z *= t
                    } else this.x = 0, this.y = 0, this.z = 0;
                    return this
                },
                min: function(e) {
                    return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
                },
                max: function(e) {
                    return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
                },
                clamp: function(e, t) {
                    return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(n, r) {
                        return void 0 === e && (e = new i.Vector3, t = new i.Vector3), e.set(n, n, n), t.set(r, r, r), this.clamp(e, t)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(e) {
                    var t = this.length();
                    return 0 !== t && e !== t && this.multiplyScalar(e / t), this
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e), this
                },
                cross: function(e, t) {
                    if (void 0 !== t) return i.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
                    var n = this.x,
                        r = this.y,
                        o = this.z;
                    return this.x = r * e.z - o * e.y, this.y = o * e.x - n * e.z, this.z = n * e.y - r * e.x, this
                },
                crossVectors: function(e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z,
                        o = t.x,
                        a = t.y,
                        s = t.z;
                    return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
                },
                projectOnVector: function() {
                    var e, t;
                    return function(n) {
                        return void 0 === e && (e = new i.Vector3), e.copy(n).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
                    }
                }(),
                projectOnPlane: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new i.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
                    }
                }(),
                reflect: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new i.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                }(),
                angleTo: function(e) {
                    var t = this.dot(e) / (this.length() * e.length());
                    return Math.acos(i.Math.clamp(t, -1, 1))
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                },
                setEulerFromRotationMatrix: function(e, t) {
                    i.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function(e, t) {
                    i.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(e) {
                    return i.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function(e) {
                    return i.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function(e, t) {
                    return i.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                setFromMatrixPosition: function(e) {
                    return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
                },
                setFromMatrixScale: function(e) {
                    var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
                        n = this.set(e.elements[4], e.elements[5], e.elements[6]).length(),
                        i = this.set(e.elements[8], e.elements[9], e.elements[10]).length();
                    return this.x = t, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function(e, t) {
                    var n = 4 * e,
                        i = t.elements;
                    return this.x = i[n], this.y = i[n + 1], this.z = i[n + 2], this
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromAttribute: function(e, t, n) {
                    return void 0 === n && (n = 0), t = t * e.itemSize + n, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this
                },
                clone: function() {
                    return new i.Vector3(this.x, this.y, this.z)
                }
            }, i.Vector4 = function(e, t, n, i) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }, i.Vector4.prototype = {
                constructor: i.Vector4,
                set: function(e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setW: function(e) {
                    return this.w = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        o = e.elements;
                    return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this
                },
                divideScalar: function(e) {
                    if (0 !== e) {
                        var t = 1 / e;
                        this.x *= t, this.y *= t, this.z *= t, this.w *= t
                    } else this.x = 0, this.y = 0, this.z = 0, this.w = 1;
                    return this
                },
                setAxisAngleFromQuaternion: function(e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return 1e-4 > t ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function(e) {
                    var t, n, i, r, o = .01,
                        a = .1,
                        s = e.elements,
                        l = s[0],
                        c = s[4],
                        h = s[8],
                        u = s[1],
                        f = s[5],
                        d = s[9],
                        p = s[2],
                        m = s[6],
                        v = s[10];
                    if (Math.abs(c - u) < o && Math.abs(h - p) < o && Math.abs(d - m) < o) {
                        if (Math.abs(c + u) < a && Math.abs(h + p) < a && Math.abs(d + m) < a && Math.abs(l + f + v - 3) < a) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var g = (l + 1) / 2,
                            y = (f + 1) / 2,
                            x = (v + 1) / 2,
                            w = (c + u) / 4,
                            _ = (h + p) / 4,
                            b = (d + m) / 4;
                        return g > y && g > x ? o > g ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(g), i = w / n, r = _ / n) : y > x ? o > y ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(y), n = w / i, r = b / i) : o > x ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(x), n = _ / r, i = b / r), this.set(n, i, r, t), this
                    }
                    var E = Math.sqrt((m - d) * (m - d) + (h - p) * (h - p) + (u - c) * (u - c));
                    return Math.abs(E) < .001 && (E = 1), this.x = (m - d) / E, this.y = (h - p) / E, this.z = (u - c) / E, this.w = Math.acos((l + f + v - 1) / 2), this
                },
                min: function(e) {
                    return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
                },
                max: function(e) {
                    return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
                },
                clamp: function(e, t) {
                    return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(n, r) {
                        return void 0 === e && (e = new i.Vector4, t = new i.Vector4), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(e) {
                    var t = this.length();
                    return 0 !== t && e !== t && this.multiplyScalar(e / t), this
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function(e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e), this
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromAttribute: function(e, t, n) {
                    return void 0 === n && (n = 0), t = t * e.itemSize + n, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this.w = e.array[t + 3], this
                },
                clone: function() {
                    return new i.Vector4(this.x, this.y, this.z, this.w)
                }
            }, i.Euler = function(e, t, n, r) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || i.Euler.DefaultOrder
            }, i.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], i.Euler.DefaultOrder = "XYZ", i.Euler.prototype = {
                constructor: i.Euler,
                _x: 0,
                _y: 0,
                _z: 0,
                _order: i.Euler.DefaultOrder,
                get x() {
                    return this._x
                },
                set x(e) {
                    this._x = e, this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(e) {
                    this._y = e, this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(e) {
                    this._z = e, this.onChangeCallback()
                },
                get order() {
                    return this._order
                },
                set order(e) {
                    this._order = e, this.onChangeCallback()
                },
                set: function(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                copy: function(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(e, t, n) {
                    var r = i.Math.clamp,
                        o = e.elements,
                        a = o[0],
                        s = o[4],
                        l = o[8],
                        c = o[1],
                        h = o[5],
                        u = o[9],
                        f = o[2],
                        d = o[6],
                        p = o[10];
                    return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(r(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(d, h), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(l, p), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-f, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === t ? (this._y = Math.asin(-r(f, -1, 1)), Math.abs(f) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-s, h))) : "YZX" === t ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-f, a)) : (this._x = 0, this._y = Math.atan2(l, p))) : "XZY" === t ? (this._z = Math.asin(-r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(d, h), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : i.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, n !== !1 && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var e;
                    return function(t, n, r) {
                        return void 0 === e && (e = new i.Matrix4), e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, r), this
                    }
                }(),
                setFromVector3: function(e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: function() {
                    var e = new i.Quaternion;
                    return function(t) {
                        e.setFromEuler(this), this.setFromQuaternion(e, t)
                    }
                }(),
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function(e) {
                    return e ? e.set(this._x, this._y, this._z) : new i.Vector3(this._x, this._y, this._z)
                },
                onChange: function(e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function() {},
                clone: function() {
                    return new i.Euler(this._x, this._y, this._z, this._order)
                }
            }, i.Line3 = function(e, t) {
                this.start = void 0 !== e ? e : new i.Vector3, this.end = void 0 !== t ? t : new i.Vector3
            }, i.Line3.prototype = {
                constructor: i.Line3,
                set: function(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                copy: function(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                center: function(e) {
                    var t = e || new i.Vector3;
                    return t.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(e) {
                    var t = e || new i.Vector3;
                    return t.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(e, t) {
                    var n = t || new i.Vector3;
                    return this.delta(n).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3;
                    return function(n, r) {
                        e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                        var o = t.dot(t),
                            a = t.dot(e),
                            s = a / o;
                        return r && (s = i.Math.clamp(s, 0, 1)), s
                    }
                }(),
                closestPointToPoint: function(e, t, n) {
                    var r = this.closestPointToPointParameter(e, t),
                        o = n || new i.Vector3;
                    return this.delta(o).multiplyScalar(r).add(this.start)
                },
                applyMatrix4: function(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                },
                clone: function() {
                    return (new i.Line3).copy(this)
                }
            }, i.Box2 = function(e, t) {
                this.min = void 0 !== e ? e : new i.Vector2(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i.Vector2(-(1 / 0), -(1 / 0))
            }, i.Box2.prototype = {
                constructor: i.Box2,
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; n > t; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var e = new i.Vector2;
                    return function(t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
                },
                empty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                center: function(e) {
                    var t = e || new i.Vector2;
                    return t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(e) {
                    var t = e || new i.Vector2;
                    return t.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function(e, t) {
                    var n = t || new i.Vector2;
                    return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                isIntersectionBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function(e, t) {
                    var n = t || new i.Vector2;
                    return n.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var e = new i.Vector2;
                    return function(t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                },
                clone: function() {
                    return (new i.Box2).copy(this)
                }
            }, i.Box3 = function(e, t) {
                this.min = void 0 !== e ? e : new i.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i.Vector3(-(1 / 0), -(1 / 0), -(1 / 0))
            }, i.Box3.prototype = {
                constructor: i.Box3,
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; n > t; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var e = new i.Vector3;
                    return function(t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                setFromObject: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        var n = this;
                        return t.updateMatrixWorld(!0), this.makeEmpty(), t.traverse(function(t) {
                            var r = t.geometry;
                            if (void 0 !== r)
                                if (r instanceof i.Geometry)
                                    for (var o = r.vertices, a = 0, s = o.length; s > a; a++) e.copy(o[a]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e);
                                else if (r instanceof i.BufferGeometry && void 0 !== r.attributes.position)
                                    for (var l = r.attributes.position.array, a = 0, s = l.length; s > a; a += 3) e.set(l[a], l[a + 1], l[a + 2]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e)
                        }), this
                    }
                }(),
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
                },
                empty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                center: function(e) {
                    var t = e || new i.Vector3;
                    return t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(e) {
                    var t = e || new i.Vector3;
                    return t.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function(e, t) {
                    var n = t || new i.Vector3;
                    return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                isIntersectionBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                clampPoint: function(e, t) {
                    var n = t || new i.Vector3;
                    return n.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        var n = t || new i.Sphere;
                        return n.center = this.center(), n.radius = .5 * this.size(e).length(), n
                    }
                }(),
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: function() {
                    var e = [new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3, new i.Vector3];
                    return function(t) {
                        return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
                    }
                }(),
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                },
                clone: function() {
                    return (new i.Box3).copy(this)
                }
            }, i.Matrix3 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && i.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }, i.Matrix3.prototype = {
                constructor: i.Matrix3,
                set: function(e, t, n, i, r, o, a, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[3] = t, c[6] = n, c[1] = i, c[4] = r, c[7] = o, c[2] = a, c[5] = s, c[8] = l, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                copy: function(e) {
                    var t = e.elements;
                    return this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this
                },
                multiplyVector3: function(e) {
                    return i.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                },
                multiplyVector3Array: function(e) {
                    return i.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
                },
                applyToVector3Array: function() {
                    var e = new i.Vector3;
                    return function(t, n, i) {
                        void 0 === n && (n = 0), void 0 === i && (i = t.length);
                        for (var r = 0, o = n; i > r; r += 3, o += 3) e.x = t[o], e.y = t[o + 1], e.z = t[o + 2], e.applyMatrix3(this), t[o] = e.x, t[o + 1] = e.y, t[o + 2] = e.z;
                        return t
                    }
                }(),
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        o = e[4],
                        a = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * o * c - t * a * l - n * r * c + n * a * s + i * r * l - i * o * s
                },
                getInverse: function(e, t) {
                    var n = e.elements,
                        r = this.elements;
                    r[0] = n[10] * n[5] - n[6] * n[9], r[1] = -n[10] * n[1] + n[2] * n[9], r[2] = n[6] * n[1] - n[2] * n[5], r[3] = -n[10] * n[4] + n[6] * n[8], r[4] = n[10] * n[0] - n[2] * n[8], r[5] = -n[6] * n[0] + n[2] * n[4], r[6] = n[9] * n[4] - n[5] * n[8], r[7] = -n[9] * n[0] + n[1] * n[8], r[8] = n[5] * n[0] - n[1] * n[4];
                    var o = n[0] * r[0] + n[1] * r[3] + n[2] * r[6];
                    if (0 === o) {
                        var a = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                        if (t) throw new Error(a);
                        return i.warn(a), this.identity(), this
                    }
                    return this.multiplyScalar(1 / o), this
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                flattenToArrayOffset: function(e, t) {
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                },
                getNormalMatrix: function(e) {
                    return this.getInverse(e).transpose(), this
                },
                transposeIntoArray: function(e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                fromArray: function(e) {
                    return this.elements.set(e), this
                },
                toArray: function() {
                    var e = this.elements;
                    return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
                },
                clone: function() {
                    return (new i.Matrix3).fromArray(this.elements)
                }
            }, i.Matrix4 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && i.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }, i.Matrix4.prototype = {
                constructor: i.Matrix4,
                set: function(e, t, n, i, r, o, a, s, l, c, h, u, f, d, p, m) {
                    var v = this.elements;
                    return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = s, v[2] = l, v[6] = c, v[10] = h, v[14] = u, v[3] = f, v[7] = d, v[11] = p, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                copy: function(e) {
                    return this.elements.set(e.elements), this
                },
                extractPosition: function(e) {
                    return i.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                },
                copyPosition: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function(e, t, n) {
                    var i = this.elements;
                    return e.set(i[0], i[1], i[2]), t.set(i[4], i[5], i[6]), n.set(i[8], i[9], i[10]), this
                },
                makeBasis: function(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        var n = this.elements,
                            i = t.elements,
                            r = 1 / e.set(i[0], i[1], i[2]).length(),
                            o = 1 / e.set(i[4], i[5], i[6]).length(),
                            a = 1 / e.set(i[8], i[9], i[10]).length();
                        return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, this
                    }
                }(),
                makeRotationFromEuler: function(e) {
                    e instanceof i.Euler == !1 && i.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        o = e.z,
                        a = Math.cos(n),
                        s = Math.sin(n),
                        l = Math.cos(r),
                        c = Math.sin(r),
                        h = Math.cos(o),
                        u = Math.sin(o);
                    if ("XYZ" === e.order) {
                        var f = a * h,
                            d = a * u,
                            p = s * h,
                            m = s * u;
                        t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = d + p * c, t[5] = f - m * c, t[9] = -s * l, t[2] = m - f * c, t[6] = p + d * c, t[10] = a * l
                    } else if ("YXZ" === e.order) {
                        var v = l * h,
                            g = l * u,
                            y = c * h,
                            x = c * u;
                        t[0] = v + x * s, t[4] = y * s - g, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -s, t[2] = g * s - y, t[6] = x + v * s, t[10] = a * l
                    } else if ("ZXY" === e.order) {
                        var v = l * h,
                            g = l * u,
                            y = c * h,
                            x = c * u;
                        t[0] = v - x * s, t[4] = -a * u, t[8] = y + g * s, t[1] = g + y * s, t[5] = a * h, t[9] = x - v * s, t[2] = -a * c, t[6] = s, t[10] = a * l
                    } else if ("ZYX" === e.order) {
                        var f = a * h,
                            d = a * u,
                            p = s * h,
                            m = s * u;
                        t[0] = l * h, t[4] = p * c - d, t[8] = f * c + m, t[1] = l * u, t[5] = m * c + f, t[9] = d * c - p, t[2] = -c, t[6] = s * l, t[10] = a * l
                    } else if ("YZX" === e.order) {
                        var w = a * l,
                            _ = a * c,
                            b = s * l,
                            E = s * c;
                        t[0] = l * h, t[4] = E - w * u, t[8] = b * u + _, t[1] = u, t[5] = a * h, t[9] = -s * h, t[2] = -c * h, t[6] = _ * u + b, t[10] = w - E * u
                    } else if ("XZY" === e.order) {
                        var w = a * l,
                            _ = a * c,
                            b = s * l,
                            E = s * c;
                        t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = w * u + E, t[5] = a * h, t[9] = _ * u - b, t[2] = b * u - _, t[6] = s * h, t[10] = E * u + w
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                setRotationFromQuaternion: function(e) {
                    return i.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                },
                makeRotationFromQuaternion: function(e) {
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        o = e.w,
                        a = n + n,
                        s = i + i,
                        l = r + r,
                        c = n * a,
                        h = n * s,
                        u = n * l,
                        f = i * s,
                        d = i * l,
                        p = r * l,
                        m = o * a,
                        v = o * s,
                        g = o * l;
                    return t[0] = 1 - (f + p), t[4] = h - g, t[8] = u + v, t[1] = h + g, t[5] = 1 - (c + p), t[9] = d - m, t[2] = u - v, t[6] = d + m, t[10] = 1 - (c + f), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                lookAt: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3,
                        n = new i.Vector3;
                    return function(i, r, o) {
                        var a = this.elements;
                        return n.subVectors(i, r).normalize(), 0 === n.length() && (n.z = 1), e.crossVectors(o, n).normalize(), 0 === e.length() && (n.x += 1e-4, e.crossVectors(o, n).normalize()), t.crossVectors(n, e), a[0] = e.x, a[4] = t.x, a[8] = n.x, a[1] = e.y, a[5] = t.y, a[9] = n.y, a[2] = e.z, a[6] = t.z, a[10] = n.z, this
                    }
                }(),
                multiply: function(e, t) {
                    return void 0 !== t ? (i.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                multiplyMatrices: function(e, t) {
                    var n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        h = n[5],
                        u = n[9],
                        f = n[13],
                        d = n[2],
                        p = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        w = n[15],
                        _ = i[0],
                        b = i[4],
                        E = i[8],
                        M = i[12],
                        S = i[1],
                        T = i[5],
                        C = i[9],
                        A = i[13],
                        P = i[2],
                        D = i[6],
                        L = i[10],
                        R = i[14],
                        O = i[3],
                        N = i[7],
                        U = i[11],
                        F = i[15];
                    return r[0] = o * _ + a * S + s * P + l * O, r[4] = o * b + a * T + s * D + l * N, r[8] = o * E + a * C + s * L + l * U, r[12] = o * M + a * A + s * R + l * F, r[1] = c * _ + h * S + u * P + f * O, r[5] = c * b + h * T + u * D + f * N, r[9] = c * E + h * C + u * L + f * U, r[13] = c * M + h * A + u * R + f * F, r[2] = d * _ + p * S + m * P + v * O, r[6] = d * b + p * T + m * D + v * N, r[10] = d * E + p * C + m * L + v * U, r[14] = d * M + p * A + m * R + v * F, r[3] = g * _ + y * S + x * P + w * O, r[7] = g * b + y * T + x * D + w * N, r[11] = g * E + y * C + x * L + w * U, r[15] = g * M + y * A + x * R + w * F, this
                },
                multiplyToArray: function(e, t, n) {
                    var i = this.elements;
                    return this.multiplyMatrices(e, t), n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this
                },
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                multiplyVector3: function(e) {
                    return i.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
                },
                multiplyVector4: function(e) {
                    return i.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector3Array: function(e) {
                    return i.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
                },
                applyToVector3Array: function() {
                    var e = new i.Vector3;
                    return function(t, n, i) {
                        void 0 === n && (n = 0), void 0 === i && (i = t.length);
                        for (var r = 0, o = n; i > r; r += 3, o += 3) e.x = t[o], e.y = t[o + 1], e.z = t[o + 2], e.applyMatrix4(this), t[o] = e.x, t[o + 1] = e.y, t[o + 2] = e.z;
                        return t
                    }
                }(),
                rotateAxis: function(e) {
                    i.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                },
                crossVector: function(e) {
                    return i.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        h = e[6],
                        u = e[10],
                        f = e[14],
                        d = e[3],
                        p = e[7],
                        m = e[11],
                        v = e[15];
                    return d * (+r * s * h - i * l * h - r * a * u + n * l * u + i * a * f - n * s * f) + p * (+t * s * f - t * l * u + r * o * u - i * o * f + i * l * c - r * s * c) + m * (+t * l * h - t * a * f - r * o * h + n * o * f + r * a * c - n * l * c) + v * (-i * a * c - t * s * h + t * a * u + i * o * h - n * o * u + n * s * c)
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                flattenToArrayOffset: function(e, t) {
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                },
                getPosition: function() {
                    var e = new i.Vector3;
                    return function() {
                        i.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                        var t = this.elements;
                        return e.set(t[12], t[13], t[14])
                    }
                }(),
                setPosition: function(e) {
                    var t = this.elements;
                    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
                },
                getInverse: function(e, t) {
                    var n = this.elements,
                        r = e.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        l = r[12],
                        c = r[1],
                        h = r[5],
                        u = r[9],
                        f = r[13],
                        d = r[2],
                        p = r[6],
                        m = r[10],
                        v = r[14],
                        g = r[3],
                        y = r[7],
                        x = r[11],
                        w = r[15];
                    n[0] = u * v * y - f * m * y + f * p * x - h * v * x - u * p * w + h * m * w, n[4] = l * m * y - s * v * y - l * p * x + a * v * x + s * p * w - a * m * w, n[8] = s * f * y - l * u * y + l * h * x - a * f * x - s * h * w + a * u * w, n[12] = l * u * p - s * f * p - l * h * m + a * f * m + s * h * v - a * u * v, n[1] = f * m * g - u * v * g - f * d * x + c * v * x + u * d * w - c * m * w, n[5] = s * v * g - l * m * g + l * d * x - o * v * x - s * d * w + o * m * w, n[9] = l * u * g - s * f * g - l * c * x + o * f * x + s * c * w - o * u * w, n[13] = s * f * d - l * u * d + l * c * m - o * f * m - s * c * v + o * u * v, n[2] = h * v * g - f * p * g + f * d * y - c * v * y - h * d * w + c * p * w, n[6] = l * p * g - a * v * g - l * d * y + o * v * y + a * d * w - o * p * w, n[10] = a * f * g - l * h * g + l * c * y - o * f * y - a * c * w + o * h * w, n[14] = l * h * d - a * f * d - l * c * p + o * f * p + a * c * v - o * h * v, n[3] = u * p * g - h * m * g - u * d * y + c * m * y + h * d * x - c * p * x, n[7] = a * m * g - s * p * g + s * d * y - o * m * y - a * d * x + o * p * x, n[11] = s * h * g - a * u * g - s * c * y + o * u * y + a * c * x - o * h * x, n[15] = a * u * d - s * h * d + s * c * p - o * u * p - a * c * m + o * h * m;
                    var _ = o * n[0] + c * n[4] + d * n[8] + g * n[12];
                    if (0 == _) {
                        var b = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                        if (t) throw new Error(b);
                        return i.warn(b), this.identity(), this
                    }
                    return this.multiplyScalar(1 / _), this
                },
                translate: function(e) {
                    i.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function(e) {
                    i.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function(e) {
                    i.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function(e) {
                    i.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function(e, t) {
                    i.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                scale: function(e) {
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, Math.max(n, i)))
                },
                makeTranslation: function(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        o = e.x,
                        a = e.y,
                        s = e.z,
                        l = r * o,
                        c = r * a;
                    return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                compose: function(e, t, n) {
                    return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
                },
                decompose: function() {
                    var e = new i.Vector3,
                        t = new i.Matrix4;
                    return function(n, i, r) {
                        var o = this.elements,
                            a = e.set(o[0], o[1], o[2]).length(),
                            s = e.set(o[4], o[5], o[6]).length(),
                            l = e.set(o[8], o[9], o[10]).length(),
                            c = this.determinant();
                        0 > c && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], t.elements.set(this.elements);
                        var h = 1 / a,
                            u = 1 / s,
                            f = 1 / l;
                        return t.elements[0] *= h, t.elements[1] *= h, t.elements[2] *= h, t.elements[4] *= u, t.elements[5] *= u, t.elements[6] *= u, t.elements[8] *= f, t.elements[9] *= f, t.elements[10] *= f, i.setFromRotationMatrix(t), r.x = a, r.y = s, r.z = l, this
                    }
                }(),
                makeFrustum: function(e, t, n, i, r, o) {
                    var a = this.elements,
                        s = 2 * r / (t - e),
                        l = 2 * r / (i - n),
                        c = (t + e) / (t - e),
                        h = (i + n) / (i - n),
                        u = -(o + r) / (o - r),
                        f = -2 * o * r / (o - r);
                    return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makePerspective: function(e, t, n, r) {
                    var o = n * Math.tan(i.Math.degToRad(.5 * e)),
                        a = -o,
                        s = a * t,
                        l = o * t;
                    return this.makeFrustum(s, l, a, o, n, r)
                },
                makeOrthographic: function(e, t, n, i, r, o) {
                    var a = this.elements,
                        s = t - e,
                        l = n - i,
                        c = o - r,
                        h = (t + e) / s,
                        u = (n + i) / l,
                        f = (o + r) / c;
                    return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 / l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 / c, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                fromArray: function(e) {
                    return this.elements.set(e), this
                },
                toArray: function() {
                    var e = this.elements;
                    return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
                },
                clone: function() {
                    return (new i.Matrix4).fromArray(this.elements)
                }
            }, i.Ray = function(e, t) {
                this.origin = void 0 !== e ? e : new i.Vector3, this.direction = void 0 !== t ? t : new i.Vector3
            }, i.Ray.prototype = {
                constructor: i.Ray,
                set: function(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                copy: function(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function(e, t) {
                    var n = t || new i.Vector3;
                    return n.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                recast: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        return this.origin.copy(this.at(t, e)), this
                    }
                }(),
                closestPointToPoint: function(e, t) {
                    var n = t || new i.Vector3;
                    n.subVectors(e, this.origin);
                    var r = n.dot(this.direction);
                    return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
                },
                distanceToPoint: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        var n = e.subVectors(t, this.origin).dot(this.direction);
                        return 0 > n ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t))
                    }
                }(),
                distanceSqToSegment: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3,
                        n = new i.Vector3;
                    return function(i, r, o, a) {
                        e.copy(i).add(r).multiplyScalar(.5), t.copy(r).sub(i).normalize(), n.copy(this.origin).sub(e);
                        var s, l, c, h, u = .5 * i.distanceTo(r),
                            f = -this.direction.dot(t),
                            d = n.dot(this.direction),
                            p = -n.dot(t),
                            m = n.lengthSq(),
                            v = Math.abs(1 - f * f);
                        if (v > 0)
                            if (s = f * p - d, l = f * d - p, h = u * v, s >= 0)
                                if (l >= -h)
                                    if (h >= l) {
                                        var g = 1 / v;
                                        s *= g, l *= g, c = s * (s + f * l + 2 * d) + l * (f * s + l + 2 * p) + m
                                    } else l = u, s = Math.max(0, -(f * l + d)), c = -s * s + l * (l + 2 * p) + m;
                                else l = -u, s = Math.max(0, -(f * l + d)), c = -s * s + l * (l + 2 * p) + m;
                            else -h >= l ? (s = Math.max(0, -(-f * u + d)), l = s > 0 ? -u : Math.min(Math.max(-u, -p), u), c = -s * s + l * (l + 2 * p) + m) : h >= l ? (s = 0, l = Math.min(Math.max(-u, -p), u), c = l * (l + 2 * p) + m) : (s = Math.max(0, -(f * u + d)), l = s > 0 ? u : Math.min(Math.max(-u, -p), u), c = -s * s + l * (l + 2 * p) + m);
                        else l = f > 0 ? -u : u, s = Math.max(0, -(f * l + d)), c = -s * s + l * (l + 2 * p) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(t).multiplyScalar(l).add(e), c
                    }
                }(),
                isIntersectionSphere: function(e) {
                    return this.distanceToPoint(e.center) <= e.radius
                },
                intersectSphere: function() {
                    var e = new i.Vector3;
                    return function(t, n) {
                        e.subVectors(t.center, this.origin);
                        var i = e.dot(this.direction),
                            r = e.dot(e) - i * i,
                            o = t.radius * t.radius;
                        if (r > o) return null;
                        var a = Math.sqrt(o - r),
                            s = i - a,
                            l = i + a;
                        return 0 > s && 0 > l ? null : 0 > s ? this.at(l, n) : this.at(s, n)
                    }
                }(),
                isIntersectionPlane: function(e) {
                    var t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    var n = e.normal.dot(this.direction);
                    return 0 > n * t
                },
                distanceToPlane: function(e) {
                    var t = e.normal.dot(this.direction);
                    if (0 == t) return 0 == e.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(e, t) {
                    var n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                },
                isIntersectionBox: function() {
                    var e = new i.Vector3;
                    return function(t) {
                        return null !== this.intersectBox(t, e)
                    }
                }(),
                intersectBox: function(e, t) {
                    var n, i, r, o, a, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (n = (e.min.x - u.x) * l, i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, i = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, o = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, o = (e.min.y - u.y) * c), n > o || r > i ? null : ((r > n || n !== n) && (n = r), (i > o || i !== i) && (i = o), h >= 0 ? (a = (e.min.z - u.z) * h, s = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, s = (e.min.z - u.z) * h), n > s || a > i ? null : ((a > n || n !== n) && (n = a), (i > s || i !== i) && (i = s), 0 > i ? null : this.at(n >= 0 ? n : i, t)))
                },
                intersectTriangle: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3,
                        n = new i.Vector3,
                        r = new i.Vector3;
                    return function(i, o, a, s, l) {
                        t.subVectors(o, i), n.subVectors(a, i), r.crossVectors(t, n);
                        var c, h = this.direction.dot(r);
                        if (h > 0) {
                            if (s) return null;
                            c = 1
                        } else {
                            if (!(0 > h)) return null;
                            c = -1, h = -h
                        }
                        e.subVectors(this.origin, i);
                        var u = c * this.direction.dot(n.crossVectors(e, n));
                        if (0 > u) return null;
                        var f = c * this.direction.dot(t.cross(e));
                        if (0 > f) return null;
                        if (u + f > h) return null;
                        var d = -c * e.dot(r);
                        return 0 > d ? null : this.at(d / h, l)
                    }
                }(),
                applyMatrix4: function(e) {
                    return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
                },
                equals: function(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                },
                clone: function() {
                    return (new i.Ray).copy(this)
                }
            }, i.Sphere = function(e, t) {
                this.center = void 0 !== e ? e : new i.Vector3, this.radius = void 0 !== t ? t : 0
            }, i.Sphere.prototype = {
                constructor: i.Sphere,
                set: function(e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: function() {
                    var e = new i.Box3;
                    return function(t, n) {
                        var i = this.center;
                        void 0 !== n ? i.copy(n) : e.setFromPoints(t).center(i);
                        for (var r = 0, o = 0, a = t.length; a > o; o++) r = Math.max(r, i.distanceToSquared(t[o]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                copy: function(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                clampPoint: function(e, t) {
                    var n = this.center.distanceToSquared(e),
                        r = t || new i.Vector3;
                    return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
                },
                getBoundingBox: function(e) {
                    var t = e || new i.Box3;
                    return t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function(e) {
                    return this.center.add(e), this
                },
                equals: function(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                },
                clone: function() {
                    return (new i.Sphere).copy(this)
                }
            }, i.Frustum = function(e, t, n, r, o, a) {
                this.planes = [void 0 !== e ? e : new i.Plane, void 0 !== t ? t : new i.Plane, void 0 !== n ? n : new i.Plane, void 0 !== r ? r : new i.Plane, void 0 !== o ? o : new i.Plane, void 0 !== a ? a : new i.Plane]
            }, i.Frustum.prototype = {
                constructor: i.Frustum,
                set: function(e, t, n, i, r, o) {
                    var a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
                },
                copy: function(e) {
                    for (var t = this.planes, n = 0; 6 > n; n++) t[n].copy(e.planes[n]);
                    return this
                },
                setFromMatrix: function(e) {
                    var t = this.planes,
                        n = e.elements,
                        i = n[0],
                        r = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        h = n[7],
                        u = n[8],
                        f = n[9],
                        d = n[10],
                        p = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return t[0].setComponents(a - i, h - s, p - u, y - m).normalize(), t[1].setComponents(a + i, h + s, p + u, y + m).normalize(), t[2].setComponents(a + r, h + l, p + f, y + v).normalize(), t[3].setComponents(a - r, h - l, p - f, y - v).normalize(),
                        t[4].setComponents(a - o, h - c, p - d, y - g).normalize(), t[5].setComponents(a + o, h + c, p + d, y + g).normalize(), this
                },
                intersectsObject: function() {
                    var e = new i.Sphere;
                    return function(t) {
                        var n = t.geometry;
                        return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSphere: function(e) {
                    for (var t = this.planes, n = e.center, i = -e.radius, r = 0; 6 > r; r++) {
                        var o = t[r].distanceToPoint(n);
                        if (i > o) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3;
                    return function(n) {
                        for (var i = this.planes, r = 0; 6 > r; r++) {
                            var o = i[r];
                            e.x = o.normal.x > 0 ? n.min.x : n.max.x, t.x = o.normal.x > 0 ? n.max.x : n.min.x, e.y = o.normal.y > 0 ? n.min.y : n.max.y, t.y = o.normal.y > 0 ? n.max.y : n.min.y, e.z = o.normal.z > 0 ? n.min.z : n.max.z, t.z = o.normal.z > 0 ? n.max.z : n.min.z;
                            var a = o.distanceToPoint(e),
                                s = o.distanceToPoint(t);
                            if (0 > a && 0 > s) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(e) {
                    for (var t = this.planes, n = 0; 6 > n; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                },
                clone: function() {
                    return (new i.Frustum).copy(this)
                }
            }, i.Plane = function(e, t) {
                this.normal = void 0 !== e ? e : new i.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }, i.Plane.prototype = {
                constructor: i.Plane,
                set: function(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function(e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3;
                    return function(n, i, r) {
                        var o = e.subVectors(r, i).cross(t.subVectors(n, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, n), this
                    }
                }(),
                copy: function(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function() {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function(e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function(e, t) {
                    return this.orthoPoint(e, t).sub(e).negate()
                },
                orthoPoint: function(e, t) {
                    var n = this.distanceToPoint(e),
                        r = t || new i.Vector3;
                    return r.copy(this.normal).multiplyScalar(n)
                },
                isIntersectionLine: function(e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return 0 > t && n > 0 || 0 > n && t > 0
                },
                intersectLine: function() {
                    var e = new i.Vector3;
                    return function(t, n) {
                        var r = n || new i.Vector3,
                            o = t.delta(e),
                            a = this.normal.dot(o);
                        if (0 != a) {
                            var s = -(t.start.dot(this.normal) + this.constant) / a;
                            if (!(0 > s || s > 1)) return r.copy(o).multiplyScalar(s).add(t.start)
                        } else if (0 == this.distanceToPoint(t.start)) return r.copy(t.start)
                    }
                }(),
                coplanarPoint: function(e) {
                    var t = e || new i.Vector3;
                    return t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3,
                        n = new i.Matrix3;
                    return function(i, r) {
                        var o = r || n.getNormalMatrix(i),
                            a = e.copy(this.normal).applyMatrix3(o),
                            s = this.coplanarPoint(t);
                        return s.applyMatrix4(i), this.setFromNormalAndCoplanarPoint(a, s), this
                    }
                }(),
                translate: function(e) {
                    return this.constant = this.constant - e.dot(this.normal), this
                },
                equals: function(e) {
                    return e.normal.equals(this.normal) && e.constant == this.constant
                },
                clone: function() {
                    return (new i.Plane).copy(this)
                }
            }, i.Math = {
                generateUUID: function() {
                    var e, t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                        n = new Array(36),
                        i = 0;
                    return function() {
                        for (var r = 0; 36 > r; r++) 8 == r || 13 == r || 18 == r || 23 == r ? n[r] = "-" : 14 == r ? n[r] = "4" : (2 >= i && (i = 33554432 + 16777216 * Math.random() | 0), e = 15 & i, i >>= 4, n[r] = t[19 == r ? 3 & e | 8 : e]);
                        return n.join("")
                    }
                }(),
                clamp: function(e, t, n) {
                    return t > e ? t : e > n ? n : e
                },
                clampBottom: function(e, t) {
                    return t > e ? t : e
                },
                mapLinear: function(e, t, n, i, r) {
                    return i + (e - t) * (r - i) / (n - t)
                },
                smoothstep: function(e, t, n) {
                    return t >= e ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
                },
                smootherstep: function(e, t, n) {
                    return t >= e ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
                },
                random16: function() {
                    return (65280 * Math.random() + 255 * Math.random()) / 65535
                },
                randInt: function(e, t) {
                    return Math.floor(this.randFloat(e, t))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                degToRad: function() {
                    var e = Math.PI / 180;
                    return function(t) {
                        return t * e
                    }
                }(),
                radToDeg: function() {
                    var e = 180 / Math.PI;
                    return function(t) {
                        return t * e
                    }
                }(),
                isPowerOfTwo: function(e) {
                    return 0 === (e & e - 1) && 0 !== e
                },
                nextPowerOfTwo: function(e) {
                    return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e
                }
            }, i.Spline = function(e) {
                function t(e, t, n, i, r, o, a) {
                    var s = .5 * (n - e),
                        l = .5 * (i - t);
                    return (2 * (t - n) + s + l) * a + (-3 * (t - n) - 2 * s - l) * o + s * r + t
                }
                this.points = e;
                var n, r, o, a, s, l, c, h, u, f = [],
                    d = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                this.initFromArray = function(e) {
                    this.points = [];
                    for (var t = 0; t < e.length; t++) this.points[t] = {
                        x: e[t][0],
                        y: e[t][1],
                        z: e[t][2]
                    }
                }, this.getPoint = function(e) {
                    return n = (this.points.length - 1) * e, r = Math.floor(n), o = n - r, f[0] = 0 === r ? r : r - 1, f[1] = r, f[2] = r > this.points.length - 2 ? this.points.length - 1 : r + 1, f[3] = r > this.points.length - 3 ? this.points.length - 1 : r + 2, l = this.points[f[0]], c = this.points[f[1]], h = this.points[f[2]], u = this.points[f[3]], a = o * o, s = o * a, d.x = t(l.x, c.x, h.x, u.x, o, a, s), d.y = t(l.y, c.y, h.y, u.y, o, a, s), d.z = t(l.z, c.z, h.z, u.z, o, a, s), d
                }, this.getControlPointsArray = function() {
                    var e, t, n = this.points.length,
                        i = [];
                    for (e = 0; n > e; e++) t = this.points[e], i[e] = [t.x, t.y, t.z];
                    return i
                }, this.getLength = function(e) {
                    var t, n, r, o, a = 0,
                        s = 0,
                        l = 0,
                        c = new i.Vector3,
                        h = new i.Vector3,
                        u = [],
                        f = 0;
                    for (u[0] = 0, e || (e = 100), r = this.points.length * e, c.copy(this.points[0]), t = 1; r > t; t++) n = t / r, o = this.getPoint(n), h.copy(o), f += h.distanceTo(c), c.copy(o), a = (this.points.length - 1) * n, s = Math.floor(a), s != l && (u[s] = f, l = s);
                    return u[u.length] = f, {
                        chunks: u,
                        total: f
                    }
                }, this.reparametrizeByArcLength = function(e) {
                    var t, n, r, o, a, s, l, c, h = [],
                        u = new i.Vector3,
                        f = this.getLength();
                    for (h.push(u.copy(this.points[0]).clone()), t = 1; t < this.points.length; t++) {
                        for (s = f.chunks[t] - f.chunks[t - 1], l = Math.ceil(e * s / f.total), o = (t - 1) / (this.points.length - 1), a = t / (this.points.length - 1), n = 1; l - 1 > n; n++) r = o + n * (1 / l) * (a - o), c = this.getPoint(r), h.push(u.copy(c).clone());
                        h.push(u.copy(this.points[t]).clone())
                    }
                    this.points = h
                }
            }, i.Triangle = function(e, t, n) {
                this.a = void 0 !== e ? e : new i.Vector3, this.b = void 0 !== t ? t : new i.Vector3, this.c = void 0 !== n ? n : new i.Vector3
            }, i.Triangle.normal = function() {
                var e = new i.Vector3;
                return function(t, n, r, o) {
                    var a = o || new i.Vector3;
                    a.subVectors(r, n), e.subVectors(t, n), a.cross(e);
                    var s = a.lengthSq();
                    return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0)
                }
            }(), i.Triangle.barycoordFromPoint = function() {
                var e = new i.Vector3,
                    t = new i.Vector3,
                    n = new i.Vector3;
                return function(r, o, a, s, l) {
                    e.subVectors(s, o), t.subVectors(a, o), n.subVectors(r, o);
                    var c = e.dot(e),
                        h = e.dot(t),
                        u = e.dot(n),
                        f = t.dot(t),
                        d = t.dot(n),
                        p = c * f - h * h,
                        m = l || new i.Vector3;
                    if (0 == p) return m.set(-2, -1, -1);
                    var v = 1 / p,
                        g = (f * u - h * d) * v,
                        y = (c * d - h * u) * v;
                    return m.set(1 - g - y, y, g)
                }
            }(), i.Triangle.containsPoint = function() {
                var e = new i.Vector3;
                return function(t, n, r, o) {
                    var a = i.Triangle.barycoordFromPoint(t, n, r, o, e);
                    return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1
                }
            }(), i.Triangle.prototype = {
                constructor: i.Triangle,
                set: function(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                },
                copy: function(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                area: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3;
                    return function() {
                        return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
                    }
                }(),
                midpoint: function(e) {
                    var t = e || new i.Vector3;
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(e) {
                    return i.Triangle.normal(this.a, this.b, this.c, e)
                },
                plane: function(e) {
                    var t = e || new i.Plane;
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(e, t) {
                    return i.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
                },
                containsPoint: function(e) {
                    return i.Triangle.containsPoint(e, this.a, this.b, this.c)
                },
                equals: function(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                },
                clone: function() {
                    return (new i.Triangle).copy(this)
                }
            }, i.Clock = function(e) {
                this.autoStart = void 0 !== e ? e : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }, i.Clock.prototype = {
                constructor: i.Clock,
                start: function() {
                    this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.oldTime = this.startTime, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var e = 0;
                    if (this.autoStart && !this.running && this.start(), this.running) {
                        var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
                        e = .001 * (t - this.oldTime), this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }, i.EventDispatcher = function() {}, i.EventDispatcher.prototype = {
                constructor: i.EventDispatcher,
                apply: function(e) {
                    e.addEventListener = i.EventDispatcher.prototype.addEventListener, e.hasEventListener = i.EventDispatcher.prototype.hasEventListener, e.removeEventListener = i.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = i.EventDispatcher.prototype.dispatchEvent
                },
                addEventListener: function(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                },
                hasEventListener: function(e, t) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                },
                removeEventListener: function(e, t) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners,
                            i = n[e];
                        if (void 0 !== i) {
                            var r = i.indexOf(t); - 1 !== r && i.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function(e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners,
                            n = t[e.type];
                        if (void 0 !== n) {
                            e.target = this;
                            for (var i = [], r = n.length, o = 0; r > o; o++) i[o] = n[o];
                            for (var o = 0; r > o; o++) i[o].call(this, e)
                        }
                    }
                }
            },
            function(e) {
                e.Raycaster = function(t, n, i, r) {
                    this.ray = new e.Ray(t, n), this.near = i || 0, this.far = r || 1 / 0, this.params = {
                        Sprite: {},
                        Mesh: {},
                        PointCloud: {
                            threshold: 1
                        },
                        LOD: {},
                        Line: {}
                    }
                };
                var t = function(e, t) {
                        return e.distance - t.distance
                    },
                    n = function(e, t, i, r) {
                        if (e.raycast(t, i), r === !0)
                            for (var o = e.children, a = 0, s = o.length; s > a; a++) n(o[a], t, i, !0)
                    };
                e.Raycaster.prototype = {
                    constructor: e.Raycaster,
                    precision: 1e-4,
                    linePrecision: 1,
                    set: function(e, t) {
                        this.ray.set(e, t)
                    },
                    setFromCamera: function(t, n) {
                        n instanceof e.PerspectiveCamera ? (this.ray.origin.copy(n.position), this.ray.direction.set(t.x, t.y, .5).unproject(n).sub(n.position).normalize()) : n instanceof e.OrthographicCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld)) : e.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(e, i) {
                        var r = [];
                        return n(e, this, r, i), r.sort(t), r
                    },
                    intersectObjects: function(i, r) {
                        var o = [];
                        if (i instanceof Array == !1) return e.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), o;
                        for (var a = 0, s = i.length; s > a; a++) n(i[a], this, o, r);
                        return o.sort(t), o
                    }
                }
            }(i), i.Object3D = function() {
                Object.defineProperty(this, "id", {
                    value: i.Object3DIdCount++
                }), this.uuid = i.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = void 0, this.children = [], this.up = i.Object3D.DefaultUp.clone();
                var e = new i.Vector3,
                    t = new i.Euler,
                    n = new i.Quaternion,
                    r = new i.Vector3(1, 1, 1),
                    o = function() {
                        n.setFromEuler(t, !1)
                    },
                    a = function() {
                        t.setFromQuaternion(n, void 0, !1)
                    };
                t.onChange(o), n.onChange(a), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        enumerable: !0,
                        value: r
                    }
                }), this.rotationAutoUpdate = !0, this.matrix = new i.Matrix4, this.matrixWorld = new i.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }, i.Object3D.DefaultUp = new i.Vector3(0, 1, 0), i.Object3D.prototype = {
                constructor: i.Object3D,
                get eulerOrder() {
                    return i.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order
                },
                set eulerOrder(e) {
                    i.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = e
                },
                get useQuaternion() {
                    i.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set useQuaternion(e) {
                    i.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                applyMatrix: function(e) {
                    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                setRotationFromAxisAngle: function(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function(e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function(e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function(e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function() {
                    var e = new i.Quaternion;
                    return function(t, n) {
                        return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
                    }
                }(),
                rotateX: function() {
                    var e = new i.Vector3(1, 0, 0);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateY: function() {
                    var e = new i.Vector3(0, 1, 0);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateZ: function() {
                    var e = new i.Vector3(0, 0, 1);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                translateOnAxis: function() {
                    var e = new i.Vector3;
                    return function(t, n) {
                        return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
                    }
                }(),
                translate: function(e, t) {
                    return i.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                },
                translateX: function() {
                    var e = new i.Vector3(1, 0, 0);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateY: function() {
                    var e = new i.Vector3(0, 1, 0);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateZ: function() {
                    var e = new i.Vector3(0, 0, 1);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                localToWorld: function(e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var e = new i.Matrix4;
                    return function(t) {
                        return t.applyMatrix4(e.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var e = new i.Matrix4;
                    return function(t) {
                        e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
                    }
                }(),
                add: function(e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (i.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e instanceof i.Object3D ? (void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                        type: "added"
                    }), this.children.push(e)) : i.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                },
                remove: function(e) {
                    if (arguments.length > 1)
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    var n = this.children.indexOf(e); - 1 !== n && (e.parent = void 0, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1))
                },
                getChildByName: function(e) {
                    return i.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                },
                getObjectById: function(e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function(e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function(e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, i = this.children.length; i > n; n++) {
                        var r = this.children[n],
                            o = r.getObjectByProperty(e, t);
                        if (void 0 !== o) return o
                    }
                },
                getWorldPosition: function(e) {
                    var t = e || new i.Vector3;
                    return this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var e = new i.Vector3,
                        t = new i.Vector3;
                    return function(n) {
                        var r = n || new i.Quaternion;
                        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, r, t), r
                    }
                }(),
                getWorldRotation: function() {
                    var e = new i.Quaternion;
                    return function(t) {
                        var n = t || new i.Euler;
                        return this.getWorldQuaternion(e), n.setFromQuaternion(e, this.rotation.order, !1)
                    }
                }(),
                getWorldScale: function() {
                    var e = new i.Vector3,
                        t = new i.Quaternion;
                    return function(n) {
                        var r = n || new i.Vector3;
                        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, r), r
                    }
                }(),
                getWorldDirection: function() {
                    var e = new i.Quaternion;
                    return function(t) {
                        var n = t || new i.Vector3;
                        return this.getWorldQuaternion(e), n.set(0, 0, 1).applyQuaternion(e)
                    }
                }(),
                raycast: function() {},
                traverse: function(e) {
                    e(this);
                    for (var t = 0, n = this.children.length; n > t; t++) this.children[t].traverse(e)
                },
                traverseVisible: function(e) {
                    if (this.visible !== !1) {
                        e(this);
                        for (var t = 0, n = this.children.length; n > t; t++) this.children[t].traverseVisible(e)
                    }
                },
                traverseAncestors: function(e) {
                    this.parent && (e(this.parent), this.parent.traverseAncestors(e))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(e) {
                    this.matrixAutoUpdate === !0 && this.updateMatrix(), this.matrixWorldNeedsUpdate !== !0 && e !== !0 || (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    for (var t = 0, n = this.children.length; n > t; t++) this.children[t].updateMatrixWorld(e)
                },
                toJSON: function() {
                    var e = {
                            metadata: {
                                version: 4.3,
                                type: "Object",
                                generator: "ObjectExporter"
                            }
                        },
                        t = {},
                        n = function(n) {
                            if (void 0 === e.geometries && (e.geometries = []), void 0 === t[n.uuid]) {
                                var i = n.toJSON();
                                delete i.metadata, t[n.uuid] = i, e.geometries.push(i)
                            }
                            return n.uuid
                        },
                        r = {},
                        o = function(t) {
                            if (void 0 === e.materials && (e.materials = []), void 0 === r[t.uuid]) {
                                var n = t.toJSON();
                                delete n.metadata, r[t.uuid] = n, e.materials.push(n)
                            }
                            return t.uuid
                        },
                        a = function(e) {
                            var t = {};
                            if (t.uuid = e.uuid, t.type = e.type, "" !== e.name && (t.name = e.name), "{}" !== JSON.stringify(e.userData) && (t.userData = e.userData), e.visible !== !0 && (t.visible = e.visible), e instanceof i.PerspectiveCamera ? (t.fov = e.fov, t.aspect = e.aspect, t.near = e.near, t.far = e.far) : e instanceof i.OrthographicCamera ? (t.left = e.left, t.right = e.right, t.top = e.top, t.bottom = e.bottom, t.near = e.near, t.far = e.far) : e instanceof i.AmbientLight ? t.color = e.color.getHex() : e instanceof i.DirectionalLight ? (t.color = e.color.getHex(), t.intensity = e.intensity) : e instanceof i.PointLight ? (t.color = e.color.getHex(), t.intensity = e.intensity, t.distance = e.distance, t.decay = e.decay) : e instanceof i.SpotLight ? (t.color = e.color.getHex(), t.intensity = e.intensity, t.distance = e.distance, t.angle = e.angle, t.exponent = e.exponent, t.decay = e.decay) : e instanceof i.HemisphereLight ? (t.color = e.color.getHex(), t.groundColor = e.groundColor.getHex()) : e instanceof i.Mesh || e instanceof i.Line || e instanceof i.PointCloud ? (t.geometry = n(e.geometry), t.material = o(e.material), e instanceof i.Line && (t.mode = e.mode)) : e instanceof i.Sprite && (t.material = o(e.material)), t.matrix = e.matrix.toArray(), e.children.length > 0) {
                                t.children = [];
                                for (var r = 0; r < e.children.length; r++) t.children.push(a(e.children[r]))
                            }
                            return t
                        };
                    return e.object = a(this), e
                },
                clone: function(e, t) {
                    if (void 0 === e && (e = new i.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData)), t === !0)
                        for (var n = 0; n < this.children.length; n++) {
                            var r = this.children[n];
                            e.add(r.clone())
                        }
                    return e
                }
            }, i.EventDispatcher.prototype.apply(i.Object3D.prototype), i.Object3DIdCount = 0, i.Face3 = function(e, t, n, r, o, a) {
                this.a = e, this.b = t, this.c = n, this.normal = r instanceof i.Vector3 ? r : new i.Vector3, this.vertexNormals = r instanceof Array ? r : [], this.color = o instanceof i.Color ? o : new i.Color, this.vertexColors = o instanceof Array ? o : [], this.vertexTangents = [], this.materialIndex = void 0 !== a ? a : 0
            }, i.Face3.prototype = {
                constructor: i.Face3,
                clone: function() {
                    var e = new i.Face3(this.a, this.b, this.c);
                    e.normal.copy(this.normal), e.color.copy(this.color), e.materialIndex = this.materialIndex;
                    for (var t = 0, n = this.vertexNormals.length; n > t; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
                    for (var t = 0, n = this.vertexColors.length; n > t; t++) e.vertexColors[t] = this.vertexColors[t].clone();
                    for (var t = 0, n = this.vertexTangents.length; n > t; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
                    return e
                }
            }, i.Face4 = function(e, t, n, r, o, a, s) {
                return i.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new i.Face3(e, t, n, o, a, s)
            }, i.BufferAttribute = function(e, t) {
                this.array = e, this.itemSize = t, this.needsUpdate = !1
            }, i.BufferAttribute.prototype = {
                constructor: i.BufferAttribute,
                get length() {
                    return this.array.length
                },
                copyAt: function(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (var i = 0, r = this.itemSize; r > i; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                set: function(e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                setX: function(e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                setY: function(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                setZ: function(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                setXY: function(e, t, n) {
                    return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this
                },
                setXYZ: function(e, t, n, i) {
                    return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                },
                setXYZW: function(e, t, n, i, r) {
                    return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                },
                clone: function() {
                    return new i.BufferAttribute(new this.array.constructor(this.array), this.itemSize)
                }
            }, i.Int8Attribute = function(e, t) {
                return i.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Uint8Attribute = function(e, t) {
                return i.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Uint8ClampedAttribute = function(e, t) {
                return i.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Int16Attribute = function(e, t) {
                return i.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Uint16Attribute = function(e, t) {
                return i.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Int32Attribute = function(e, t) {
                return i.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Uint32Attribute = function(e, t) {
                return i.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Float32Attribute = function(e, t) {
                return i.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.Float64Attribute = function(e, t) {
                return i.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new i.BufferAttribute(e, t)
            }, i.DynamicBufferAttribute = function(e, t) {
                i.BufferAttribute.call(this, e, t), this.updateRange = {
                    offset: 0,
                    count: -1
                }
            }, i.DynamicBufferAttribute.prototype = Object.create(i.BufferAttribute.prototype), i.DynamicBufferAttribute.prototype.constructor = i.DynamicBufferAttribute, i.DynamicBufferAttribute.prototype.clone = function() {
                return new i.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize)
            }, i.BufferGeometry = function() {
                Object.defineProperty(this, "id", {
                    value: i.GeometryIdCount++
                }), this.uuid = i.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.attributes = {}, this.attributesKeys = [], this.drawcalls = [], this.offsets = this.drawcalls, this.boundingBox = null, this.boundingSphere = null
            }, i.BufferGeometry.prototype = {
                constructor: i.BufferGeometry,
                addAttribute: function(e, t) {
                    return t instanceof i.BufferAttribute == !1 ? (i.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void(this.attributes[e] = {
                        array: arguments[1],
                        itemSize: arguments[2]
                    })) : (this.attributes[e] = t, void(this.attributesKeys = Object.keys(this.attributes)))
                },
                getAttribute: function(e) {
                    return this.attributes[e]
                },
                addDrawCall: function(e, t, n) {
                    this.drawcalls.push({
                        start: e,
                        count: t,
                        index: void 0 !== n ? n : 0
                    })
                },
                applyMatrix: function(e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var r = (new i.Matrix3).getNormalMatrix(e);
                        r.applyToVector3Array(n.array), n.needsUpdate = !0
                    }
                    null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere()
                },
                center: function() {
                    this.computeBoundingBox();
                    var e = this.boundingBox.center().negate();
                    return this.applyMatrix((new i.Matrix4).setPosition(e)), e
                },
                fromGeometry: function(e, t) {
                    t = t || {
                        vertexColors: i.NoColors
                    };
                    var n = e.vertices,
                        r = e.faces,
                        o = e.faceVertexUvs,
                        a = t.vertexColors,
                        s = o[0].length > 0,
                        l = 3 == r[0].vertexNormals.length,
                        c = new Float32Array(3 * r.length * 3);
                    this.addAttribute("position", new i.BufferAttribute(c, 3));
                    var h = new Float32Array(3 * r.length * 3);
                    if (this.addAttribute("normal", new i.BufferAttribute(h, 3)), a !== i.NoColors) {
                        var u = new Float32Array(3 * r.length * 3);
                        this.addAttribute("color", new i.BufferAttribute(u, 3))
                    }
                    if (s === !0) {
                        var f = new Float32Array(3 * r.length * 2);
                        this.addAttribute("uv", new i.BufferAttribute(f, 2))
                    }
                    for (var d = 0, p = 0, m = 0; d < r.length; d++, p += 6, m += 9) {
                        var v = r[d],
                            g = n[v.a],
                            y = n[v.b],
                            x = n[v.c];
                        if (c[m] = g.x, c[m + 1] = g.y, c[m + 2] = g.z, c[m + 3] = y.x, c[m + 4] = y.y, c[m + 5] = y.z, c[m + 6] = x.x, c[m + 7] = x.y, c[m + 8] = x.z, l === !0) {
                            var w = v.vertexNormals[0],
                                _ = v.vertexNormals[1],
                                b = v.vertexNormals[2];
                            h[m] = w.x, h[m + 1] = w.y, h[m + 2] = w.z, h[m + 3] = _.x, h[m + 4] = _.y, h[m + 5] = _.z, h[m + 6] = b.x, h[m + 7] = b.y, h[m + 8] = b.z
                        } else {
                            var E = v.normal;
                            h[m] = E.x, h[m + 1] = E.y, h[m + 2] = E.z, h[m + 3] = E.x, h[m + 4] = E.y, h[m + 5] = E.z, h[m + 6] = E.x, h[m + 7] = E.y, h[m + 8] = E.z
                        } if (a === i.FaceColors) {
                            var M = v.color;
                            u[m] = M.r, u[m + 1] = M.g, u[m + 2] = M.b, u[m + 3] = M.r, u[m + 4] = M.g, u[m + 5] = M.b, u[m + 6] = M.r, u[m + 7] = M.g, u[m + 8] = M.b
                        } else if (a === i.VertexColors) {
                            var S = v.vertexColors[0],
                                T = v.vertexColors[1],
                                C = v.vertexColors[2];
                            u[m] = S.r, u[m + 1] = S.g, u[m + 2] = S.b, u[m + 3] = T.r, u[m + 4] = T.g, u[m + 5] = T.b, u[m + 6] = C.r, u[m + 7] = C.g, u[m + 8] = C.b
                        }
                        if (s === !0) {
                            var A = o[0][d][0],
                                P = o[0][d][1],
                                D = o[0][d][2];
                            f[p] = A.x, f[p + 1] = A.y, f[p + 2] = P.x, f[p + 3] = P.y, f[p + 4] = D.x, f[p + 5] = D.y
                        }
                    }
                    return this.computeBoundingSphere(), this
                },
                computeBoundingBox: function() {
                    var e = new i.Vector3;
                    return function() {
                        null === this.boundingBox && (this.boundingBox = new i.Box3);
                        var t = this.attributes.position.array;
                        if (t) {
                            var n = this.boundingBox;
                            n.makeEmpty();
                            for (var r = 0, o = t.length; o > r; r += 3) e.set(t[r], t[r + 1], t[r + 2]), n.expandByPoint(e)
                        }
                        void 0 !== t && 0 !== t.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && i.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
                    }
                }(),
                computeBoundingSphere: function() {
                    var e = new i.Box3,
                        t = new i.Vector3;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new i.Sphere);
                        var n = this.attributes.position.array;
                        if (n) {
                            e.makeEmpty();
                            for (var r = this.boundingSphere.center, o = 0, a = n.length; a > o; o += 3) t.set(n[o], n[o + 1], n[o + 2]), e.expandByPoint(t);
                            e.center(r);
                            for (var s = 0, o = 0, a = n.length; a > o; o += 3) t.set(n[o], n[o + 1], n[o + 2]), s = Math.max(s, r.distanceToSquared(t));
                            this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && i.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var e = this.attributes;
                    if (e.position) {
                        var t = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new i.BufferAttribute(new Float32Array(t.length), 3));
                        else
                            for (var n = e.normal.array, r = 0, o = n.length; o > r; r++) n[r] = 0;
                        var a, s, l, n = e.normal.array,
                            c = new i.Vector3,
                            h = new i.Vector3,
                            u = new i.Vector3,
                            f = new i.Vector3,
                            d = new i.Vector3;
                        if (e.index)
                            for (var p = e.index.array, m = this.offsets.length > 0 ? this.offsets : [{
                                start: 0,
                                count: p.length,
                                index: 0
                            }], v = 0, g = m.length; g > v; ++v)
                                for (var y = m[v].start, x = m[v].count, w = m[v].index, r = y, o = y + x; o > r; r += 3) a = 3 * (w + p[r]), s = 3 * (w + p[r + 1]), l = 3 * (w + p[r + 2]), c.fromArray(t, a), h.fromArray(t, s), u.fromArray(t, l), f.subVectors(u, h), d.subVectors(c, h), f.cross(d), n[a] += f.x, n[a + 1] += f.y, n[a + 2] += f.z, n[s] += f.x, n[s + 1] += f.y, n[s + 2] += f.z, n[l] += f.x, n[l + 1] += f.y, n[l + 2] += f.z;
                        else
                            for (var r = 0, o = t.length; o > r; r += 9) c.fromArray(t, r), h.fromArray(t, r + 3), u.fromArray(t, r + 6), f.subVectors(u, h), d.subVectors(c, h), f.cross(d), n[r] = f.x, n[r + 1] = f.y, n[r + 2] = f.z, n[r + 3] = f.x, n[r + 4] = f.y, n[r + 5] = f.z, n[r + 6] = f.x, n[r + 7] = f.y, n[r + 8] = f.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                computeTangents: function() {
                    function e(e, t, n) {
                        D.fromArray(r, 3 * e), L.fromArray(r, 3 * t), R.fromArray(r, 3 * n), O.fromArray(a, 2 * e), N.fromArray(a, 2 * t), U.fromArray(a, 2 * n), f = L.x - D.x, d = R.x - D.x, p = L.y - D.y, m = R.y - D.y, v = L.z - D.z, g = R.z - D.z, y = N.x - O.x, x = U.x - O.x, w = N.y - O.y, _ = U.y - O.y, b = 1 / (y * _ - x * w), F.set((_ * f - w * d) * b, (_ * p - w * m) * b, (_ * v - w * g) * b), k.set((y * d - x * f) * b, (y * m - x * p) * b, (y * g - x * v) * b), c[e].add(F), c[t].add(F), c[n].add(F), h[e].add(k), h[t].add(k), h[n].add(k)
                    }

                    function t(e) {
                        q.fromArray(o, 3 * e), K.copy(q), j = c[e], W.copy(j), W.sub(q.multiplyScalar(q.dot(j))).normalize(), X.crossVectors(K, j), G = X.dot(h[e]), B = 0 > G ? -1 : 1, l[4 * e] = W.x, l[4 * e + 1] = W.y, l[4 * e + 2] = W.z, l[4 * e + 3] = B
                    }
                    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) return void i.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
                    var n = this.attributes.index.array,
                        r = this.attributes.position.array,
                        o = this.attributes.normal.array,
                        a = this.attributes.uv.array,
                        s = r.length / 3;
                    void 0 === this.attributes.tangent && this.addAttribute("tangent", new i.BufferAttribute(new Float32Array(4 * s), 4));
                    for (var l = this.attributes.tangent.array, c = [], h = [], u = 0; s > u; u++) c[u] = new i.Vector3, h[u] = new i.Vector3;
                    var f, d, p, m, v, g, y, x, w, _, b, E, M, S, T, C, A, P, D = new i.Vector3,
                        L = new i.Vector3,
                        R = new i.Vector3,
                        O = new i.Vector2,
                        N = new i.Vector2,
                        U = new i.Vector2,
                        F = new i.Vector3,
                        k = new i.Vector3;
                    0 === this.drawcalls.length && this.addDrawCall(0, n.length, 0);
                    var H = this.drawcalls;
                    for (S = 0, T = H.length; T > S; ++S) {
                        var I = H[S].start,
                            V = H[S].count,
                            z = H[S].index;
                        for (E = I, M = I + V; M > E; E += 3) C = z + n[E], A = z + n[E + 1], P = z + n[E + 2], e(C, A, P)
                    }
                    var B, j, G, W = new i.Vector3,
                        X = new i.Vector3,
                        q = new i.Vector3,
                        K = new i.Vector3;
                    for (S = 0, T = H.length; T > S; ++S) {
                        var I = H[S].start,
                            V = H[S].count,
                            z = H[S].index;
                        for (E = I, M = I + V; M > E; E += 3) C = z + n[E], A = z + n[E + 1], P = z + n[E + 2], t(C), t(A), t(P)
                    }
                },
                computeOffsets: function(e) {
                    void 0 === e && (e = 65535);
                    for (var t = this.attributes.index.array, n = this.attributes.position.array, i = t.length / 3, r = new Uint16Array(t.length), o = 0, a = 0, s = [{
                        start: 0,
                        count: 0,
                        index: 0
                    }], l = s[0], c = 0, h = 0, u = new Int32Array(6), f = new Int32Array(n.length), d = new Int32Array(n.length), p = 0; p < n.length; p++) f[p] = -1, d[p] = -1;
                    for (var m = 0; i > m; m++) {
                        h = 0;
                        for (var v = 0; 3 > v; v++) {
                            var g = t[3 * m + v]; - 1 == f[g] ? (u[2 * v] = g, u[2 * v + 1] = -1, h++) : f[g] < l.index ? (u[2 * v] = g, u[2 * v + 1] = -1, c++) : (u[2 * v] = g, u[2 * v + 1] = f[g])
                        }
                        var y = a + h;
                        if (y > l.index + e) {
                            var x = {
                                start: o,
                                count: 0,
                                index: a
                            };
                            s.push(x), l = x;
                            for (var w = 0; 6 > w; w += 2) {
                                var _ = u[w + 1];
                                _ > -1 && _ < l.index && (u[w + 1] = -1)
                            }
                        }
                        for (var w = 0; 6 > w; w += 2) {
                            var g = u[w],
                                _ = u[w + 1]; - 1 === _ && (_ = a++), f[g] = _, d[_] = g, r[o++] = _ - l.index, l.count++
                        }
                    }
                    return this.reorderBuffers(r, d, a), this.offsets = s, this.drawcalls = s, s
                },
                merge: function(e, t) {
                    if (e instanceof i.BufferGeometry == !1) return void i.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0);
                    var n = this.attributes;
                    for (var r in n)
                        if (void 0 !== e.attributes[r])
                            for (var o = n[r], a = o.array, s = e.attributes[r], l = s.array, c = s.itemSize, h = 0, u = c * t; h < l.length; h++, u++) a[u] = l[h];
                    return this
                },
                normalizeNormals: function() {
                    for (var e, t, n, i, r = this.attributes.normal.array, o = 0, a = r.length; a > o; o += 3) e = r[o], t = r[o + 1], n = r[o + 2], i = 1 / Math.sqrt(e * e + t * t + n * n), r[o] *= i, r[o + 1] *= i, r[o + 2] *= i
                },
                reorderBuffers: function(e, t, n) {
                    var i = {};
                    for (var r in this.attributes)
                        if ("index" != r) {
                            var o = this.attributes[r].array;
                            i[r] = new o.constructor(this.attributes[r].itemSize * n)
                        }
                    for (var a = 0; n > a; a++) {
                        var s = t[a];
                        for (var r in this.attributes)
                            if ("index" != r)
                                for (var l = this.attributes[r].array, c = this.attributes[r].itemSize, h = i[r], u = 0; c > u; u++) h[a * c + u] = l[s * c + u]
                    }
                    this.attributes.index.array = e;
                    for (var r in this.attributes) "index" != r && (this.attributes[r].array = i[r], this.attributes[r].numItems = this.attributes[r].itemSize * n)
                },
                toJSON: function() {
                    var e = {
                            metadata: {
                                version: 4,
                                type: "BufferGeometry",
                                generator: "BufferGeometryExporter"
                            },
                            uuid: this.uuid,
                            type: this.type,
                            data: {
                                attributes: {}
                            }
                        },
                        t = this.attributes,
                        n = this.offsets,
                        i = this.boundingSphere;
                    for (var r in t) {
                        var o = t[r],
                            a = Array.prototype.slice.call(o.array);
                        e.data.attributes[r] = {
                            itemSize: o.itemSize,
                            type: o.array.constructor.name,
                            array: a
                        }
                    }
                    return n.length > 0 && (e.data.offsets = JSON.parse(JSON.stringify(n))), null !== i && (e.data.boundingSphere = {
                        center: i.center.toArray(),
                        radius: i.radius
                    }), e
                },
                clone: function() {
                    var e = new i.BufferGeometry;
                    for (var t in this.attributes) {
                        var n = this.attributes[t];
                        e.addAttribute(t, n.clone())
                    }
                    for (var r = 0, o = this.offsets.length; o > r; r++) {
                        var a = this.offsets[r];
                        e.offsets.push({
                            start: a.start,
                            index: a.index,
                            count: a.count
                        })
                    }
                    return e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, i.EventDispatcher.prototype.apply(i.BufferGeometry.prototype), i.Geometry = function() {
                Object.defineProperty(this, "id", {
                    value: i.GeometryIdCount++
                }), this.uuid = i.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.tangentsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }, i.Geometry.prototype = {
                constructor: i.Geometry,
                applyMatrix: function(e) {
                    for (var t = (new i.Matrix3).getNormalMatrix(e), n = 0, r = this.vertices.length; r > n; n++) {
                        var o = this.vertices[n];
                        o.applyMatrix4(e)
                    }
                    for (var n = 0, r = this.faces.length; r > n; n++) {
                        var a = this.faces[n];
                        a.normal.applyMatrix3(t).normalize();
                        for (var s = 0, l = a.vertexNormals.length; l > s; s++) a.vertexNormals[s].applyMatrix3(t).normalize()
                    }
                    null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0
                },
                fromBufferGeometry: function(e) {
                    for (var t = this, n = e.attributes, r = n.position.array, o = void 0 !== n.index ? n.index.array : void 0, a = void 0 !== n.normal ? n.normal.array : void 0, s = void 0 !== n.color ? n.color.array : void 0, l = void 0 !== n.uv ? n.uv.array : void 0, c = [], h = [], u = 0, f = 0; u < r.length; u += 3, f += 2) t.vertices.push(new i.Vector3(r[u], r[u + 1], r[u + 2])), void 0 !== a && c.push(new i.Vector3(a[u], a[u + 1], a[u + 2])), void 0 !== s && t.colors.push(new i.Color(s[u], s[u + 1], s[u + 2])), void 0 !== l && h.push(new i.Vector2(l[f], l[f + 1]));
                    var d = function(e, n, r) {
                        var o = void 0 !== a ? [c[e].clone(), c[n].clone(), c[r].clone()] : [],
                            u = void 0 !== s ? [t.colors[e].clone(), t.colors[n].clone(), t.colors[r].clone()] : [];
                        t.faces.push(new i.Face3(e, n, r, o, u)), void 0 !== l && t.faceVertexUvs[0].push([h[e].clone(), h[n].clone(), h[r].clone()])
                    };
                    if (void 0 !== o) {
                        var p = e.drawcalls;
                        if (p.length > 0)
                            for (var u = 0; u < p.length; u++)
                                for (var m = p[u], v = m.start, g = m.count, y = m.index, f = v, x = v + g; x > f; f += 3) d(y + o[f], y + o[f + 1], y + o[f + 2]);
                        else
                            for (var u = 0; u < o.length; u += 3) d(o[u], o[u + 1], o[u + 2])
                    } else
                        for (var u = 0; u < r.length / 3; u += 3) d(u, u + 1, u + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function() {
                    this.computeBoundingBox();
                    var e = this.boundingBox.center().negate();
                    return this.applyMatrix((new i.Matrix4).setPosition(e)), e
                },
                computeFaceNormals: function() {
                    for (var e = new i.Vector3, t = new i.Vector3, n = 0, r = this.faces.length; r > n; n++) {
                        var o = this.faces[n],
                            a = this.vertices[o.a],
                            s = this.vertices[o.b],
                            l = this.vertices[o.c];
                        e.subVectors(l, s), t.subVectors(a, s), e.cross(t), e.normalize(), o.normal.copy(e)
                    }
                },
                computeVertexNormals: function(e) {
                    var t, n, r, o, a, s;
                    for (s = new Array(this.vertices.length), t = 0, n = this.vertices.length; n > t; t++) s[t] = new i.Vector3;
                    if (e) {
                        var l, c, h, u = new i.Vector3,
                            f = new i.Vector3;
                        for (r = 0, o = this.faces.length; o > r; r++) a = this.faces[r], l = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], u.subVectors(h, c), f.subVectors(l, c), u.cross(f), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u)
                    } else
                        for (r = 0, o = this.faces.length; o > r; r++) a = this.faces[r], s[a.a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
                    for (t = 0, n = this.vertices.length; n > t; t++) s[t].normalize();
                    for (r = 0, o = this.faces.length; o > r; r++) a = this.faces[r], a.vertexNormals[0] = s[a.a].clone(), a.vertexNormals[1] = s[a.b].clone(), a.vertexNormals[2] = s[a.c].clone()
                },
                computeMorphNormals: function() {
                    var e, t, n, r, o;
                    for (n = 0, r = this.faces.length; r > n; n++)
                        for (o = this.faces[n], o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(), o.__originalVertexNormals || (o.__originalVertexNormals = []), e = 0, t = o.vertexNormals.length; t > e; e++) o.__originalVertexNormals[e] ? o.__originalVertexNormals[e].copy(o.vertexNormals[e]) : o.__originalVertexNormals[e] = o.vertexNormals[e].clone();
                    var a = new i.Geometry;
                    for (a.faces = this.faces, e = 0, t = this.morphTargets.length; t > e; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var s, l, c = this.morphNormals[e].faceNormals,
                                h = this.morphNormals[e].vertexNormals;
                            for (n = 0, r = this.faces.length; r > n; n++) s = new i.Vector3, l = {
                                a: new i.Vector3,
                                b: new i.Vector3,
                                c: new i.Vector3
                            }, c.push(s), h.push(l)
                        }
                        var u = this.morphNormals[e];
                        a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                        var s, l;
                        for (n = 0, r = this.faces.length; r > n; n++) o = this.faces[n], s = u.faceNormals[n], l = u.vertexNormals[n], s.copy(o.normal), l.a.copy(o.vertexNormals[0]), l.b.copy(o.vertexNormals[1]), l.c.copy(o.vertexNormals[2])
                    }
                    for (n = 0, r = this.faces.length; r > n; n++) o = this.faces[n], o.normal = o.__originalFaceNormal, o.vertexNormals = o.__originalVertexNormals
                },
                computeTangents: function() {
                    function e(e, t, n, i, r, o, a) {
                        h = e.vertices[t], u = e.vertices[n], f = e.vertices[i], d = c[r], p = c[o], m = c[a], v = u.x - h.x, g = f.x - h.x, y = u.y - h.y, x = f.y - h.y, w = u.z - h.z, _ = f.z - h.z, b = p.x - d.x, E = m.x - d.x, M = p.y - d.y, S = m.y - d.y, T = 1 / (b * S - E * M), R.set((S * v - M * g) * T, (S * y - M * x) * T, (S * w - M * _) * T), O.set((b * g - E * v) * T, (b * x - E * y) * T, (b * _ - E * w) * T), D[t].add(R), D[n].add(R), D[i].add(R), L[t].add(O), L[n].add(O), L[i].add(O)
                    }
                    var t, n, r, o, a, s, l, c, h, u, f, d, p, m, v, g, y, x, w, _, b, E, M, S, T, C, A, P, D = [],
                        L = [],
                        R = new i.Vector3,
                        O = new i.Vector3,
                        N = new i.Vector3,
                        U = new i.Vector3,
                        F = new i.Vector3;
                    for (r = 0, o = this.vertices.length; o > r; r++) D[r] = new i.Vector3, L[r] = new i.Vector3;
                    for (t = 0, n = this.faces.length; n > t; t++) l = this.faces[t], c = this.faceVertexUvs[0][t], e(this, l.a, l.b, l.c, 0, 1, 2);
                    var k = ["a", "b", "c", "d"];
                    for (t = 0, n = this.faces.length; n > t; t++)
                        for (l = this.faces[t], a = 0; a < Math.min(l.vertexNormals.length, 3); a++) F.copy(l.vertexNormals[a]), s = l[k[a]], C = D[s], N.copy(C), N.sub(F.multiplyScalar(F.dot(C))).normalize(), U.crossVectors(l.vertexNormals[a], C), A = U.dot(L[s]), P = 0 > A ? -1 : 1, l.vertexTangents[a] = new i.Vector4(N.x, N.y, N.z, P);
                    this.hasTangents = !0
                },
                computeLineDistances: function() {
                    for (var e = 0, t = this.vertices, n = 0, i = t.length; i > n; n++) n > 0 && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new i.Box3), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new i.Sphere), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(e, t, n) {
                    if (e instanceof i.Geometry == !1) return void i.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
                    var r, o = this.vertices.length,
                        a = this.vertices,
                        s = e.vertices,
                        l = this.faces,
                        c = e.faces,
                        h = this.faceVertexUvs[0],
                        u = e.faceVertexUvs[0];
                    void 0 === n && (n = 0), void 0 !== t && (r = (new i.Matrix3).getNormalMatrix(t));
                    for (var f = 0, d = s.length; d > f; f++) {
                        var p = s[f],
                            m = p.clone();
                        void 0 !== t && m.applyMatrix4(t), a.push(m)
                    }
                    for (f = 0, d = c.length; d > f; f++) {
                        var v, g, y, x = c[f],
                            w = x.vertexNormals,
                            _ = x.vertexColors;
                        v = new i.Face3(x.a + o, x.b + o, x.c + o), v.normal.copy(x.normal), void 0 !== r && v.normal.applyMatrix3(r).normalize();
                        for (var b = 0, E = w.length; E > b; b++) g = w[b].clone(), void 0 !== r && g.applyMatrix3(r).normalize(), v.vertexNormals.push(g);
                        v.color.copy(x.color);
                        for (var b = 0, E = _.length; E > b; b++) y = _[b], v.vertexColors.push(y.clone());
                        v.materialIndex = x.materialIndex + n, l.push(v)
                    }
                    for (f = 0, d = u.length; d > f; f++) {
                        var M = u[f],
                            S = [];
                        if (void 0 !== M) {
                            for (var b = 0, E = M.length; E > b; b++) S.push(M[b].clone());
                            h.push(S)
                        }
                    }
                },
                mergeMesh: function(e) {
                    return e instanceof i.Mesh == !1 ? void i.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) : (e.matrixAutoUpdate && e.updateMatrix(), void this.merge(e.geometry, e.matrix))
                },
                mergeVertices: function() {
                    var e, t, n, i, r, o, a, s, l = {},
                        c = [],
                        h = [],
                        u = 4,
                        f = Math.pow(10, u);
                    for (n = 0, i = this.vertices.length; i > n; n++) e = this.vertices[n], t = Math.round(e.x * f) + "_" + Math.round(e.y * f) + "_" + Math.round(e.z * f), void 0 === l[t] ? (l[t] = n, c.push(this.vertices[n]), h[n] = c.length - 1) : h[n] = h[l[t]];
                    var d = [];
                    for (n = 0, i = this.faces.length; i > n; n++) {
                        r = this.faces[n], r.a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                        for (var p = -1, m = 0; 3 > m; m++)
                            if (o[m] == o[(m + 1) % 3]) {
                                p = m, d.push(n);
                                break
                            }
                    }
                    for (n = d.length - 1; n >= 0; n--) {
                        var v = d[n];
                        for (this.faces.splice(v, 1), a = 0, s = this.faceVertexUvs.length; s > a; a++) this.faceVertexUvs[a].splice(v, 1)
                    }
                    var g = this.vertices.length - c.length;
                    return this.vertices = c, g
                },
                toJSON: function() {
                    function e(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function t(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== f[t] ? f[t] : (f[t] = u.length / 3, u.push(e.x, e.y, e.z), f[t])
                    }

                    function n(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== p[t] ? p[t] : (p[t] = d.length, d.push(e.getHex()), p[t])
                    }

                    function i(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== v[t] ? v[t] : (v[t] = m.length / 2, m.push(e.x, e.y), v[t])
                    }
                    var r = {
                        metadata: {
                            version: 4,
                            type: "BufferGeometry",
                            generator: "BufferGeometryExporter"
                        },
                        uuid: this.uuid,
                        type: this.type
                    };
                    if ("" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                        var o = this.parameters;
                        for (var a in o) void 0 !== o[a] && (r[a] = o[a]);
                        return r
                    }
                    for (var s = [], l = 0; l < this.vertices.length; l++) {
                        var c = this.vertices[l];
                        s.push(c.x, c.y, c.z)
                    }
                    for (var h = [], u = [], f = {}, d = [], p = {}, m = [], v = {}, l = 0; l < this.faces.length; l++) {
                        var g = this.faces[l],
                            y = !1,
                            x = !1,
                            w = void 0 !== this.faceVertexUvs[0][l],
                            _ = g.normal.length() > 0,
                            b = g.vertexNormals.length > 0,
                            E = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
                            M = g.vertexColors.length > 0,
                            S = 0;
                        if (S = e(S, 0, 0), S = e(S, 1, y), S = e(S, 2, x), S = e(S, 3, w), S = e(S, 4, _), S = e(S, 5, b), S = e(S, 6, E), S = e(S, 7, M), h.push(S), h.push(g.a, g.b, g.c), w) {
                            var T = this.faceVertexUvs[0][l];
                            h.push(i(T[0]), i(T[1]), i(T[2]))
                        }
                        if (_ && h.push(t(g.normal)), b) {
                            var C = g.vertexNormals;
                            h.push(t(C[0]), t(C[1]), t(C[2]))
                        }
                        if (E && h.push(n(g.color)), M) {
                            var A = g.vertexColors;
                            h.push(n(A[0]), n(A[1]), n(A[2]))
                        }
                    }
                    return r.data = {}, r.data.vertices = s, r.data.normals = u, d.length > 0 && (r.data.colors = d), m.length > 0 && (r.data.uvs = [m]), r.data.faces = h, r
                },
                clone: function() {
                    for (var e = new i.Geometry, t = this.vertices, n = 0, r = t.length; r > n; n++) e.vertices.push(t[n].clone());
                    for (var o = this.faces, n = 0, r = o.length; r > n; n++) e.faces.push(o[n].clone());
                    for (var n = 0, r = this.faceVertexUvs.length; r > n; n++) {
                        var a = this.faceVertexUvs[n];
                        void 0 === e.faceVertexUvs[n] && (e.faceVertexUvs[n] = []);
                        for (var s = 0, l = a.length; l > s; s++) {
                            for (var c = a[s], h = [], u = 0, f = c.length; f > u; u++) {
                                var d = c[u];
                                h.push(d.clone())
                            }
                            e.faceVertexUvs[n].push(h)
                        }
                    }
                    return e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, i.EventDispatcher.prototype.apply(i.Geometry.prototype), i.GeometryIdCount = 0, i.Camera = function() {
                i.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new i.Matrix4, this.projectionMatrix = new i.Matrix4
            }, i.Camera.prototype = Object.create(i.Object3D.prototype), i.Camera.prototype.constructor = i.Camera, i.Camera.prototype.getWorldDirection = function() {
                var e = new i.Quaternion;
                return function(t) {
                    var n = t || new i.Vector3;
                    return this.getWorldQuaternion(e), n.set(0, 0, -1).applyQuaternion(e)
                }
            }(), i.Camera.prototype.lookAt = function() {
                var e = new i.Matrix4;
                return function(t) {
                    e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
                }
            }(), i.Camera.prototype.clone = function(e) {
                return void 0 === e && (e = new i.Camera), i.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
            }, i.CubeCamera = function(e, t, n) {
                i.Object3D.call(this), this.type = "CubeCamera";
                var r = 90,
                    o = 1,
                    a = new i.PerspectiveCamera(r, o, e, t);
                a.up.set(0, -1, 0), a.lookAt(new i.Vector3(1, 0, 0)), this.add(a);
                var s = new i.PerspectiveCamera(r, o, e, t);
                s.up.set(0, -1, 0), s.lookAt(new i.Vector3(-1, 0, 0)), this.add(s);
                var l = new i.PerspectiveCamera(r, o, e, t);
                l.up.set(0, 0, 1), l.lookAt(new i.Vector3(0, 1, 0)), this.add(l);
                var c = new i.PerspectiveCamera(r, o, e, t);
                c.up.set(0, 0, -1), c.lookAt(new i.Vector3(0, -1, 0)), this.add(c);
                var h = new i.PerspectiveCamera(r, o, e, t);
                h.up.set(0, -1, 0), h.lookAt(new i.Vector3(0, 0, 1)), this.add(h);
                var u = new i.PerspectiveCamera(r, o, e, t);
                u.up.set(0, -1, 0), u.lookAt(new i.Vector3(0, 0, -1)), this.add(u), this.renderTarget = new i.WebGLRenderTargetCube(n, n, {
                    format: i.RGBFormat,
                    magFilter: i.LinearFilter,
                    minFilter: i.LinearFilter
                }), this.updateCubeMap = function(e, t) {
                    var n = this.renderTarget,
                        i = n.generateMipmaps;
                    n.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, a, n), n.activeCubeFace = 1, e.render(t, s, n), n.activeCubeFace = 2, e.render(t, l, n), n.activeCubeFace = 3, e.render(t, c, n), n.activeCubeFace = 4, e.render(t, h, n), n.generateMipmaps = i, n.activeCubeFace = 5, e.render(t, u, n)
                }
            }, i.CubeCamera.prototype = Object.create(i.Object3D.prototype), i.CubeCamera.prototype.constructor = i.CubeCamera, i.OrthographicCamera = function(e, t, n, r, o, a) {
                i.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== o ? o : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }, i.OrthographicCamera.prototype = Object.create(i.Camera.prototype), i.OrthographicCamera.prototype.constructor = i.OrthographicCamera, i.OrthographicCamera.prototype.updateProjectionMatrix = function() {
                var e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                this.projectionMatrix.makeOrthographic(n - e, n + e, i + t, i - t, this.near, this.far)
            }, i.OrthographicCamera.prototype.clone = function() {
                var e = new i.OrthographicCamera;
                return i.Camera.prototype.clone.call(this, e), e.zoom = this.zoom, e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e.projectionMatrix.copy(this.projectionMatrix), e
            }, i.PerspectiveCamera = function(e, t, n, r) {
                i.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
            }, i.PerspectiveCamera.prototype = Object.create(i.Camera.prototype), i.PerspectiveCamera.prototype.constructor = i.PerspectiveCamera, i.PerspectiveCamera.prototype.setLens = function(e, t) {
                void 0 === t && (t = 24), this.fov = 2 * i.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
            }, i.PerspectiveCamera.prototype.setViewOffset = function(e, t, n, i, r, o) {
                this.fullWidth = e, this.fullHeight = t, this.x = n, this.y = i, this.width = r, this.height = o, this.updateProjectionMatrix()
            }, i.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
                var e = i.Math.radToDeg(2 * Math.atan(Math.tan(.5 * i.Math.degToRad(this.fov)) / this.zoom));
                if (this.fullWidth) {
                    var t = this.fullWidth / this.fullHeight,
                        n = Math.tan(i.Math.degToRad(.5 * e)) * this.near,
                        r = -n,
                        o = t * r,
                        a = t * n,
                        s = Math.abs(a - o),
                        l = Math.abs(n - r);
                    this.projectionMatrix.makeFrustum(o + this.x * s / this.fullWidth, o + (this.x + this.width) * s / this.fullWidth, n - (this.y + this.height) * l / this.fullHeight, n - this.y * l / this.fullHeight, this.near, this.far)
                } else this.projectionMatrix.makePerspective(e, this.aspect, this.near, this.far)
            }, i.PerspectiveCamera.prototype.clone = function() {
                var e = new i.PerspectiveCamera;
                return i.Camera.prototype.clone.call(this, e), e.zoom = this.zoom, e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e.projectionMatrix.copy(this.projectionMatrix), e
            }, i.Light = function(e) {
                i.Object3D.call(this), this.type = "Light", this.color = new i.Color(e)
            }, i.Light.prototype = Object.create(i.Object3D.prototype), i.Light.prototype.constructor = i.Light, i.Light.prototype.clone = function(e) {
                return void 0 === e && (e = new i.Light), i.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
            }, i.AmbientLight = function(e) {
                i.Light.call(this, e), this.type = "AmbientLight"
            }, i.AmbientLight.prototype = Object.create(i.Light.prototype), i.AmbientLight.prototype.constructor = i.AmbientLight, i.AmbientLight.prototype.clone = function() {
                var e = new i.AmbientLight;
                return i.Light.prototype.clone.call(this, e), e
            }, i.AreaLight = function(e, t) {
                i.Light.call(this, e), this.type = "AreaLight", this.normal = new i.Vector3(0, -1, 0), this.right = new i.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.width = 1, this.height = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
            }, i.AreaLight.prototype = Object.create(i.Light.prototype), i.AreaLight.prototype.constructor = i.AreaLight, i.DirectionalLight = function(e, t) {
                i.Light.call(this, e), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.target = new i.Object3D, this.intensity = void 0 !== t ? t : 1, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraRight = 500, this.shadowCameraTop = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new i.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null
            }, i.DirectionalLight.prototype = Object.create(i.Light.prototype), i.DirectionalLight.prototype.constructor = i.DirectionalLight, i.DirectionalLight.prototype.clone = function() {
                var e = new i.DirectionalLight;
                return i.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraLeft = this.shadowCameraLeft, e.shadowCameraRight = this.shadowCameraRight, e.shadowCameraTop = this.shadowCameraTop, e.shadowCameraBottom = this.shadowCameraBottom, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e.shadowCascade = this.shadowCascade, e.shadowCascadeOffset.copy(this.shadowCascadeOffset), e.shadowCascadeCount = this.shadowCascadeCount, e.shadowCascadeBias = this.shadowCascadeBias.slice(0), e.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), e.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), e.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), e.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), e
            }, i.HemisphereLight = function(e, t, n) {
                i.Light.call(this, e), this.type = "HemisphereLight", this.position.set(0, 100, 0), this.groundColor = new i.Color(t), this.intensity = void 0 !== n ? n : 1
            }, i.HemisphereLight.prototype = Object.create(i.Light.prototype), i.HemisphereLight.prototype.constructor = i.HemisphereLight, i.HemisphereLight.prototype.clone = function() {
                var e = new i.HemisphereLight;
                return i.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
            }, i.PointLight = function(e, t, n, r) {
                i.Light.call(this, e), this.type = "PointLight", this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1
            }, i.PointLight.prototype = Object.create(i.Light.prototype), i.PointLight.prototype.constructor = i.PointLight, i.PointLight.prototype.clone = function() {
                var e = new i.PointLight;
                return i.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e.decay = this.decay, e
            }, i.SpotLight = function(e, t, n, r, o, a) {
                i.Light.call(this, e), this.type = "SpotLight", this.position.set(0, 1, 0), this.target = new i.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== o ? o : 10, this.decay = void 0 !== a ? a : 1, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null
            }, i.SpotLight.prototype = Object.create(i.Light.prototype), i.SpotLight.prototype.constructor = i.SpotLight, i.SpotLight.prototype.clone = function() {
                var e = new i.SpotLight;
                return i.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.decay = this.decay, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraFov = this.shadowCameraFov, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e
            }, i.Cache = {
                files: {},
                add: function(e, t) {
                    this.files[e] = t
                },
                get: function(e) {
                    return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            }, i.Loader = function(e) {
                this.showStatus = e, this.statusDomElement = e ? i.Loader.prototype.addStatusElement() : null, this.imageLoader = new i.ImageLoader, this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
            }, i.Loader.prototype = {
                constructor: i.Loader,
                crossOrigin: void 0,
                addStatusElement: function() {
                    var e = document.createElement("div");
                    return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
                },
                updateProgress: function(e) {
                    var t = "Loaded ";
                    t += e.total ? (100 * e.loaded / e.total).toFixed(0) + "%" : (e.loaded / 1024).toFixed(2) + " KB", this.statusDomElement.innerHTML = t
                },
                extractUrlBase: function(e) {
                    var t = e.split("/");
                    return 1 === t.length ? "./" : (t.pop(), t.join("/") + "/")
                },
                initMaterials: function(e, t) {
                    for (var n = [], i = 0; i < e.length; ++i) n[i] = this.createMaterial(e[i], t);
                    return n
                },
                needsTangents: function(e) {
                    for (var t = 0, n = e.length; n > t; t++) {
                        var r = e[t];
                        if (r instanceof i.ShaderMaterial) return !0
                    }
                    return !1
                },
                createMaterial: function(e, t) {
                    function n(e) {
                        var t = Math.log(e) / Math.LN2;
                        return Math.pow(2, Math.round(t))
                    }

                    function r(e, r, o, s, l, c, h) {
                        var u, f = t + o,
                            d = i.Loader.Handlers.get(f);
                        if (null !== d ? u = d.load(f) : (u = new i.Texture, d = a.imageLoader, d.crossOrigin = a.crossOrigin, d.load(f, function(e) {
                                if (i.Math.isPowerOfTwo(e.width) === !1 || i.Math.isPowerOfTwo(e.height) === !1) {
                                    var t = n(e.width),
                                        r = n(e.height),
                                        o = document.createElement("canvas");
                                    o.width = t, o.height = r;
                                    var a = o.getContext("2d");
                                    a.drawImage(e, 0, 0, t, r), u.image = o
                                } else u.image = e;
                                u.needsUpdate = !0
                            })), u.sourceFile = o, s && (u.repeat.set(s[0], s[1]), 1 !== s[0] && (u.wrapS = i.RepeatWrapping), 1 !== s[1] && (u.wrapT = i.RepeatWrapping)), l && u.offset.set(l[0], l[1]), c) {
                            var p = {
                                repeat: i.RepeatWrapping,
                                mirror: i.MirroredRepeatWrapping
                            };
                            void 0 !== p[c[0]] && (u.wrapS = p[c[0]]), void 0 !== p[c[1]] && (u.wrapT = p[c[1]])
                        }
                        h && (u.anisotropy = h), e[r] = u
                    }

                    function o(e) {
                        return (255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
                    }
                    var a = this,
                        s = "MeshLambertMaterial",
                        l = {
                            color: 15658734,
                            opacity: 1,
                            map: null,
                            lightMap: null,
                            normalMap: null,
                            bumpMap: null,
                            wireframe: !1
                        };
                    if (e.shading) {
                        var c = e.shading.toLowerCase();
                        "phong" === c ? s = "MeshPhongMaterial" : "basic" === c && (s = "MeshBasicMaterial")
                    }
                    void 0 !== e.blending && void 0 !== i[e.blending] && (l.blending = i[e.blending]), void 0 !== e.transparent && (l.transparent = e.transparent), void 0 !== e.opacity && e.opacity < 1 && (l.transparent = !0), void 0 !== e.depthTest && (l.depthTest = e.depthTest), void 0 !== e.depthWrite && (l.depthWrite = e.depthWrite), void 0 !== e.visible && (l.visible = e.visible), void 0 !== e.flipSided && (l.side = i.BackSide), void 0 !== e.doubleSided && (l.side = i.DoubleSide), void 0 !== e.wireframe && (l.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? l.vertexColors = i.FaceColors : e.vertexColors && (l.vertexColors = i.VertexColors)), e.colorDiffuse ? l.color = o(e.colorDiffuse) : e.DbgColor && (l.color = e.DbgColor), e.colorSpecular && (l.specular = o(e.colorSpecular)), e.colorEmissive && (l.emissive = o(e.colorEmissive)), void 0 !== e.transparency && (console.warn("THREE.Loader: transparency has been renamed to opacity"), e.opacity = e.transparency), void 0 !== e.opacity && (l.opacity = e.opacity), e.specularCoef && (l.shininess = e.specularCoef), e.mapDiffuse && t && r(l, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && t && r(l, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && t && r(l, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && t && r(l, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && t && r(l, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapAlpha && t && r(l, "alphaMap", e.mapAlpha, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy), e.mapBumpScale && (l.bumpScale = e.mapBumpScale), e.mapNormalFactor && (l.normalScale = new i.Vector2(e.mapNormalFactor, e.mapNormalFactor));
                    var h = new i[s](l);
                    return void 0 !== e.DbgName && (h.name = e.DbgName), h
                }
            }, i.Loader.Handlers = {
                handlers: [],
                add: function(e, t) {
                    this.handlers.push(e, t)
                },
                get: function(e) {
                    for (var t = 0, n = this.handlers.length; n > t; t += 2) {
                        var i = this.handlers[t],
                            r = this.handlers[t + 1];
                        if (i.test(e)) return r
                    }
                    return null
                }
            }, i.XHRLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager
            }, i.XHRLoader.prototype = {
                constructor: i.XHRLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = i.Cache.get(e);
                    if (void 0 !== a) return void(t && t(a));
                    var s = new XMLHttpRequest;
                    s.open("GET", e, !0), s.addEventListener("load", function(n) {
                        i.Cache.add(e, this.response), t && t(this.response), o.manager.itemEnd(e)
                    }, !1), void 0 !== n && s.addEventListener("progress", function(e) {
                        n(e)
                    }, !1), void 0 !== r && s.addEventListener("error", function(e) {
                        r(e)
                    }, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (s.responseType = this.responseType), s.send(null), o.manager.itemStart(e)
                },
                setResponseType: function(e) {
                    this.responseType = e
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                }
            }, i.ImageLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager
            }, i.ImageLoader.prototype = {
                constructor: i.ImageLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = i.Cache.get(e);
                    if (void 0 !== a) return void t(a);
                    var s = document.createElement("img");
                    return s.addEventListener("load", function(n) {
                        i.Cache.add(e, this), t && t(this), o.manager.itemEnd(e)
                    }, !1), void 0 !== n && s.addEventListener("progress", function(e) {
                        n(e)
                    }, !1), void 0 !== r && s.addEventListener("error", function(e) {
                        r(e)
                    }, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), s.src = e, o.manager.itemStart(e), s
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                }
            }, i.JSONLoader = function(e) {
                i.Loader.call(this, e), this.withCredentials = !1
            }, i.JSONLoader.prototype = Object.create(i.Loader.prototype), i.JSONLoader.prototype.constructor = i.JSONLoader, i.JSONLoader.prototype.load = function(e, t, n) {
                n = n && "string" == typeof n ? n : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n)
            }, i.JSONLoader.prototype.loadAjaxJSON = function(e, t, n, r, o) {
                var a = new XMLHttpRequest,
                    s = 0;
                a.onreadystatechange = function() {
                    if (a.readyState === a.DONE)
                        if (200 === a.status || 0 === a.status) {
                            if (a.responseText) {
                                var l = JSON.parse(a.responseText),
                                    c = l.metadata;
                                if (void 0 !== c) {
                                    if ("object" === c.type) return void i.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                                    if ("scene" === c.type) return void i.error("THREE.JSONLoader: " + t + " seems to be a Scene. Use THREE.SceneLoader instead.")
                                }
                                var h = e.parse(l, r);
                                n(h.geometry, h.materials)
                            } else i.error("THREE.JSONLoader: " + t + " seems to be unreachable or the file is empty.");
                            e.onLoadComplete()
                        } else i.error("THREE.JSONLoader: Couldn't load " + t + " (" + a.status + ")");
                    else a.readyState === a.LOADING ? o && (0 === s && (s = a.getResponseHeader("Content-Length")), o({
                        total: s,
                        loaded: a.responseText.length
                    })) : a.readyState === a.HEADERS_RECEIVED && void 0 !== o && (s = a.getResponseHeader("Content-Length"))
                }, a.open("GET", t, !0), a.withCredentials = this.withCredentials, a.send(null)
            }, i.JSONLoader.prototype.parse = function(e, t) {
                function n(t) {
                    function n(e, t) {
                        return e & 1 << t
                    }
                    var r, o, s, l, c, h, u, f, d, p, m, v, g, y, x, w, _, b, E, M, S, T, C, A, P, D, L, R = e.faces,
                        O = e.vertices,
                        N = e.normals,
                        U = e.colors,
                        F = 0;
                    if (void 0 !== e.uvs) {
                        for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && F++;
                        for (r = 0; F > r; r++) a.faceVertexUvs[r] = []
                    }
                    for (l = 0, c = O.length; c > l;) b = new i.Vector3, b.x = O[l++] * t, b.y = O[l++] * t, b.z = O[l++] * t, a.vertices.push(b);
                    for (l = 0, c = R.length; c > l;)
                        if (p = R[l++], m = n(p, 0), v = n(p, 1), g = n(p, 3), y = n(p, 4), x = n(p, 5), w = n(p, 6), _ = n(p, 7), m) {
                            if (M = new i.Face3, M.a = R[l], M.b = R[l + 1], M.c = R[l + 3], S = new i.Face3, S.a = R[l + 1], S.b = R[l + 2], S.c = R[l + 3], l += 4, v && (d = R[l++], M.materialIndex = d, S.materialIndex = d), s = a.faces.length, g)
                                for (r = 0; F > r; r++)
                                    for (A = e.uvs[r], a.faceVertexUvs[r][s] = [], a.faceVertexUvs[r][s + 1] = [], o = 0; 4 > o; o++) f = R[l++], D = A[2 * f], L = A[2 * f + 1], P = new i.Vector2(D, L), 2 !== o && a.faceVertexUvs[r][s].push(P), 0 !== o && a.faceVertexUvs[r][s + 1].push(P);
                            if (y && (u = 3 * R[l++], M.normal.set(N[u++], N[u++], N[u]), S.normal.copy(M.normal)), x)
                                for (r = 0; 4 > r; r++) u = 3 * R[l++], C = new i.Vector3(N[u++], N[u++], N[u]), 2 !== r && M.vertexNormals.push(C), 0 !== r && S.vertexNormals.push(C);
                            if (w && (h = R[l++], T = U[h], M.color.setHex(T), S.color.setHex(T)), _)
                                for (r = 0; 4 > r; r++) h = R[l++], T = U[h], 2 !== r && M.vertexColors.push(new i.Color(T)), 0 !== r && S.vertexColors.push(new i.Color(T));
                            a.faces.push(M), a.faces.push(S)
                        } else {
                            if (E = new i.Face3, E.a = R[l++], E.b = R[l++], E.c = R[l++], v && (d = R[l++], E.materialIndex = d), s = a.faces.length, g)
                                for (r = 0; F > r; r++)
                                    for (A = e.uvs[r], a.faceVertexUvs[r][s] = [], o = 0; 3 > o; o++) f = R[l++], D = A[2 * f], L = A[2 * f + 1], P = new i.Vector2(D, L), a.faceVertexUvs[r][s].push(P);
                            if (y && (u = 3 * R[l++], E.normal.set(N[u++], N[u++], N[u])), x)
                                for (r = 0; 3 > r; r++) u = 3 * R[l++], C = new i.Vector3(N[u++], N[u++], N[u]), E.vertexNormals.push(C);
                            if (w && (h = R[l++], E.color.setHex(U[h])), _)
                                for (r = 0; 3 > r; r++) h = R[l++], E.vertexColors.push(new i.Color(U[h]));
                            a.faces.push(E)
                        }
                }

                function r() {
                    var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                    if (e.skinWeights)
                        for (var n = 0, r = e.skinWeights.length; r > n; n += t) {
                            var o = e.skinWeights[n],
                                s = t > 1 ? e.skinWeights[n + 1] : 0,
                                l = t > 2 ? e.skinWeights[n + 2] : 0,
                                c = t > 3 ? e.skinWeights[n + 3] : 0;
                            a.skinWeights.push(new i.Vector4(o, s, l, c))
                        }
                    if (e.skinIndices)
                        for (var n = 0, r = e.skinIndices.length; r > n; n += t) {
                            var h = e.skinIndices[n],
                                u = t > 1 ? e.skinIndices[n + 1] : 0,
                                f = t > 2 ? e.skinIndices[n + 2] : 0,
                                d = t > 3 ? e.skinIndices[n + 3] : 0;
                            a.skinIndices.push(new i.Vector4(h, u, f, d))
                        }
                    a.bones = e.bones, a.bones && a.bones.length > 0 && (a.skinWeights.length !== a.skinIndices.length || a.skinIndices.length !== a.vertices.length) && i.warn("THREE.JSONLoader: When skinning, number of vertices (" + a.vertices.length + "), skinIndices (" + a.skinIndices.length + "), and skinWeights (" + a.skinWeights.length + ") should match."), a.animation = e.animation, a.animations = e.animations
                }

                function o(t) {
                    if (void 0 !== e.morphTargets) {
                        var n, r, o, s, l, c;
                        for (n = 0, r = e.morphTargets.length; r > n; n++)
                            for (a.morphTargets[n] = {}, a.morphTargets[n].name = e.morphTargets[n].name, a.morphTargets[n].vertices = [], l = a.morphTargets[n].vertices, c = e.morphTargets[n].vertices, o = 0, s = c.length; s > o; o += 3) {
                                var h = new i.Vector3;
                                h.x = c[o] * t, h.y = c[o + 1] * t, h.z = c[o + 2] * t, l.push(h)
                            }
                    }
                    if (void 0 !== e.morphColors) {
                        var n, r, u, f, d, p, m;
                        for (n = 0, r = e.morphColors.length; r > n; n++)
                            for (a.morphColors[n] = {}, a.morphColors[n].name = e.morphColors[n].name, a.morphColors[n].colors = [], d = a.morphColors[n].colors, p = e.morphColors[n].colors, u = 0, f = p.length; f > u; u += 3) m = new i.Color(16755200), m.setRGB(p[u], p[u + 1], p[u + 2]), d.push(m)
                    }
                }
                var a = new i.Geometry,
                    s = void 0 !== e.scale ? 1 / e.scale : 1;
                if (n(s), r(), o(s), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length) return {
                    geometry: a
                };
                var l = this.initMaterials(e.materials, t);
                return this.needsTangents(l) && a.computeTangents(), {
                    geometry: a,
                    materials: l
                }
            }, i.LoadingManager = function(e, t, n) {
                var i = this,
                    r = 0,
                    o = 0;
                this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    o++
                }, this.itemEnd = function(e) {
                    r++, void 0 !== i.onProgress && i.onProgress(e, r, o), r === o && void 0 !== i.onLoad && i.onLoad();
                }
            }, i.DefaultLoadingManager = new i.LoadingManager, i.BufferGeometryLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager
            }, i.BufferGeometryLoader.prototype = {
                constructor: i.BufferGeometryLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = new i.XHRLoader(o.manager);
                    a.setCrossOrigin(this.crossOrigin), a.load(e, function(e) {
                        t(o.parse(JSON.parse(e)))
                    }, n, r)
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                parse: function(e) {
                    var t = new i.BufferGeometry,
                        n = e.data.attributes;
                    for (var r in n) {
                        var o = n[r],
                            a = new self[o.type](o.array);
                        t.addAttribute(r, new i.BufferAttribute(a, o.itemSize))
                    }
                    var s = e.data.offsets;
                    void 0 !== s && (t.offsets = JSON.parse(JSON.stringify(s)));
                    var l = e.data.boundingSphere;
                    if (void 0 !== l) {
                        var c = new i.Vector3;
                        void 0 !== l.center && c.fromArray(l.center), t.boundingSphere = new i.Sphere(c, l.radius)
                    }
                    return t
                }
            }, i.MaterialLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager
            }, i.MaterialLoader.prototype = {
                constructor: i.MaterialLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = new i.XHRLoader(o.manager);
                    a.setCrossOrigin(this.crossOrigin), a.load(e, function(e) {
                        t(o.parse(JSON.parse(e)))
                    }, n, r)
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                parse: function(e) {
                    var t = new i[e.type];
                    if (void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.uniforms && (t.uniforms = e.uniforms), void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.shading && (t.shading = e.shading), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe), void 0 !== e.size && (t.size = e.size), void 0 !== e.sizeAttenuation && (t.sizeAttenuation = e.sizeAttenuation), void 0 !== e.materials)
                        for (var n = 0, r = e.materials.length; r > n; n++) t.materials.push(this.parse(e.materials[n]));
                    return t
                }
            }, i.ObjectLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager, this.texturePath = ""
            }, i.ObjectLoader.prototype = {
                constructor: i.ObjectLoader,
                load: function(e, t, n, r) {
                    "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
                    var o = this,
                        a = new i.XHRLoader(o.manager);
                    a.setCrossOrigin(this.crossOrigin), a.load(e, function(e) {
                        o.parse(JSON.parse(e), t)
                    }, n, r)
                },
                setTexturePath: function(e) {
                    this.texturePath = e
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                parse: function(e, t) {
                    var n = this.parseGeometries(e.geometries),
                        i = this.parseImages(e.images, function() {
                            void 0 !== t && t(a)
                        }),
                        r = this.parseTextures(e.textures, i),
                        o = this.parseMaterials(e.materials, r),
                        a = this.parseObject(e.object, n, o);
                    return void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(a), a
                },
                parseGeometries: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = new i.JSONLoader, r = new i.BufferGeometryLoader, o = 0, a = e.length; a > o; o++) {
                            var s, l = e[o];
                            switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new i[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "CubeGeometry":
                                    s = new i.BoxGeometry(l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                    s = new i.CircleGeometry(l.radius, l.segments);
                                    break;
                                case "CylinderGeometry":
                                    s = new i.CylinderGeometry(l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded);
                                    break;
                                case "SphereGeometry":
                                    s = new i.SphereGeometry(l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                    break;
                                case "IcosahedronGeometry":
                                    s = new i.IcosahedronGeometry(l.radius, l.detail);
                                    break;
                                case "TorusGeometry":
                                    s = new i.TorusGeometry(l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                    s = new i.TorusKnotGeometry(l.radius, l.tube, l.radialSegments, l.tubularSegments, l.p, l.q, l.heightScale);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(l);
                                    break;
                                case "Geometry":
                                    s = n.parse(l.data).geometry
                            }
                            s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), t[l.uuid] = s
                        }
                    return t
                },
                parseMaterials: function(e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = function(e) {
                            return void 0 === t[e] && i.warn("THREE.ObjectLoader: Undefined texture", e), t[e]
                        }, o = new i.MaterialLoader, a = 0, s = e.length; s > a; a++) {
                            var l = e[a],
                                c = o.parse(l);
                            c.uuid = l.uuid, void 0 !== l.name && (c.name = l.name), void 0 !== l.map && (c.map = r(l.map)), void 0 !== l.bumpMap && (c.bumpMap = r(l.bumpMap), l.bumpScale && (c.bumpScale = new i.Vector2(l.bumpScale, l.bumpScale))), void 0 !== l.alphaMap && (c.alphaMap = r(l.alphaMap)), void 0 !== l.envMap && (c.envMap = r(l.envMap)), void 0 !== l.normalMap && (c.normalMap = r(l.normalMap), l.normalScale && (c.normalScale = new i.Vector2(l.normalScale, l.normalScale))), void 0 !== l.lightMap && (c.lightMap = r(l.lightMap)), void 0 !== l.specularMap && (c.specularMap = r(l.specularMap)), n[l.uuid] = c
                        }
                    return n
                },
                parseImages: function(e, t) {
                    var n = this,
                        r = {};
                    if (void 0 !== e && e.length > 0) {
                        var o = new i.LoadingManager(t),
                            a = new i.ImageLoader(o);
                        a.setCrossOrigin(this.crossOrigin);
                        for (var s = function(e) {
                            return n.manager.itemStart(e), a.load(e, function() {
                                n.manager.itemEnd(e)
                            })
                        }, l = 0, c = e.length; c > l; l++) {
                            var h = e[l],
                                u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : n.texturePath + h.url;
                            r[h.uuid] = s(u)
                        }
                    }
                    return r
                },
                parseTextures: function(e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = 0, o = e.length; o > r; r++) {
                            var a = e[r];
                            void 0 === a.image && i.warn('THREE.ObjectLoader: No "image" speficied for', a.uuid), void 0 === t[a.image] && i.warn("THREE.ObjectLoader: Undefined image", a.image);
                            var s = new i.Texture(t[a.image]);
                            s.needsUpdate = !0, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.repeat && (s.repeat = new i.Vector2(a.repeat[0], a.repeat[1])), void 0 !== a.minFilter && (s.minFilter = i[a.minFilter]), void 0 !== a.magFilter && (s.magFilter = i[a.magFilter]), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), a.wrap instanceof Array && (s.wrapS = i[a.wrap[0]], s.wrapT = i[a.wrap[1]]), n[a.uuid] = s
                        }
                    return n
                },
                parseObject: function() {
                    var e = new i.Matrix4;
                    return function(t, n, r) {
                        var o, a = function(e) {
                                return void 0 === n[e] && i.warn("THREE.ObjectLoader: Undefined geometry", e), n[e]
                            },
                            s = function(e) {
                                return void 0 === r[e] && i.warn("THREE.ObjectLoader: Undefined material", e), r[e]
                            };
                        switch (t.type) {
                            case "Scene":
                                o = new i.Scene;
                                break;
                            case "PerspectiveCamera":
                                o = new i.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                                break;
                            case "OrthographicCamera":
                                o = new i.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                                break;
                            case "AmbientLight":
                                o = new i.AmbientLight(t.color);
                                break;
                            case "DirectionalLight":
                                o = new i.DirectionalLight(t.color, t.intensity);
                                break;
                            case "PointLight":
                                o = new i.PointLight(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "SpotLight":
                                o = new i.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent, t.decay);
                                break;
                            case "HemisphereLight":
                                o = new i.HemisphereLight(t.color, t.groundColor, t.intensity);
                                break;
                            case "Mesh":
                                o = new i.Mesh(a(t.geometry), s(t.material));
                                break;
                            case "Line":
                                o = new i.Line(a(t.geometry), s(t.material), t.mode);
                                break;
                            case "PointCloud":
                                o = new i.PointCloud(a(t.geometry), s(t.material));
                                break;
                            case "Sprite":
                                o = new i.Sprite(s(t.material));
                                break;
                            case "Group":
                                o = new i.Group;
                                break;
                            default:
                                o = new i.Object3D
                        }
                        if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.children)
                            for (var l in t.children) o.add(this.parseObject(t.children[l], n, r));
                        return o
                    }
                }()
            }, i.TextureLoader = function(e) {
                this.manager = void 0 !== e ? e : i.DefaultLoadingManager
            }, i.TextureLoader.prototype = {
                constructor: i.TextureLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = new i.ImageLoader(o.manager);
                    a.setCrossOrigin(this.crossOrigin), a.load(e, function(e) {
                        var n = new i.Texture(e);
                        n.needsUpdate = !0, void 0 !== t && t(n)
                    }, n, r)
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                }
            }, i.DataTextureLoader = i.BinaryTextureLoader = function() {
                this._parser = null
            }, i.BinaryTextureLoader.prototype = {
                constructor: i.BinaryTextureLoader,
                load: function(e, t, n, r) {
                    var o = this,
                        a = new i.DataTexture,
                        s = new i.XHRLoader;
                    return s.setResponseType("arraybuffer"), s.load(e, function(e) {
                        var n = o._parser(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : i.ClampToEdgeWrapping, a.wrapT = void 0 !== n.wrapT ? n.wrapT : i.ClampToEdgeWrapping, a.magFilter = void 0 !== n.magFilter ? n.magFilter : i.LinearFilter, a.minFilter = void 0 !== n.minFilter ? n.minFilter : i.LinearMipMapLinearFilter, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = i.LinearFilter), a.needsUpdate = !0, t && t(a, n))
                    }, n, r), a
                }
            }, i.CompressedTextureLoader = function() {
                this._parser = null
            }, i.CompressedTextureLoader.prototype = {
                constructor: i.CompressedTextureLoader,
                load: function(e, t, n) {
                    var r = this,
                        o = [],
                        a = new i.CompressedTexture;
                    a.image = o;
                    var s = new i.XHRLoader;
                    if (s.setResponseType("arraybuffer"), e instanceof Array)
                        for (var l = 0, c = function(n) {
                            s.load(e[n], function(e) {
                                var s = r._parser(e, !0);
                                o[n] = {
                                    width: s.width,
                                    height: s.height,
                                    format: s.format,
                                    mipmaps: s.mipmaps
                                }, l += 1, 6 === l && (1 == s.mipmapCount && (a.minFilter = i.LinearFilter), a.format = s.format, a.needsUpdate = !0, t && t(a))
                            })
                        }, h = 0, u = e.length; u > h; ++h) c(h);
                    else s.load(e, function(e) {
                        var n = r._parser(e, !0);
                        if (n.isCubemap)
                            for (var s = n.mipmaps.length / n.mipmapCount, l = 0; s > l; l++) {
                                o[l] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) o[l].mipmaps.push(n.mipmaps[l * n.mipmapCount + c]), o[l].format = n.format, o[l].width = n.width, o[l].height = n.height
                            } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = i.LinearFilter), a.format = n.format, a.needsUpdate = !0, t && t(a)
                    });
                    return a
                }
            }, i.Material = function() {
                Object.defineProperty(this, "id", {
                    value: i.MaterialIdCount++
                }), this.uuid = i.Math.generateUUID(), this.name = "", this.type = "Material", this.side = i.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = i.NormalBlending, this.blendSrc = i.SrcAlphaFactor, this.blendDst = i.OneMinusSrcAlphaFactor, this.blendEquation = i.AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthTest = !0, this.depthWrite = !0, this.colorWrite = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.overdraw = 0, this.visible = !0, this._needsUpdate = !0
            }, i.Material.prototype = {
                constructor: i.Material,
                get needsUpdate() {
                    return this._needsUpdate
                },
                set needsUpdate(e) {
                    e === !0 && this.update(), this._needsUpdate = e
                },
                setValues: function(e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n) {
                                if (t in this) {
                                    var r = this[t];
                                    r instanceof i.Color ? r.set(n) : r instanceof i.Vector3 && n instanceof i.Vector3 ? r.copy(n) : "overdraw" == t ? this[t] = Number(n) : this[t] = n
                                }
                            } else i.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function() {
                    var e = {
                        metadata: {
                            version: 4.2,
                            type: "material",
                            generator: "MaterialExporter"
                        },
                        uuid: this.uuid,
                        type: this.type
                    };
                    return "" !== this.name && (e.name = this.name), this instanceof i.MeshBasicMaterial ? (e.color = this.color.getHex(), this.vertexColors !== i.NoColors && (e.vertexColors = this.vertexColors), this.blending !== i.NormalBlending && (e.blending = this.blending), this.side !== i.FrontSide && (e.side = this.side)) : this instanceof i.MeshLambertMaterial ? (e.color = this.color.getHex(), e.emissive = this.emissive.getHex(), this.vertexColors !== i.NoColors && (e.vertexColors = this.vertexColors), this.shading !== i.SmoothShading && (e.shading = this.shading), this.blending !== i.NormalBlending && (e.blending = this.blending), this.side !== i.FrontSide && (e.side = this.side)) : this instanceof i.MeshPhongMaterial ? (e.color = this.color.getHex(), e.emissive = this.emissive.getHex(), e.specular = this.specular.getHex(), e.shininess = this.shininess, this.vertexColors !== i.NoColors && (e.vertexColors = this.vertexColors), this.shading !== i.SmoothShading && (e.shading = this.shading), this.blending !== i.NormalBlending && (e.blending = this.blending), this.side !== i.FrontSide && (e.side = this.side)) : this instanceof i.MeshNormalMaterial ? (this.blending !== i.NormalBlending && (e.blending = this.blending), this.side !== i.FrontSide && (e.side = this.side)) : this instanceof i.MeshDepthMaterial ? (this.blending !== i.NormalBlending && (e.blending = this.blending), this.side !== i.FrontSide && (e.side = this.side)) : this instanceof i.PointCloudMaterial ? (e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.color = this.color.getHex(), this.vertexColors !== i.NoColors && (e.vertexColors = this.vertexColors), this.blending !== i.NormalBlending && (e.blending = this.blending)) : this instanceof i.ShaderMaterial ? (e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader) : this instanceof i.SpriteMaterial && (e.color = this.color.getHex()), this.opacity < 1 && (e.opacity = this.opacity), this.transparent !== !1 && (e.transparent = this.transparent), this.wireframe !== !1 && (e.wireframe = this.wireframe), e
                },
                clone: function(e) {
                    return void 0 === e && (e = new i.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.blendSrcAlpha = this.blendSrcAlpha, e.blendDstAlpha = this.blendDstAlpha, e.blendEquationAlpha = this.blendEquationAlpha, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
                },
                update: function() {
                    this.dispatchEvent({
                        type: "update"
                    })
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, i.EventDispatcher.prototype.apply(i.Material.prototype), i.MaterialIdCount = 0, i.LineBasicMaterial = function(e) {
                i.Material.call(this), this.type = "LineBasicMaterial", this.color = new i.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = i.NoColors, this.fog = !0, this.setValues(e)
            }, i.LineBasicMaterial.prototype = Object.create(i.Material.prototype), i.LineBasicMaterial.prototype.constructor = i.LineBasicMaterial, i.LineBasicMaterial.prototype.clone = function() {
                var e = new i.LineBasicMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
            }, i.LineDashedMaterial = function(e) {
                i.Material.call(this), this.type = "LineDashedMaterial", this.color = new i.Color(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
            }, i.LineDashedMaterial.prototype = Object.create(i.Material.prototype), i.LineDashedMaterial.prototype.constructor = i.LineDashedMaterial, i.LineDashedMaterial.prototype.clone = function() {
                var e = new i.LineDashedMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
            }, i.MeshBasicMaterial = function(e) {
                i.Material.call(this), this.type = "MeshBasicMaterial", this.color = new i.Color(16777215), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = i.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = i.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = i.NoColors, this.skinning = !1, this.morphTargets = !1, this.setValues(e)
            }, i.MeshBasicMaterial.prototype = Object.create(i.Material.prototype), i.MeshBasicMaterial.prototype.constructor = i.MeshBasicMaterial, i.MeshBasicMaterial.prototype.clone = function() {
                var e = new i.MeshBasicMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
            }, i.MeshLambertMaterial = function(e) {
                i.Material.call(this), this.type = "MeshLambertMaterial", this.color = new i.Color(16777215), this.emissive = new i.Color(0), this.wrapAround = !1, this.wrapRGB = new i.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = i.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = i.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = i.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }, i.MeshLambertMaterial.prototype = Object.create(i.Material.prototype), i.MeshLambertMaterial.prototype.constructor = i.MeshLambertMaterial, i.MeshLambertMaterial.prototype.clone = function() {
                var e = new i.MeshLambertMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
            }, i.MeshPhongMaterial = function(e) {
                i.Material.call(this), this.type = "MeshPhongMaterial", this.color = new i.Color(16777215), this.emissive = new i.Color(0), this.specular = new i.Color(1118481), this.shininess = 30, this.metal = !1, this.wrapAround = !1, this.wrapRGB = new i.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i.Vector2(1, 1), this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = i.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = i.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = i.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }, i.MeshPhongMaterial.prototype = Object.create(i.Material.prototype), i.MeshPhongMaterial.prototype.constructor = i.MeshPhongMaterial, i.MeshPhongMaterial.prototype.clone = function() {
                var e = new i.MeshPhongMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
            }, i.MeshDepthMaterial = function(e) {
                i.Material.call(this), this.type = "MeshDepthMaterial", this.morphTargets = !1, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
            }, i.MeshDepthMaterial.prototype = Object.create(i.Material.prototype), i.MeshDepthMaterial.prototype.constructor = i.MeshDepthMaterial, i.MeshDepthMaterial.prototype.clone = function() {
                var e = new i.MeshDepthMaterial;
                return i.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
            }, i.MeshNormalMaterial = function(e) {
                i.Material.call(this, e), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
            }, i.MeshNormalMaterial.prototype = Object.create(i.Material.prototype), i.MeshNormalMaterial.prototype.constructor = i.MeshNormalMaterial, i.MeshNormalMaterial.prototype.clone = function() {
                var e = new i.MeshNormalMaterial;
                return i.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
            }, i.MeshFaceMaterial = function(e) {
                this.uuid = i.Math.generateUUID(), this.type = "MeshFaceMaterial", this.materials = e instanceof Array ? e : []
            }, i.MeshFaceMaterial.prototype = {
                constructor: i.MeshFaceMaterial,
                toJSON: function() {
                    for (var e = {
                        metadata: {
                            version: 4.2,
                            type: "material",
                            generator: "MaterialExporter"
                        },
                        uuid: this.uuid,
                        type: this.type,
                        materials: []
                    }, t = 0, n = this.materials.length; n > t; t++) e.materials.push(this.materials[t].toJSON());
                    return e
                },
                clone: function() {
                    for (var e = new i.MeshFaceMaterial, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
                    return e
                }
            }, i.PointCloudMaterial = function(e) {
                i.Material.call(this), this.type = "PointCloudMaterial", this.color = new i.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = i.NoColors, this.fog = !0, this.setValues(e)
            }, i.PointCloudMaterial.prototype = Object.create(i.Material.prototype), i.PointCloudMaterial.prototype.constructor = i.PointCloudMaterial, i.PointCloudMaterial.prototype.clone = function() {
                var e = new i.PointCloudMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
            }, i.ParticleBasicMaterial = function(e) {
                return i.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new i.PointCloudMaterial(e)
            }, i.ParticleSystemMaterial = function(e) {
                return i.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new i.PointCloudMaterial(e)
            }, i.ShaderMaterial = function(e) {
                i.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = i.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.vertexColors = i.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.setValues(e)
            }, i.ShaderMaterial.prototype = Object.create(i.Material.prototype), i.ShaderMaterial.prototype.constructor = i.ShaderMaterial, i.ShaderMaterial.prototype.clone = function() {
                var e = new i.ShaderMaterial;
                return i.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = i.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
            }, i.RawShaderMaterial = function(e) {
                i.ShaderMaterial.call(this, e), this.type = "RawShaderMaterial"
            }, i.RawShaderMaterial.prototype = Object.create(i.ShaderMaterial.prototype), i.RawShaderMaterial.prototype.constructor = i.RawShaderMaterial, i.RawShaderMaterial.prototype.clone = function() {
                var e = new i.RawShaderMaterial;
                return i.ShaderMaterial.prototype.clone.call(this, e), e
            }, i.SpriteMaterial = function(e) {
                i.Material.call(this), this.type = "SpriteMaterial", this.color = new i.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
            }, i.SpriteMaterial.prototype = Object.create(i.Material.prototype), i.SpriteMaterial.prototype.constructor = i.SpriteMaterial, i.SpriteMaterial.prototype.clone = function() {
                var e = new i.SpriteMaterial;
                return i.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
            }, i.Texture = function(e, t, n, r, o, a, s, l, c) {
                Object.defineProperty(this, "id", {
                    value: i.TextureIdCount++
                }), this.uuid = i.Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== e ? e : i.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : i.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : i.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : i.ClampToEdgeWrapping, this.magFilter = void 0 !== o ? o : i.LinearFilter, this.minFilter = void 0 !== a ? a : i.LinearMipMapLinearFilter, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : i.RGBAFormat, this.type = void 0 !== l ? l : i.UnsignedByteType, this.offset = new i.Vector2(0, 0), this.repeat = new i.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
            }, i.Texture.DEFAULT_IMAGE = void 0, i.Texture.DEFAULT_MAPPING = i.UVMapping, i.Texture.prototype = {
                constructor: i.Texture,
                get needsUpdate() {
                    return this._needsUpdate
                },
                set needsUpdate(e) {
                    e === !0 && this.update(), this._needsUpdate = e
                },
                clone: function(e) {
                    return void 0 === e && (e = new i.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
                },
                update: function() {
                    this.dispatchEvent({
                        type: "update"
                    })
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, i.EventDispatcher.prototype.apply(i.Texture.prototype), i.TextureIdCount = 0, i.CubeTexture = function(e, t, n, r, o, a, s, l, c) {
                t = void 0 !== t ? t : i.CubeReflectionMapping, i.Texture.call(this, e, t, n, r, o, a, s, l, c), this.images = e
            }, i.CubeTexture.prototype = Object.create(i.Texture.prototype), i.CubeTexture.prototype.constructor = i.CubeTexture, i.CubeTexture.clone = function(e) {
                return void 0 === e && (e = new i.CubeTexture), i.Texture.prototype.clone.call(this, e), e.images = this.images, e
            }, i.CompressedTexture = function(e, t, n, r, o, a, s, l, c, h, u) {
                i.Texture.call(this, null, a, s, l, c, h, r, o, u), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }, i.CompressedTexture.prototype = Object.create(i.Texture.prototype), i.CompressedTexture.prototype.constructor = i.CompressedTexture, i.CompressedTexture.prototype.clone = function() {
                var e = new i.CompressedTexture;
                return i.Texture.prototype.clone.call(this, e), e
            }, i.DataTexture = function(e, t, n, r, o, a, s, l, c, h, u) {
                i.Texture.call(this, null, a, s, l, c, h, r, o, u), this.image = {
                    data: e,
                    width: t,
                    height: n
                }
            }, i.DataTexture.prototype = Object.create(i.Texture.prototype), i.DataTexture.prototype.constructor = i.DataTexture, i.DataTexture.prototype.clone = function() {
                var e = new i.DataTexture;
                return i.Texture.prototype.clone.call(this, e), e
            }, i.VideoTexture = function(e, t, n, r, o, a, s, l, c) {
                i.Texture.call(this, e, t, n, r, o, a, s, l, c), this.generateMipmaps = !1;
                var h = this,
                    u = function() {
                        requestAnimationFrame(u), e.readyState === e.HAVE_ENOUGH_DATA && (h.needsUpdate = !0)
                    };
                u()
            }, i.VideoTexture.prototype = Object.create(i.Texture.prototype), i.VideoTexture.prototype.constructor = i.VideoTexture, i.Group = function() {
                i.Object3D.call(this), this.type = "Group"
            }, i.Group.prototype = Object.create(i.Object3D.prototype), i.Group.prototype.constructor = i.Group, i.PointCloud = function(e, t) {
                i.Object3D.call(this), this.type = "PointCloud", this.geometry = void 0 !== e ? e : new i.Geometry, this.material = void 0 !== t ? t : new i.PointCloudMaterial({
                    color: 16777215 * Math.random()
                })
            }, i.PointCloud.prototype = Object.create(i.Object3D.prototype), i.PointCloud.prototype.constructor = i.PointCloud, i.PointCloud.prototype.raycast = function() {
                var e = new i.Matrix4,
                    t = new i.Ray;
                return function(n, r) {
                    var o = this,
                        a = o.geometry,
                        s = n.params.PointCloud.threshold;
                    if (e.getInverse(this.matrixWorld), t.copy(n.ray).applyMatrix4(e), null === a.boundingBox || t.isIntersectionBox(a.boundingBox) !== !1) {
                        var l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            c = new i.Vector3,
                            h = function(e, i) {
                                var a = t.distanceToPoint(e);
                                if (l > a) {
                                    var s = t.closestPointToPoint(e);
                                    s.applyMatrix4(o.matrixWorld);
                                    var c = n.ray.origin.distanceTo(s);
                                    r.push({
                                        distance: c,
                                        distanceToRay: a,
                                        point: s.clone(),
                                        index: i,
                                        face: null,
                                        object: o
                                    })
                                }
                            };
                        if (a instanceof i.BufferGeometry) {
                            var u = a.attributes,
                                f = u.position.array;
                            if (void 0 !== u.index) {
                                var d = u.index.array,
                                    p = a.offsets;
                                if (0 === p.length) {
                                    var m = {
                                        start: 0,
                                        count: d.length,
                                        index: 0
                                    };
                                    p = [m]
                                }
                                for (var v = 0, g = p.length; g > v; ++v)
                                    for (var y = p[v].start, x = p[v].count, w = p[v].index, _ = y, b = y + x; b > _; _++) {
                                        var E = w + d[_];
                                        c.fromArray(f, 3 * E), h(c, E)
                                    }
                            } else
                                for (var M = f.length / 3, _ = 0; M > _; _++) c.set(f[3 * _], f[3 * _ + 1], f[3 * _ + 2]), h(c, _)
                        } else
                            for (var S = this.geometry.vertices, _ = 0; _ < S.length; _++) h(S[_], _)
                    }
                }
            }(), i.PointCloud.prototype.clone = function(e) {
                return void 0 === e && (e = new i.PointCloud(this.geometry, this.material)), i.Object3D.prototype.clone.call(this, e), e
            }, i.ParticleSystem = function(e, t) {
                return i.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new i.PointCloud(e, t)
            }, i.Line = function(e, t, n) {
                i.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new i.Geometry, this.material = void 0 !== t ? t : new i.LineBasicMaterial({
                    color: 16777215 * Math.random()
                }), this.mode = void 0 !== n ? n : i.LineStrip
            }, i.LineStrip = 0, i.LinePieces = 1, i.Line.prototype = Object.create(i.Object3D.prototype), i.Line.prototype.constructor = i.Line, i.Line.prototype.raycast = function() {
                var e = new i.Matrix4,
                    t = new i.Ray,
                    n = new i.Sphere;
                return function(r, o) {
                    var a = r.linePrecision,
                        s = a * a,
                        l = this.geometry;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), n.copy(l.boundingSphere), n.applyMatrix4(this.matrixWorld), r.ray.isIntersectionSphere(n) !== !1) {
                        e.getInverse(this.matrixWorld), t.copy(r.ray).applyMatrix4(e);
                        var c = new i.Vector3,
                            h = new i.Vector3,
                            u = new i.Vector3,
                            f = new i.Vector3,
                            d = this.mode === i.LineStrip ? 1 : 2;
                        if (l instanceof i.BufferGeometry) {
                            var p = l.attributes;
                            if (void 0 !== p.index) {
                                var m = p.index.array,
                                    v = p.position.array,
                                    g = l.offsets;
                                0 === g.length && (g = [{
                                    start: 0,
                                    count: m.length,
                                    index: 0
                                }]);
                                for (var y = 0; y < g.length; y++)
                                    for (var x = g[y].start, w = g[y].count, _ = g[y].index, b = x; x + w - 1 > b; b += d) {
                                        var E = _ + m[b],
                                            M = _ + m[b + 1];
                                        c.fromArray(v, 3 * E), h.fromArray(v, 3 * M);
                                        var S = t.distanceSqToSegment(c, h, f, u);
                                        if (!(S > s)) {
                                            var T = t.origin.distanceTo(f);
                                            T < r.near || T > r.far || o.push({
                                                distance: T,
                                                point: u.clone().applyMatrix4(this.matrixWorld),
                                                index: b,
                                                offsetIndex: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                            } else
                                for (var v = p.position.array, b = 0; b < v.length / 3 - 1; b += d) {
                                    c.fromArray(v, 3 * b), h.fromArray(v, 3 * b + 3);
                                    var S = t.distanceSqToSegment(c, h, f, u);
                                    if (!(S > s)) {
                                        var T = t.origin.distanceTo(f);
                                        T < r.near || T > r.far || o.push({
                                            distance: T,
                                            point: u.clone().applyMatrix4(this.matrixWorld),
                                            index: b,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        } else if (l instanceof i.Geometry)
                            for (var C = l.vertices, A = C.length, b = 0; A - 1 > b; b += d) {
                                var S = t.distanceSqToSegment(C[b], C[b + 1], f, u);
                                if (!(S > s)) {
                                    var T = t.origin.distanceTo(f);
                                    T < r.near || T > r.far || o.push({
                                        distance: T,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: b,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                }
            }(), i.Line.prototype.clone = function(e) {
                return void 0 === e && (e = new i.Line(this.geometry, this.material, this.mode)), i.Object3D.prototype.clone.call(this, e), e
            }, i.Mesh = function(e, t) {
                i.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new i.Geometry, this.material = void 0 !== t ? t : new i.MeshBasicMaterial({
                    color: 16777215 * Math.random()
                }), this.updateMorphTargets()
            }, i.Mesh.prototype = Object.create(i.Object3D.prototype), i.Mesh.prototype.constructor = i.Mesh, i.Mesh.prototype.updateMorphTargets = function() {
                if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                    this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (var e = 0, t = this.geometry.morphTargets.length; t > e; e++) this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
                }
            }, i.Mesh.prototype.getMorphTargetIndexByName = function(e) {
                return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (i.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
            }, i.Mesh.prototype.raycast = function() {
                var e = new i.Matrix4,
                    t = new i.Ray,
                    n = new i.Sphere,
                    r = new i.Vector3,
                    o = new i.Vector3,
                    a = new i.Vector3;
                return function(s, l) {
                    var c = this.geometry;
                    if (null === c.boundingSphere && c.computeBoundingSphere(), n.copy(c.boundingSphere), n.applyMatrix4(this.matrixWorld), s.ray.isIntersectionSphere(n) !== !1 && (e.getInverse(this.matrixWorld), t.copy(s.ray).applyMatrix4(e), null === c.boundingBox || t.isIntersectionBox(c.boundingBox) !== !1))
                        if (c instanceof i.BufferGeometry) {
                            var h = this.material;
                            if (void 0 === h) return;
                            var u, f, d, p = c.attributes,
                                m = s.precision;
                            if (void 0 !== p.index) {
                                var v = p.index.array,
                                    g = p.position.array,
                                    y = c.offsets;
                                0 === y.length && (y = [{
                                    start: 0,
                                    count: v.length,
                                    index: 0
                                }]);
                                for (var x = 0, w = y.length; w > x; ++x)
                                    for (var _ = y[x].start, b = y[x].count, E = y[x].index, M = _, S = _ + b; S > M; M += 3) {
                                        if (u = E + v[M], f = E + v[M + 1], d = E + v[M + 2], r.fromArray(g, 3 * u), o.fromArray(g, 3 * f), a.fromArray(g, 3 * d), h.side === i.BackSide) var T = t.intersectTriangle(a, o, r, !0);
                                        else var T = t.intersectTriangle(r, o, a, h.side !== i.DoubleSide); if (null !== T) {
                                            T.applyMatrix4(this.matrixWorld);
                                            var C = s.ray.origin.distanceTo(T);
                                            m > C || C < s.near || C > s.far || l.push({
                                                distance: C,
                                                point: T,
                                                face: new i.Face3(u, f, d, i.Triangle.normal(r, o, a)),
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                            } else
                                for (var g = p.position.array, M = 0, A = 0, S = g.length; S > M; M += 3, A += 9) {
                                    if (u = M, f = M + 1, d = M + 2, r.fromArray(g, A), o.fromArray(g, A + 3), a.fromArray(g, A + 6), h.side === i.BackSide) var T = t.intersectTriangle(a, o, r, !0);
                                    else var T = t.intersectTriangle(r, o, a, h.side !== i.DoubleSide); if (null !== T) {
                                        T.applyMatrix4(this.matrixWorld);
                                        var C = s.ray.origin.distanceTo(T);
                                        m > C || C < s.near || C > s.far || l.push({
                                            distance: C,
                                            point: T,
                                            face: new i.Face3(u, f, d, i.Triangle.normal(r, o, a)),
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        } else if (c instanceof i.Geometry)
                            for (var u, f, d, P = this.material instanceof i.MeshFaceMaterial, D = P === !0 ? this.material.materials : null, m = s.precision, L = c.vertices, R = 0, O = c.faces.length; O > R; R++) {
                                var N = c.faces[R],
                                    h = P === !0 ? D[N.materialIndex] : this.material;
                                if (void 0 !== h) {
                                    if (u = L[N.a], f = L[N.b], d = L[N.c], h.morphTargets === !0) {
                                        var U = c.morphTargets,
                                            F = this.morphTargetInfluences;
                                        r.set(0, 0, 0), o.set(0, 0, 0), a.set(0, 0, 0);
                                        for (var k = 0, H = U.length; H > k; k++) {
                                            var I = F[k];
                                            if (0 !== I) {
                                                var V = U[k].vertices;
                                                r.x += (V[N.a].x - u.x) * I, r.y += (V[N.a].y - u.y) * I, r.z += (V[N.a].z - u.z) * I, o.x += (V[N.b].x - f.x) * I, o.y += (V[N.b].y - f.y) * I, o.z += (V[N.b].z - f.z) * I, a.x += (V[N.c].x - d.x) * I, a.y += (V[N.c].y - d.y) * I, a.z += (V[N.c].z - d.z) * I
                                            }
                                        }
                                        r.add(u), o.add(f), a.add(d), u = r, f = o, d = a
                                    }
                                    if (h.side === i.BackSide) var T = t.intersectTriangle(d, f, u, !0);
                                    else var T = t.intersectTriangle(u, f, d, h.side !== i.DoubleSide); if (null !== T) {
                                        T.applyMatrix4(this.matrixWorld);
                                        var C = s.ray.origin.distanceTo(T);
                                        m > C || C < s.near || C > s.far || l.push({
                                            distance: C,
                                            point: T,
                                            face: N,
                                            faceIndex: R,
                                            object: this
                                        })
                                    }
                                }
                            }
                }
            }(), i.Mesh.prototype.clone = function(e, t) {
                return void 0 === e && (e = new i.Mesh(this.geometry, this.material)), i.Object3D.prototype.clone.call(this, e, t), e
            }, i.Bone = function(e) {
                i.Object3D.call(this), this.type = "Bone", this.skin = e
            }, i.Bone.prototype = Object.create(i.Object3D.prototype), i.Bone.prototype.constructor = i.Bone, i.Skeleton = function(e, t, n) {
                if (this.useVertexTexture = void 0 !== n ? n : !0, this.identityMatrix = new i.Matrix4, e = e || [], this.bones = e.slice(0), this.useVertexTexture) {
                    var r;
                    r = this.bones.length > 256 ? 64 : this.bones.length > 64 ? 32 : this.bones.length > 16 ? 16 : 8, this.boneTextureWidth = r, this.boneTextureHeight = r, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new i.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, i.RGBAFormat, i.FloatType), this.boneTexture.minFilter = i.NearestFilter, this.boneTexture.magFilter = i.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1
                } else this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    i.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
                    for (var o = 0, a = this.bones.length; a > o; o++) this.boneInverses.push(new i.Matrix4)
                }
            }, i.Skeleton.prototype.calculateInverses = function() {
                this.boneInverses = [];
                for (var e = 0, t = this.bones.length; t > e; e++) {
                    var n = new i.Matrix4;
                    this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                }
            }, i.Skeleton.prototype.pose = function() {
                for (var e, t = 0, n = this.bones.length; n > t; t++) e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
                for (var t = 0, n = this.bones.length; n > t; t++) e = this.bones[t], e && (e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
            }, i.Skeleton.prototype.update = function() {
                var e = new i.Matrix4;
                return function() {
                    for (var t = 0, n = this.bones.length; n > t; t++) {
                        var i = this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix;
                        e.multiplyMatrices(i, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t)
                    }
                    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                }
            }(), i.SkinnedMesh = function(e, t, n) {
                i.Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new i.Matrix4, this.bindMatrixInverse = new i.Matrix4;
                var r = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (var o, a, s, l, c, h = 0, u = this.geometry.bones.length; u > h; ++h) a = this.geometry.bones[h], s = a.pos, l = a.rotq, c = a.scl, o = new i.Bone(this), r.push(o), o.name = a.name, o.position.set(s[0], s[1], s[2]), o.quaternion.set(l[0], l[1], l[2], l[3]), void 0 !== c ? o.scale.set(c[0], c[1], c[2]) : o.scale.set(1, 1, 1);
                    for (var h = 0, u = this.geometry.bones.length; u > h; ++h) a = this.geometry.bones[h], -1 !== a.parent ? r[a.parent].add(r[h]) : this.add(r[h])
                }
                this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new i.Skeleton(r, void 0, n))
            }, i.SkinnedMesh.prototype = Object.create(i.Mesh.prototype), i.SkinnedMesh.prototype.constructor = i.SkinnedMesh, i.SkinnedMesh.prototype.bind = function(e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
            }, i.SkinnedMesh.prototype.pose = function() {
                this.skeleton.pose()
            }, i.SkinnedMesh.prototype.normalizeSkinWeights = function() {
                if (this.geometry instanceof i.Geometry)
                    for (var e = 0; e < this.geometry.skinIndices.length; e++) {
                        var t = this.geometry.skinWeights[e],
                            n = 1 / t.lengthManhattan();
                        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1)
                    }
            }, i.SkinnedMesh.prototype.updateMatrixWorld = function(e) {
                i.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : i.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
            }, i.SkinnedMesh.prototype.clone = function(e) {
                return void 0 === e && (e = new i.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), i.Mesh.prototype.clone.call(this, e), e
            }, i.MorphAnimMesh = function(e, t) {
                i.Mesh.call(this, e, t), this.type = "MorphAnimMesh", this.duration = 1e3, this.mirroredLoop = !1, this.time = 0, this.lastKeyframe = 0, this.currentKeyframe = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
            }, i.MorphAnimMesh.prototype = Object.create(i.Mesh.prototype), i.MorphAnimMesh.prototype.constructor = i.MorphAnimMesh, i.MorphAnimMesh.prototype.setFrameRange = function(e, t) {
                this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
            }, i.MorphAnimMesh.prototype.setDirectionForward = function() {
                this.direction = 1, this.directionBackwards = !1
            }, i.MorphAnimMesh.prototype.setDirectionBackward = function() {
                this.direction = -1, this.directionBackwards = !0
            }, i.MorphAnimMesh.prototype.parseAnimations = function() {
                var e = this.geometry;
                e.animations || (e.animations = {});
                for (var t, n = e.animations, i = /([a-z]+)_?(\d+)/, r = 0, o = e.morphTargets.length; o > r; r++) {
                    var a = e.morphTargets[r],
                        s = a.name.match(i);
                    if (s && s.length > 1) {
                        var l = s[1];
                        n[l] || (n[l] = {
                            start: 1 / 0,
                            end: -(1 / 0)
                        });
                        var c = n[l];
                        r < c.start && (c.start = r), r > c.end && (c.end = r), t || (t = l)
                    }
                }
                e.firstAnimation = t
            }, i.MorphAnimMesh.prototype.setAnimationLabel = function(e, t, n) {
                this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {
                    start: t,
                    end: n
                }
            }, i.MorphAnimMesh.prototype.playAnimation = function(e, t) {
                var n = this.geometry.animations[e];
                n ? (this.setFrameRange(n.start, n.end), this.duration = 1e3 * ((n.end - n.start) / t), this.time = 0) : i.warn("THREE.MorphAnimMesh: animation[" + e + "] undefined in .playAnimation()")
            }, i.MorphAnimMesh.prototype.updateAnimation = function(e) {
                var t = this.duration / this.length;
                this.time += this.direction * e, this.mirroredLoop ? (this.time > this.duration || this.time < 0) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), this.time < 0 && (this.time = 0, this.directionBackwards = !1)) : (this.time = this.time % this.duration, this.time < 0 && (this.time += this.duration));
                var n = this.startKeyframe + i.Math.clamp(Math.floor(this.time / t), 0, this.length - 1);
                n !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[n] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = n);
                var r = this.time % t / t;
                this.directionBackwards && (r = 1 - r), this.morphTargetInfluences[this.currentKeyframe] = r, this.morphTargetInfluences[this.lastKeyframe] = 1 - r
            }, i.MorphAnimMesh.prototype.interpolateTargets = function(e, t, n) {
                for (var i = this.morphTargetInfluences, r = 0, o = i.length; o > r; r++) i[r] = 0;
                e > -1 && (i[e] = 1 - n), t > -1 && (i[t] = n)
            }, i.MorphAnimMesh.prototype.clone = function(e) {
                return void 0 === e && (e = new i.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, i.Mesh.prototype.clone.call(this, e), e
            }, i.LOD = function() {
                i.Object3D.call(this), this.objects = []
            }, i.LOD.prototype = Object.create(i.Object3D.prototype), i.LOD.prototype.constructor = i.LOD, i.LOD.prototype.addLevel = function(e, t) {
                void 0 === t && (t = 0), t = Math.abs(t);
                for (var n = 0; n < this.objects.length && !(t < this.objects[n].distance); n++);
                this.objects.splice(n, 0, {
                    distance: t,
                    object: e
                }), this.add(e)
            }, i.LOD.prototype.getObjectForDistance = function(e) {
                for (var t = 1, n = this.objects.length; n > t && !(e < this.objects[t].distance); t++);
                return this.objects[t - 1].object
            }, i.LOD.prototype.raycast = function() {
                var e = new i.Vector3;
                return function(t, n) {
                    e.setFromMatrixPosition(this.matrixWorld);
                    var i = t.ray.origin.distanceTo(e);
                    this.getObjectForDistance(i).raycast(t, n)
                }
            }(), i.LOD.prototype.update = function() {
                var e = new i.Vector3,
                    t = new i.Vector3;
                return function(n) {
                    if (this.objects.length > 1) {
                        e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                        var i = e.distanceTo(t);
                        this.objects[0].object.visible = !0;
                        for (var r = 1, o = this.objects.length; o > r && i >= this.objects[r].distance; r++) this.objects[r - 1].object.visible = !1, this.objects[r].object.visible = !0;
                        for (; o > r; r++) this.objects[r].object.visible = !1
                    }
                }
            }(), i.LOD.prototype.clone = function(e) {
                void 0 === e && (e = new i.LOD), i.Object3D.prototype.clone.call(this, e);
                for (var t = 0, n = this.objects.length; n > t; t++) {
                    var r = this.objects[t].object.clone();
                    r.visible = 0 === t, e.addLevel(r, this.objects[t].distance)
                }
                return e
            }, i.Sprite = function() {
                var e = new Uint16Array([0, 1, 2, 0, 2, 3]),
                    t = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
                    n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                    r = new i.BufferGeometry;
                return r.addAttribute("index", new i.BufferAttribute(e, 1)), r.addAttribute("position", new i.BufferAttribute(t, 3)), r.addAttribute("uv", new i.BufferAttribute(n, 2)),
                    function(e) {
                        i.Object3D.call(this), this.type = "Sprite", this.geometry = r, this.material = void 0 !== e ? e : new i.SpriteMaterial
                    }
            }(), i.Sprite.prototype = Object.create(i.Object3D.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Sprite.prototype.raycast = function() {
                var e = new i.Vector3;
                return function(t, n) {
                    e.setFromMatrixPosition(this.matrixWorld);
                    var i = t.ray.distanceToPoint(e);
                    i > this.scale.x || n.push({
                        distance: i,
                        point: this.position,
                        face: null,
                        object: this
                    })
                }
            }(), i.Sprite.prototype.clone = function(e) {
                return void 0 === e && (e = new i.Sprite(this.material)), i.Object3D.prototype.clone.call(this, e), e
            }, i.Particle = i.Sprite, i.LensFlare = function(e, t, n, r, o) {
                i.Object3D.call(this), this.lensFlares = [], this.positionScreen = new i.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, r, o)
            }, i.LensFlare.prototype = Object.create(i.Object3D.prototype), i.LensFlare.prototype.constructor = i.LensFlare, i.LensFlare.prototype.add = function(e, t, n, r, o, a) {
                void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === a && (a = 1), void 0 === o && (o = new i.Color(16777215)), void 0 === r && (r = i.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
                    texture: e,
                    size: t,
                    distance: n,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 1,
                    opacity: a,
                    color: o,
                    blending: r
                })
            }, i.LensFlare.prototype.updateLensFlares = function() {
                var e, t, n = this.lensFlares.length,
                    i = 2 * -this.positionScreen.x,
                    r = 2 * -this.positionScreen.y;
                for (e = 0; n > e; e++) t = this.lensFlares[e], t.x = this.positionScreen.x + i * t.distance, t.y = this.positionScreen.y + r * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
            }, i.Scene = function() {
                i.Object3D.call(this), this.type = "Scene", this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }, i.Scene.prototype = Object.create(i.Object3D.prototype), i.Scene.prototype.constructor = i.Scene, i.Scene.prototype.clone = function(e) {
                return void 0 === e && (e = new i.Scene), i.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
            }, i.Fog = function(e, t, n) {
                this.name = "", this.color = new i.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }, i.Fog.prototype.clone = function() {
                return new i.Fog(this.color.getHex(), this.near, this.far)
            }, i.FogExp2 = function(e, t) {
                this.name = "", this.color = new i.Color(e), this.density = void 0 !== t ? t : 25e-5
            }, i.FogExp2.prototype.clone = function() {
                return new i.FogExp2(this.color.getHex(), this.density)
            }, i.ShaderChunk = {}, i.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n", i.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n", i.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n", i.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n", i.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", i.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", i.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", i.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", i.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", i.ShaderChunk.lights_phong_fragment = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n", i.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", i.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", i.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n", i.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", i.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n",
            i.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", i.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", i.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", i.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", i.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif", i.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", i.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n", i.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", i.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif", i.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", i.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n", i.ShaderChunk.linear_to_gamma_fragment = "\n	outgoingLight = linearToOutput( outgoingLight );\n", i.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", i.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", i.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", i.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n", i.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", i.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", i.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", i.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", i.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif", i.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n", i.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", i.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n", i.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", i.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", i.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif", i.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", i.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif", i.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", i.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n", i.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n", i.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n", i.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", i.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", i.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", i.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", i.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", i.UniformsUtils = {
                merge: function(e) {
                    for (var t = {}, n = 0; n < e.length; n++) {
                        var i = this.clone(e[n]);
                        for (var r in i) t[r] = i[r]
                    }
                    return t
                },
                clone: function(e) {
                    var t = {};
                    for (var n in e) {
                        t[n] = {};
                        for (var r in e[n]) {
                            var o = e[n][r];
                            o instanceof i.Color || o instanceof i.Vector2 || o instanceof i.Vector3 || o instanceof i.Vector4 || o instanceof i.Matrix4 || o instanceof i.Texture ? t[n][r] = o.clone() : o instanceof Array ? t[n][r] = o.slice() : t[n][r] = o
                        }
                    }
                    return t
                }
            }, i.UniformsLib = {
                common: {
                    diffuse: {
                        type: "c",
                        value: new i.Color(15658734)
                    },
                    opacity: {
                        type: "f",
                        value: 1
                    },
                    map: {
                        type: "t",
                        value: null
                    },
                    offsetRepeat: {
                        type: "v4",
                        value: new i.Vector4(0, 0, 1, 1)
                    },
                    lightMap: {
                        type: "t",
                        value: null
                    },
                    specularMap: {
                        type: "t",
                        value: null
                    },
                    alphaMap: {
                        type: "t",
                        value: null
                    },
                    envMap: {
                        type: "t",
                        value: null
                    },
                    flipEnvMap: {
                        type: "f",
                        value: -1
                    },
                    reflectivity: {
                        type: "f",
                        value: 1
                    },
                    refractionRatio: {
                        type: "f",
                        value: .98
                    },
                    morphTargetInfluences: {
                        type: "f",
                        value: 0
                    }
                },
                bump: {
                    bumpMap: {
                        type: "t",
                        value: null
                    },
                    bumpScale: {
                        type: "f",
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        type: "t",
                        value: null
                    },
                    normalScale: {
                        type: "v2",
                        value: new i.Vector2(1, 1)
                    }
                },
                fog: {
                    fogDensity: {
                        type: "f",
                        value: 25e-5
                    },
                    fogNear: {
                        type: "f",
                        value: 1
                    },
                    fogFar: {
                        type: "f",
                        value: 2e3
                    },
                    fogColor: {
                        type: "c",
                        value: new i.Color(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        type: "fv",
                        value: []
                    },
                    directionalLightDirection: {
                        type: "fv",
                        value: []
                    },
                    directionalLightColor: {
                        type: "fv",
                        value: []
                    },
                    hemisphereLightDirection: {
                        type: "fv",
                        value: []
                    },
                    hemisphereLightSkyColor: {
                        type: "fv",
                        value: []
                    },
                    hemisphereLightGroundColor: {
                        type: "fv",
                        value: []
                    },
                    pointLightColor: {
                        type: "fv",
                        value: []
                    },
                    pointLightPosition: {
                        type: "fv",
                        value: []
                    },
                    pointLightDistance: {
                        type: "fv1",
                        value: []
                    },
                    pointLightDecay: {
                        type: "fv1",
                        value: []
                    },
                    spotLightColor: {
                        type: "fv",
                        value: []
                    },
                    spotLightPosition: {
                        type: "fv",
                        value: []
                    },
                    spotLightDirection: {
                        type: "fv",
                        value: []
                    },
                    spotLightDistance: {
                        type: "fv1",
                        value: []
                    },
                    spotLightAngleCos: {
                        type: "fv1",
                        value: []
                    },
                    spotLightExponent: {
                        type: "fv1",
                        value: []
                    },
                    spotLightDecay: {
                        type: "fv1",
                        value: []
                    }
                },
                particle: {
                    psColor: {
                        type: "c",
                        value: new i.Color(15658734)
                    },
                    opacity: {
                        type: "f",
                        value: 1
                    },
                    size: {
                        type: "f",
                        value: 1
                    },
                    scale: {
                        type: "f",
                        value: 1
                    },
                    map: {
                        type: "t",
                        value: null
                    },
                    offsetRepeat: {
                        type: "v4",
                        value: new i.Vector4(0, 0, 1, 1)
                    },
                    fogDensity: {
                        type: "f",
                        value: 25e-5
                    },
                    fogNear: {
                        type: "f",
                        value: 1
                    },
                    fogFar: {
                        type: "f",
                        value: 2e3
                    },
                    fogColor: {
                        type: "c",
                        value: new i.Color(16777215)
                    }
                },
                shadowmap: {
                    shadowMap: {
                        type: "tv",
                        value: []
                    },
                    shadowMapSize: {
                        type: "v2v",
                        value: []
                    },
                    shadowBias: {
                        type: "fv1",
                        value: []
                    },
                    shadowDarkness: {
                        type: "fv1",
                        value: []
                    },
                    shadowMatrix: {
                        type: "m4v",
                        value: []
                    }
                }
            }, i.ShaderLib = {
                basic: {
                    uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.fog, i.UniformsLib.shadowmap]),
                    vertexShader: [i.ShaderChunk.common, i.ShaderChunk.map_pars_vertex, i.ShaderChunk.lightmap_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.map_vertex, i.ShaderChunk.lightmap_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, "	#endif", i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, "	outgoingLight = diffuseColor.rgb;", i.ShaderChunk.lightmap_fragment, i.ShaderChunk.envmap_fragment, i.ShaderChunk.shadowmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
                },
                lambert: {
                    uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.fog, i.UniformsLib.lights, i.UniformsLib.shadowmap, {
                        emissive: {
                            type: "c",
                            value: new i.Color(0)
                        },
                        wrapRGB: {
                            type: "v3",
                            value: new i.Vector3(1, 1, 1)
                        }
                    }]),
                    vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", i.ShaderChunk.common, i.ShaderChunk.map_pars_vertex, i.ShaderChunk.lightmap_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.lights_lambert_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.map_vertex, i.ShaderChunk.lightmap_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinbase_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.lights_lambert_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "	#endif", i.ShaderChunk.lightmap_fragment, i.ShaderChunk.envmap_fragment, i.ShaderChunk.shadowmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
                },
                phong: {
                    uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.bump, i.UniformsLib.normalmap, i.UniformsLib.fog, i.UniformsLib.lights, i.UniformsLib.shadowmap, {
                        emissive: {
                            type: "c",
                            value: new i.Color(0)
                        },
                        specular: {
                            type: "c",
                            value: new i.Color(1118481)
                        },
                        shininess: {
                            type: "f",
                            value: 30
                        },
                        wrapRGB: {
                            type: "v3",
                            value: new i.Vector3(1, 1, 1)
                        }
                    }]),
                    vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", i.ShaderChunk.common, i.ShaderChunk.map_pars_vertex, i.ShaderChunk.lightmap_pars_vertex, i.ShaderChunk.envmap_pars_vertex, i.ShaderChunk.lights_phong_pars_vertex, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.map_vertex, i.ShaderChunk.lightmap_vertex, i.ShaderChunk.color_vertex, i.ShaderChunk.morphnormal_vertex, i.ShaderChunk.skinbase_vertex, i.ShaderChunk.skinnormal_vertex, i.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", i.ShaderChunk.worldpos_vertex, i.ShaderChunk.envmap_vertex, i.ShaderChunk.lights_phong_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                    fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.map_pars_fragment, i.ShaderChunk.alphamap_pars_fragment, i.ShaderChunk.lightmap_pars_fragment, i.ShaderChunk.envmap_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.lights_phong_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.bumpmap_pars_fragment, i.ShaderChunk.normalmap_pars_fragment, i.ShaderChunk.specularmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphamap_fragment, i.ShaderChunk.alphatest_fragment, i.ShaderChunk.specularmap_fragment, i.ShaderChunk.lights_phong_fragment, i.ShaderChunk.lightmap_fragment, i.ShaderChunk.envmap_fragment, i.ShaderChunk.shadowmap_fragment, i.ShaderChunk.linear_to_gamma_fragment, i.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
                },
                particle_basic: {
                    uniforms: i.UniformsUtils.merge([i.UniformsLib.particle, i.UniformsLib.shadowmap]),
                    vertexShader: ["uniform float size;", "uniform float scale;", i.ShaderChunk.common, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.shadowmap_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", i.ShaderChunk.logdepthbuf_vertex, i.ShaderChunk.worldpos_vertex, i.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.map_particle_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.shadowmap_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.map_particle_fragment, i.ShaderChunk.color_fragment, i.ShaderChunk.alphatest_fragment, "	outgoingLight = diffuseColor.rgb;", i.ShaderChunk.shadowmap_fragment, i.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
                },
                dashed: {
                    uniforms: i.UniformsUtils.merge([i.UniformsLib.common, i.UniformsLib.fog, {
                        scale: {
                            type: "f",
                            value: 1
                        },
                        dashSize: {
                            type: "f",
                            value: 1
                        },
                        totalSize: {
                            type: "f",
                            value: 2
                        }
                    }]),
                    vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", i.ShaderChunk.common, i.ShaderChunk.color_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", i.ShaderChunk.common, i.ShaderChunk.color_pars_fragment, i.ShaderChunk.fog_pars_fragment, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", i.ShaderChunk.logdepthbuf_fragment, i.ShaderChunk.color_fragment, "	outgoingLight = diffuseColor.rgb;", i.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
                },
                depth: {
                    uniforms: {
                        mNear: {
                            type: "f",
                            value: 1
                        },
                        mFar: {
                            type: "f",
                            value: 2e3
                        },
                        opacity: {
                            type: "f",
                            value: 1
                        }
                    },
                    vertexShader: [i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", i.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
                },
                normal: {
                    uniforms: {
                        opacity: {
                            type: "f",
                            value: 1
                        }
                    },
                    vertexShader: ["varying vec3 vNormal;", i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vNormal = normalize( normalMatrix * normal );", i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
                },
                cube: {
                    uniforms: {
                        tCube: {
                            type: "t",
                            value: null
                        },
                        tFlip: {
                            type: "f",
                            value: -1
                        }
                    },
                    vertexShader: ["varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            type: "t",
                            value: null
                        },
                        tFlip: {
                            type: "f",
                            value: -1
                        }
                    },
                    vertexShader: ["varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", i.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
                },
                depthRGBA: {
                    uniforms: {},
                    vertexShader: [i.ShaderChunk.common, i.ShaderChunk.morphtarget_pars_vertex, i.ShaderChunk.skinning_pars_vertex, i.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", i.ShaderChunk.skinbase_vertex, i.ShaderChunk.morphtarget_vertex, i.ShaderChunk.skinning_vertex, i.ShaderChunk.default_vertex, i.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                    fragmentShader: [i.ShaderChunk.common, i.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", i.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
                }
            }, i.WebGLRenderer = function(e) {
                function t(e) {
                    e.__webglVertexBuffer = Le.createBuffer(), e.__webglColorBuffer = Le.createBuffer(), Re.info.memory.geometries++
                }

                function n(e) {
                    e.__webglVertexBuffer = Le.createBuffer(), e.__webglColorBuffer = Le.createBuffer(), e.__webglLineDistanceBuffer = Le.createBuffer(), Re.info.memory.geometries++
                }

                function r(e) {
                    e.__webglVertexBuffer = Le.createBuffer(), e.__webglNormalBuffer = Le.createBuffer(), e.__webglTangentBuffer = Le.createBuffer(), e.__webglColorBuffer = Le.createBuffer(), e.__webglUVBuffer = Le.createBuffer(), e.__webglUV2Buffer = Le.createBuffer(), e.__webglSkinIndicesBuffer = Le.createBuffer(), e.__webglSkinWeightsBuffer = Le.createBuffer(), e.__webglFaceBuffer = Le.createBuffer(), e.__webglLineBuffer = Le.createBuffer();
                    var t = e.numMorphTargets;
                    if (t) {
                        e.__webglMorphTargetsBuffers = [];
                        for (var n = 0, i = t; i > n; n++) e.__webglMorphTargetsBuffers.push(Le.createBuffer())
                    }
                    var r = e.numMorphNormals;
                    if (r) {
                        e.__webglMorphNormalsBuffers = [];
                        for (var n = 0, i = r; i > n; n++) e.__webglMorphNormalsBuffers.push(Le.createBuffer())
                    }
                    Re.info.memory.geometries++
                }

                function o(e) {
                    var t = e.geometry,
                        n = e.material,
                        i = t.vertices.length;
                    if (n.attributes) {
                        void 0 === t.__webglCustomAttributesList && (t.__webglCustomAttributesList = []);
                        for (var r in n.attributes) {
                            var o = n.attributes[r];
                            if (!o.__webglInitialized || o.createUniqueBuffers) {
                                o.__webglInitialized = !0;
                                var a = 1;
                                "v2" === o.type ? a = 2 : "v3" === o.type ? a = 3 : "v4" === o.type ? a = 4 : "c" === o.type && (a = 3), o.size = a, o.array = new Float32Array(i * a), o.buffer = Le.createBuffer(), o.buffer.belongsToAttribute = r, o.needsUpdate = !0
                            }
                            t.__webglCustomAttributesList.push(o)
                        }
                    }
                }

                function a(e, t) {
                    var n = e.vertices.length;
                    e.__vertexArray = new Float32Array(3 * n), e.__colorArray = new Float32Array(3 * n), e.__webglParticleCount = n, o(t)
                }

                function s(e, t) {
                    var n = e.vertices.length;
                    e.__vertexArray = new Float32Array(3 * n), e.__colorArray = new Float32Array(3 * n), e.__lineDistanceArray = new Float32Array(1 * n), e.__webglLineCount = n, o(t)
                }

                function l(e, t) {
                    var n = t.geometry,
                        i = e.faces3,
                        r = 3 * i.length,
                        o = 1 * i.length,
                        a = 3 * i.length,
                        s = c(t, e);
                    e.__vertexArray = new Float32Array(3 * r), e.__normalArray = new Float32Array(3 * r), e.__colorArray = new Float32Array(3 * r), e.__uvArray = new Float32Array(2 * r), n.faceVertexUvs.length > 1 && (e.__uv2Array = new Float32Array(2 * r)), n.hasTangents && (e.__tangentArray = new Float32Array(4 * r)), t.geometry.skinWeights.length && t.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * r), e.__skinWeightArray = new Float32Array(4 * r));
                    var l = null !== tt.get("OES_element_index_uint") && o > 21845 ? Uint32Array : Uint16Array;
                    e.__typeArray = l, e.__faceArray = new l(3 * o), e.__lineArray = new l(2 * a);
                    var h = e.numMorphTargets;
                    if (h) {
                        e.__morphTargetsArrays = [];
                        for (var u = 0, f = h; f > u; u++) e.__morphTargetsArrays.push(new Float32Array(3 * r))
                    }
                    var d = e.numMorphNormals;
                    if (d) {
                        e.__morphNormalsArrays = [];
                        for (var u = 0, f = d; f > u; u++) e.__morphNormalsArrays.push(new Float32Array(3 * r))
                    }
                    if (e.__webglFaceCount = 3 * o, e.__webglLineCount = 2 * a, s.attributes) {
                        void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
                        for (var p in s.attributes) {
                            var m = s.attributes[p],
                                v = {};
                            for (var g in m) v[g] = m[g];
                            if (!v.__webglInitialized || v.createUniqueBuffers) {
                                v.__webglInitialized = !0;
                                var y = 1;
                                "v2" === v.type ? y = 2 : "v3" === v.type ? y = 3 : "v4" === v.type ? y = 4 : "c" === v.type && (y = 3), v.size = y, v.array = new Float32Array(r * y), v.buffer = Le.createBuffer(), v.buffer.belongsToAttribute = p, m.needsUpdate = !0, v.__original = m
                            }
                            e.__webglCustomAttributesList.push(v)
                        }
                    }
                    e.__inittedArrays = !0
                }

                function c(e, t) {
                    return e.material instanceof i.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
                }

                function h(e) {
                    return e instanceof i.MeshPhongMaterial == !1 && e.shading === i.FlatShading
                }

                function u(e, t, n) {
                    var i, r, o, a, s, l, c, h, u, f, d, p = e.vertices,
                        m = p.length,
                        v = e.colors,
                        g = v.length,
                        y = e.__vertexArray,
                        x = e.__colorArray,
                        w = e.verticesNeedUpdate,
                        _ = e.colorsNeedUpdate,
                        b = e.__webglCustomAttributesList;
                    if (w) {
                        for (i = 0; m > i; i++) o = p[i], a = 3 * i, y[a] = o.x, y[a + 1] = o.y, y[a + 2] = o.z;
                        Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglVertexBuffer), Le.bufferData(Le.ARRAY_BUFFER, y, t)
                    }
                    if (_) {
                        for (r = 0; g > r; r++) s = v[r], a = 3 * r, x[a] = s.r, x[a + 1] = s.g, x[a + 2] = s.b;
                        Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglColorBuffer), Le.bufferData(Le.ARRAY_BUFFER, x, t)
                    }
                    if (b)
                        for (l = 0, c = b.length; c > l; l++) {
                            if (d = b[l], d.needsUpdate && (void 0 === d.boundTo || "vertices" === d.boundTo))
                                if (u = d.value.length, a = 0, 1 === d.size)
                                    for (h = 0; u > h; h++) d.array[h] = d.value[h];
                                else if (2 === d.size)
                                    for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, a += 2;
                                else if (3 === d.size)
                                    if ("c" === d.type)
                                        for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.r, d.array[a + 1] = f.g, d.array[a + 2] = f.b, a += 3;
                                    else
                                        for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, a += 3;
                                else if (4 === d.size)
                                    for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, d.array[a + 3] = f.w, a += 4;
                            Le.bindBuffer(Le.ARRAY_BUFFER, d.buffer), Le.bufferData(Le.ARRAY_BUFFER, d.array, t), d.needsUpdate = !1
                        }
                }

                function f(e, t) {
                    var n, i, r, o, a, s, l, c, h, u, f, d, p = e.vertices,
                        m = e.colors,
                        v = e.lineDistances,
                        g = p.length,
                        y = m.length,
                        x = v.length,
                        w = e.__vertexArray,
                        _ = e.__colorArray,
                        b = e.__lineDistanceArray,
                        E = e.verticesNeedUpdate,
                        M = e.colorsNeedUpdate,
                        S = e.lineDistancesNeedUpdate,
                        T = e.__webglCustomAttributesList;
                    if (E) {
                        for (n = 0; g > n; n++) o = p[n], a = 3 * n, w[a] = o.x, w[a + 1] = o.y, w[a + 2] = o.z;
                        Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglVertexBuffer), Le.bufferData(Le.ARRAY_BUFFER, w, t)
                    }
                    if (M) {
                        for (i = 0; y > i; i++) s = m[i], a = 3 * i, _[a] = s.r, _[a + 1] = s.g, _[a + 2] = s.b;
                        Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglColorBuffer), Le.bufferData(Le.ARRAY_BUFFER, _, t)
                    }
                    if (S) {
                        for (r = 0; x > r; r++) b[r] = v[r];
                        Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglLineDistanceBuffer), Le.bufferData(Le.ARRAY_BUFFER, b, t)
                    }
                    if (T)
                        for (l = 0, c = T.length; c > l; l++)
                            if (d = T[l], d.needsUpdate && (void 0 === d.boundTo || "vertices" === d.boundTo)) {
                                if (a = 0, u = d.value.length, 1 === d.size)
                                    for (h = 0; u > h; h++) d.array[h] = d.value[h];
                                else if (2 === d.size)
                                    for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, a += 2;
                                else if (3 === d.size)
                                    if ("c" === d.type)
                                        for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.r, d.array[a + 1] = f.g, d.array[a + 2] = f.b, a += 3;
                                    else
                                        for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, a += 3;
                                else if (4 === d.size)
                                    for (h = 0; u > h; h++) f = d.value[h], d.array[a] = f.x, d.array[a + 1] = f.y, d.array[a + 2] = f.z, d.array[a + 3] = f.w, a += 4;
                                Le.bindBuffer(Le.ARRAY_BUFFER, d.buffer), Le.bufferData(Le.ARRAY_BUFFER, d.array, t), d.needsUpdate = !1
                            }
                }

                function d(e, t, n, r, o) {
                    if (e.__inittedArrays) {
                        var a, s, l, c, u, f, d, p, m, v, g, y, x, w, _, b, E, M, S, T, C, A, P, D, L, R, O, N, U, F, k, H, I, V, z, B, j, G, W, X, q, K, Y = h(o),
                            $ = 0,
                            J = 0,
                            Z = 0,
                            Q = 0,
                            ee = 0,
                            te = 0,
                            ne = 0,
                            ie = 0,
                            re = 0,
                            oe = 0,
                            ae = 0,
                            se = 0,
                            le = e.__vertexArray,
                            ce = e.__uvArray,
                            he = e.__uv2Array,
                            ue = e.__normalArray,
                            fe = e.__tangentArray,
                            de = e.__colorArray,
                            pe = e.__skinIndexArray,
                            me = e.__skinWeightArray,
                            ve = e.__morphTargetsArrays,
                            ge = e.__morphNormalsArrays,
                            ye = e.__webglCustomAttributesList,
                            xe = e.__faceArray,
                            we = e.__lineArray,
                            _e = t.geometry,
                            be = _e.verticesNeedUpdate,
                            Ee = _e.elementsNeedUpdate,
                            Me = _e.uvsNeedUpdate,
                            Se = _e.normalsNeedUpdate,
                            Te = _e.tangentsNeedUpdate,
                            Ce = _e.colorsNeedUpdate,
                            Ae = _e.morphTargetsNeedUpdate,
                            Pe = _e.vertices,
                            De = e.faces3,
                            Re = _e.faces,
                            Oe = _e.faceVertexUvs[0],
                            Ne = _e.faceVertexUvs[1],
                            Ue = _e.skinIndices,
                            Fe = _e.skinWeights,
                            ke = _e.morphTargets,
                            He = _e.morphNormals;
                        if (be) {
                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], y = Pe[c.a], x = Pe[c.b], w = Pe[c.c], le[J] = y.x, le[J + 1] = y.y, le[J + 2] = y.z, le[J + 3] = x.x, le[J + 4] = x.y, le[J + 5] = x.z, le[J + 6] = w.x, le[J + 7] = w.y, le[J + 8] = w.z, J += 9;
                            Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglVertexBuffer), Le.bufferData(Le.ARRAY_BUFFER, le, n)
                        }
                        if (Ae)
                            for (z = 0, B = ke.length; B > z; z++) {
                                for (ae = 0, a = 0, s = De.length; s > a; a++) W = De[a], c = Re[W], y = ke[z].vertices[c.a], x = ke[z].vertices[c.b], w = ke[z].vertices[c.c], j = ve[z], j[ae] = y.x, j[ae + 1] = y.y, j[ae + 2] = y.z, j[ae + 3] = x.x, j[ae + 4] = x.y, j[ae + 5] = x.z, j[ae + 6] = w.x, j[ae + 7] = w.y, j[ae + 8] = w.z, o.morphNormals && (Y ? (M = He[z].faceNormals[W], S = M, T = M) : (X = He[z].vertexNormals[W], M = X.a, S = X.b, T = X.c), G = ge[z], G[ae] = M.x, G[ae + 1] = M.y, G[ae + 2] = M.z, G[ae + 3] = S.x, G[ae + 4] = S.y, G[ae + 5] = S.z, G[ae + 6] = T.x, G[ae + 7] = T.y, G[ae + 8] = T.z), ae += 9;
                                Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[z]), Le.bufferData(Le.ARRAY_BUFFER, ve[z], n), o.morphNormals && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[z]), Le.bufferData(Le.ARRAY_BUFFER, ge[z], n))
                            }
                        if (Fe.length) {
                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], D = Fe[c.a], L = Fe[c.b], R = Fe[c.c], me[oe] = D.x, me[oe + 1] = D.y, me[oe + 2] = D.z, me[oe + 3] = D.w, me[oe + 4] = L.x, me[oe + 5] = L.y, me[oe + 6] = L.z, me[oe + 7] = L.w, me[oe + 8] = R.x, me[oe + 9] = R.y, me[oe + 10] = R.z, me[oe + 11] = R.w, O = Ue[c.a], N = Ue[c.b], U = Ue[c.c], pe[oe] = O.x, pe[oe + 1] = O.y, pe[oe + 2] = O.z, pe[oe + 3] = O.w, pe[oe + 4] = N.x, pe[oe + 5] = N.y, pe[oe + 6] = N.z, pe[oe + 7] = N.w, pe[oe + 8] = U.x, pe[oe + 9] = U.y, pe[oe + 10] = U.z, pe[oe + 11] = U.w, oe += 12;
                            oe > 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), Le.bufferData(Le.ARRAY_BUFFER, pe, n), Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), Le.bufferData(Le.ARRAY_BUFFER, me, n))
                        }
                        if (Ce) {
                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], d = c.vertexColors, p = c.color, 3 === d.length && o.vertexColors === i.VertexColors ? (C = d[0], A = d[1], P = d[2]) : (C = p, A = p, P = p), de[re] = C.r, de[re + 1] = C.g, de[re + 2] = C.b, de[re + 3] = A.r, de[re + 4] = A.g, de[re + 5] = A.b, de[re + 6] = P.r, de[re + 7] = P.g, de[re + 8] = P.b, re += 9;
                            re > 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglColorBuffer), Le.bufferData(Le.ARRAY_BUFFER, de, n))
                        }
                        if (Te && _e.hasTangents) {
                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], m = c.vertexTangents, _ = m[0], b = m[1], E = m[2], fe[ne] = _.x, fe[ne + 1] = _.y, fe[ne + 2] = _.z, fe[ne + 3] = _.w, fe[ne + 4] = b.x, fe[ne + 5] = b.y, fe[ne + 6] = b.z, fe[ne + 7] = b.w, fe[ne + 8] = E.x, fe[ne + 9] = E.y, fe[ne + 10] = E.z, fe[ne + 11] = E.w, ne += 12;
                            Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglTangentBuffer), Le.bufferData(Le.ARRAY_BUFFER, fe, n)
                        }
                        if (Se) {
                            for (a = 0, s = De.length; s > a; a++)
                                if (c = Re[De[a]], u = c.vertexNormals, f = c.normal, 3 === u.length && Y === !1)
                                    for (F = 0; 3 > F; F++) H = u[F], ue[te] = H.x, ue[te + 1] = H.y, ue[te + 2] = H.z, te += 3;
                                else
                                    for (F = 0; 3 > F; F++) ue[te] = f.x, ue[te + 1] = f.y, ue[te + 2] = f.z, te += 3;
                            Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglNormalBuffer), Le.bufferData(Le.ARRAY_BUFFER, ue, n)
                        }
                        if (Me && Oe) {
                            for (a = 0, s = De.length; s > a; a++)
                                if (l = De[a], v = Oe[l], void 0 !== v)
                                    for (F = 0; 3 > F; F++) I = v[F], ce[Z] = I.x, ce[Z + 1] = I.y, Z += 2;
                            Z > 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglUVBuffer), Le.bufferData(Le.ARRAY_BUFFER, ce, n))
                        }
                        if (Me && Ne) {
                            for (a = 0, s = De.length; s > a; a++)
                                if (l = De[a], g = Ne[l], void 0 !== g)
                                    for (F = 0; 3 > F; F++) V = g[F], he[Q] = V.x, he[Q + 1] = V.y, Q += 2;
                            Q > 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglUV2Buffer), Le.bufferData(Le.ARRAY_BUFFER, he, n))
                        }
                        if (Ee) {
                            for (a = 0, s = De.length; s > a; a++) xe[ee] = $, xe[ee + 1] = $ + 1, xe[ee + 2] = $ + 2, ee += 3, we[ie] = $, we[ie + 1] = $ + 1, we[ie + 2] = $, we[ie + 3] = $ + 2, we[ie + 4] = $ + 1, we[ie + 5] = $ + 2, ie += 6, $ += 3;
                            Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), Le.bufferData(Le.ELEMENT_ARRAY_BUFFER, xe, n), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), Le.bufferData(Le.ELEMENT_ARRAY_BUFFER, we, n)
                        }
                        if (ye)
                            for (F = 0, k = ye.length; k > F; F++)
                                if (K = ye[F], K.__original.needsUpdate) {
                                    if (se = 0, 1 === K.size) {
                                        if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], K.array[se] = K.value[c.a], K.array[se + 1] = K.value[c.b], K.array[se + 2] = K.value[c.c], se += 3;
                                        else if ("faces" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], K.array[se] = q, K.array[se + 1] = q, K.array[se + 2] = q, se += 3
                                    } else if (2 === K.size) {
                                        if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], y = K.value[c.a], x = K.value[c.b], w = K.value[c.c], K.array[se] = y.x, K.array[se + 1] = y.y, K.array[se + 2] = x.x, K.array[se + 3] = x.y, K.array[se + 4] = w.x, K.array[se + 5] = w.y, se += 6;
                                        else if ("faces" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], y = q, x = q, w = q, K.array[se] = y.x, K.array[se + 1] = y.y, K.array[se + 2] = x.x, K.array[se + 3] = x.y, K.array[se + 4] = w.x, K.array[se + 5] = w.y, se += 6
                                    } else if (3 === K.size) {
                                        var Ie;
                                        if (Ie = "c" === K.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === K.boundTo || "vertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], y = K.value[c.a], x = K.value[c.b], w = K.value[c.c], K.array[se] = y[Ie[0]], K.array[se + 1] = y[Ie[1]], K.array[se + 2] = y[Ie[2]], K.array[se + 3] = x[Ie[0]], K.array[se + 4] = x[Ie[1]], K.array[se + 5] = x[Ie[2]], K.array[se + 6] = w[Ie[0]], K.array[se + 7] = w[Ie[1]], K.array[se + 8] = w[Ie[2]], se += 9;
                                        else if ("faces" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], y = q, x = q, w = q, K.array[se] = y[Ie[0]], K.array[se + 1] = y[Ie[1]], K.array[se + 2] = y[Ie[2]], K.array[se + 3] = x[Ie[0]], K.array[se + 4] = x[Ie[1]], K.array[se + 5] = x[Ie[2]], K.array[se + 6] = w[Ie[0]], K.array[se + 7] = w[Ie[1]], K.array[se + 8] = w[Ie[2]], se += 9;
                                        else if ("faceVertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], y = q[0], x = q[1], w = q[2], K.array[se] = y[Ie[0]], K.array[se + 1] = y[Ie[1]], K.array[se + 2] = y[Ie[2]], K.array[se + 3] = x[Ie[0]], K.array[se + 4] = x[Ie[1]], K.array[se + 5] = x[Ie[2]], K.array[se + 6] = w[Ie[0]], K.array[se + 7] = w[Ie[1]], K.array[se + 8] = w[Ie[2]], se += 9
                                    } else if (4 === K.size)
                                        if (void 0 === K.boundTo || "vertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) c = Re[De[a]], y = K.value[c.a], x = K.value[c.b], w = K.value[c.c], K.array[se] = y.x, K.array[se + 1] = y.y, K.array[se + 2] = y.z, K.array[se + 3] = y.w, K.array[se + 4] = x.x, K.array[se + 5] = x.y, K.array[se + 6] = x.z, K.array[se + 7] = x.w, K.array[se + 8] = w.x, K.array[se + 9] = w.y, K.array[se + 10] = w.z, K.array[se + 11] = w.w, se += 12;
                                        else if ("faces" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], y = q, x = q, w = q, K.array[se] = y.x, K.array[se + 1] = y.y, K.array[se + 2] = y.z, K.array[se + 3] = y.w, K.array[se + 4] = x.x, K.array[se + 5] = x.y, K.array[se + 6] = x.z, K.array[se + 7] = x.w, K.array[se + 8] = w.x, K.array[se + 9] = w.y, K.array[se + 10] = w.z, K.array[se + 11] = w.w, se += 12;
                                        else if ("faceVertices" === K.boundTo)
                                            for (a = 0, s = De.length; s > a; a++) q = K.value[De[a]], y = q[0], x = q[1], w = q[2], K.array[se] = y.x, K.array[se + 1] = y.y, K.array[se + 2] = y.z, K.array[se + 3] = y.w, K.array[se + 4] = x.x, K.array[se + 5] = x.y, K.array[se + 6] = x.z, K.array[se + 7] = x.w, K.array[se + 8] = w.x, K.array[se + 9] = w.y, K.array[se + 10] = w.z, K.array[se + 11] = w.w, se += 12;
                                    Le.bindBuffer(Le.ARRAY_BUFFER, K.buffer), Le.bufferData(Le.ARRAY_BUFFER, K.array, n)
                                }
                        r && (delete e.__inittedArrays, delete e.__colorArray, delete e.__normalArray, delete e.__tangentArray, delete e.__uvArray, delete e.__uv2Array, delete e.__faceArray, delete e.__vertexArray, delete e.__lineArray, delete e.__skinIndexArray, delete e.__skinWeightArray)
                    }
                }

                function p(e, t, n, i) {
                    for (var r = n.attributes, o = t.attributes, a = t.attributesKeys, s = 0, l = a.length; l > s; s++) {
                        var c = a[s],
                            h = o[c];
                        if (h >= 0) {
                            var u = r[c];
                            if (void 0 !== u) {
                                var f = u.itemSize;
                                Le.bindBuffer(Le.ARRAY_BUFFER, u.buffer), et.enableAttribute(h), Le.vertexAttribPointer(h, f, Le.FLOAT, !1, 0, i * f * 4)
                            } else void 0 !== e.defaultAttributeValues && (2 === e.defaultAttributeValues[c].length ? Le.vertexAttrib2fv(h, e.defaultAttributeValues[c]) : 3 === e.defaultAttributeValues[c].length && Le.vertexAttrib3fv(h, e.defaultAttributeValues[c]))
                        }
                    }
                    et.disableUnusedAttributes()
                }

                function m(e, t, n) {
                    var i = e.program.attributes;
                    if (-1 !== n.morphTargetBase && i.position >= 0 ? (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[n.morphTargetBase]), et.enableAttribute(i.position), Le.vertexAttribPointer(i.position, 3, Le.FLOAT, !1, 0, 0)) : i.position >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglVertexBuffer), et.enableAttribute(i.position), Le.vertexAttribPointer(i.position, 3, Le.FLOAT, !1, 0, 0)), n.morphTargetForcedOrder.length)
                        for (var r, o = 0, a = n.morphTargetForcedOrder, s = n.morphTargetInfluences; o < e.numSupportedMorphTargets && o < a.length;) r = i["morphTarget" + o], r >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[a[o]]), et.enableAttribute(r), Le.vertexAttribPointer(r, 3, Le.FLOAT, !1, 0, 0)), r = i["morphNormal" + o], r >= 0 && e.morphNormals && (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[a[o]]), et.enableAttribute(r), Le.vertexAttribPointer(r, 3, Le.FLOAT, !1, 0, 0)), n.__webglMorphTargetInfluences[o] = s[a[o]], o++;
                    else {
                        var l = [],
                            s = n.morphTargetInfluences,
                            c = n.geometry.morphTargets;
                        s.length > c.length && (console.warn("THREE.WebGLRenderer: Influences array is bigger than morphTargets array."), s.length = c.length);
                        for (var h = 0, u = s.length; u > h; h++) {
                            var f = s[h];
                            l.push([f, h])
                        }
                        l.length > e.numSupportedMorphTargets ? (l.sort(y), l.length = e.numSupportedMorphTargets) : l.length > e.numSupportedMorphNormals ? l.sort(y) : 0 === l.length && l.push([0, 0]);
                        for (var r, o = 0, d = e.numSupportedMorphTargets; d > o; o++)
                            if (l[o]) {
                                var p = l[o][1];
                                r = i["morphTarget" + o], r >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[p]), et.enableAttribute(r), Le.vertexAttribPointer(r, 3, Le.FLOAT, !1, 0, 0)), r = i["morphNormal" + o], r >= 0 && e.morphNormals && (Le.bindBuffer(Le.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[p]), et.enableAttribute(r), Le.vertexAttribPointer(r, 3, Le.FLOAT, !1, 0, 0)), n.__webglMorphTargetInfluences[o] = s[p]
                            } else n.__webglMorphTargetInfluences[o] = 0
                    }
                    null !== e.program.uniforms.morphTargetInfluences && Le.uniform1fv(e.program.uniforms.morphTargetInfluences, n.__webglMorphTargetInfluences)
                }

                function v(e, t) {
                    return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }

                function g(e, t) {
                    return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }

                function y(e, t) {
                    return t[0] - e[0]
                }

                function x(e) {
                    if (e.visible !== !1) {
                        if (e instanceof i.Scene || e instanceof i.Group);
                        else if (M(e), e instanceof i.Light) Me.push(e);
                        else if (e instanceof i.Sprite) Pe.push(e);
                        else if (e instanceof i.LensFlare) De.push(e);
                        else {
                            var t = Se[e.id];
                            if (t && (e.frustumCulled === !1 || Xe.intersectsObject(e) === !0))
                                for (var n = 0, r = t.length; r > n; n++) {
                                    var o = t[n];
                                    E(o), o.render = !0, Re.sortObjects === !0 && (Ke.setFromMatrixPosition(e.matrixWorld), Ke.applyProjection(qe), o.z = Ke.z)
                                }
                        }
                        for (var n = 0, r = e.children.length; r > n; n++) x(e.children[n])
                    }
                }

                function w(e, t, n, r, o) {
                    for (var a, s = 0, l = e.length; l > s; s++) {
                        var c = e[s],
                            h = c.object,
                            u = c.buffer;
                        if ($(h, t), o) a = o;
                        else {
                            if (a = c.material, !a) continue;
                            U(a)
                        }
                        Re.setMaterialFaces(a), u instanceof i.BufferGeometry ? Re.renderBufferDirect(t, n, r, a, u, h) : Re.renderBuffer(t, n, r, a, u, h)
                    }
                }

                function _(e, t, n, i, r, o) {
                    for (var a, s = 0, l = e.length; l > s; s++) {
                        var c = e[s],
                            h = c.object;
                        if (h.visible) {
                            if (o) a = o;
                            else {
                                if (a = c[t], !a) continue;
                                U(a)
                            }
                            Re.renderImmediateObject(n, i, r, a, h)
                        }
                    }
                }

                function b(e) {
                    var t = e.object,
                        n = t.material;
                    n.transparent ? (e.transparent = n, e.opaque = null) : (e.opaque = n, e.transparent = null)
                }

                function E(e) {
                    var t = e.object,
                        n = e.buffer,
                        r = t.geometry,
                        o = t.material;
                    if (o instanceof i.MeshFaceMaterial) {
                        var a = r instanceof i.BufferGeometry ? 0 : n.materialIndex;
                        o = o.materials[a], e.material = o, o.transparent ? Ae.push(e) : Ce.push(e)
                    } else o && (e.material = o, o.transparent ? Ae.push(e) : Ce.push(e))
                }

                function M(e) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, e._modelViewMatrix = new i.Matrix4, e._normalMatrix = new i.Matrix3, e.addEventListener("removed", _t));
                    var r = e.geometry;
                    if (void 0 === r || void 0 === r.__webglInit && (r.__webglInit = !0, r.addEventListener("dispose", bt), r instanceof i.BufferGeometry ? Re.info.memory.geometries++ : e instanceof i.Mesh ? T(e, r) : e instanceof i.Line ? void 0 === r.__webglVertexBuffer && (n(r), s(r, e), r.verticesNeedUpdate = !0, r.colorsNeedUpdate = !0, r.lineDistancesNeedUpdate = !0) : e instanceof i.PointCloud && void 0 === r.__webglVertexBuffer && (t(r), a(r, e), r.verticesNeedUpdate = !0, r.colorsNeedUpdate = !0)), void 0 === e.__webglActive)
                        if (e.__webglActive = !0, e instanceof i.Mesh) {
                            if (r instanceof i.BufferGeometry) C(Se, r, e);
                            else if (r instanceof i.Geometry)
                                for (var o = Lt[r.id], l = 0, c = o.length; c > l; l++) C(Se, o[l], e)
                        } else e instanceof i.Line || e instanceof i.PointCloud ? C(Se, r, e) : (e instanceof i.ImmediateRenderObject || e.immediateRenderCallback) && A(Te, e)
                }

                function S(e, t) {
                    for (var n, i, r = tt.get("OES_element_index_uint") ? 4294967296 : 65535, o = {}, a = e.morphTargets.length, s = e.morphNormals.length, l = {}, c = [], h = 0, u = e.faces.length; u > h; h++) {
                        var f = e.faces[h],
                            d = t ? f.materialIndex : 0;
                        d in o || (o[d] = {
                            hash: d,
                            counter: 0
                        }), n = o[d].hash + "_" + o[d].counter, n in l || (i = {
                            id: Rt++,
                            faces3: [],
                            materialIndex: d,
                            vertices: 0,
                            numMorphTargets: a,
                            numMorphNormals: s
                        }, l[n] = i, c.push(i)), l[n].vertices + 3 > r && (o[d].counter += 1, n = o[d].hash + "_" + o[d].counter, n in l || (i = {
                            id: Rt++,
                            faces3: [],
                            materialIndex: d,
                            vertices: 0,
                            numMorphTargets: a,
                            numMorphNormals: s
                        }, l[n] = i, c.push(i))), l[n].faces3.push(h), l[n].vertices += 3
                    }
                    return c
                }

                function T(e, t) {
                    var n = e.material,
                        o = !1;
                    void 0 !== Lt[t.id] && t.groupsNeedUpdate !== !0 || (delete Se[e.id], Lt[t.id] = S(t, n instanceof i.MeshFaceMaterial), t.groupsNeedUpdate = !1);
                    for (var a = Lt[t.id], s = 0, c = a.length; c > s; s++) {
                        var h = a[s];
                        void 0 === h.__webglVertexBuffer ? (r(h), l(h, e), t.verticesNeedUpdate = !0, t.morphTargetsNeedUpdate = !0, t.elementsNeedUpdate = !0, t.uvsNeedUpdate = !0, t.normalsNeedUpdate = !0, t.tangentsNeedUpdate = !0, t.colorsNeedUpdate = !0, o = !0) : o = !1, (o || void 0 === e.__webglActive) && C(Se, h, e)
                    }
                    e.__webglActive = !0
                }

                function C(e, t, n) {
                    var i = n.id;
                    e[i] = e[i] || [], e[i].push({
                        id: i,
                        buffer: t,
                        object: n,
                        material: null,
                        z: 0
                    })
                }

                function A(e, t) {
                    e.push({
                        id: null,
                        object: t,
                        opaque: null,
                        transparent: null,
                        z: 0
                    })
                }

                function P(e) {
                    var t = e.geometry;
                    if (t instanceof i.BufferGeometry)
                        for (var n = t.attributes, r = t.attributesKeys, o = 0, a = r.length; a > o; o++) {
                            var s = r[o],
                                l = n[s],
                                h = "index" === s ? Le.ELEMENT_ARRAY_BUFFER : Le.ARRAY_BUFFER;
                            void 0 === l.buffer ? (l.buffer = Le.createBuffer(), Le.bindBuffer(h, l.buffer), Le.bufferData(h, l.array, l instanceof i.DynamicBufferAttribute ? Le.DYNAMIC_DRAW : Le.STATIC_DRAW), l.needsUpdate = !1) : l.needsUpdate === !0 && (Le.bindBuffer(h, l.buffer), void 0 === l.updateRange || -1 === l.updateRange.count ? Le.bufferSubData(h, 0, l.array) : 0 === l.updateRange.count ? console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.") : (Le.bufferSubData(h, l.updateRange.offset * l.array.BYTES_PER_ELEMENT, l.array.subarray(l.updateRange.offset, l.updateRange.offset + l.updateRange.count)), l.updateRange.count = 0), l.needsUpdate = !1)
                        } else if (e instanceof i.Mesh) {
                        t.groupsNeedUpdate === !0 && T(e, t);
                        for (var p = Lt[t.id], o = 0, m = p.length; m > o; o++) {
                            var v = p[o],
                                g = c(e, v),
                                y = g.attributes && D(g);
                            (t.verticesNeedUpdate || t.morphTargetsNeedUpdate || t.elementsNeedUpdate || t.uvsNeedUpdate || t.normalsNeedUpdate || t.colorsNeedUpdate || t.tangentsNeedUpdate || y) && d(v, e, Le.DYNAMIC_DRAW, !t.dynamic, g)
                        }
                        t.verticesNeedUpdate = !1, t.morphTargetsNeedUpdate = !1, t.elementsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.tangentsNeedUpdate = !1, g.attributes && L(g)
                    } else if (e instanceof i.Line) {
                        var g = c(e, t),
                            y = g.attributes && D(g);
                        (t.verticesNeedUpdate || t.colorsNeedUpdate || t.lineDistancesNeedUpdate || y) && f(t, Le.DYNAMIC_DRAW), t.verticesNeedUpdate = !1, t.colorsNeedUpdate = !1, t.lineDistancesNeedUpdate = !1, g.attributes && L(g)
                    } else if (e instanceof i.PointCloud) {
                        var g = c(e, t),
                            y = g.attributes && D(g);
                        (t.verticesNeedUpdate || t.colorsNeedUpdate || y) && u(t, Le.DYNAMIC_DRAW, e), t.verticesNeedUpdate = !1, t.colorsNeedUpdate = !1, g.attributes && L(g)
                    }
                }

                function D(e) {
                    for (var t in e.attributes)
                        if (e.attributes[t].needsUpdate) return !0;
                    return !1
                }

                function L(e) {
                    for (var t in e.attributes) e.attributes[t].needsUpdate = !1
                }

                function R(e) {
                    e instanceof i.Mesh || e instanceof i.PointCloud || e instanceof i.Line ? delete Se[e.id] : (e instanceof i.ImmediateRenderObject || e.immediateRenderCallback) && O(Te, e), delete e.__webglInit, delete e._modelViewMatrix, delete e._normalMatrix, delete e.__webglActive
                }

                function O(e, t) {
                    for (var n = e.length - 1; n >= 0; n--) e[n].object === t && e.splice(n, 1)
                }

                function N(e, t, n, r) {
                    e.addEventListener("dispose", St);
                    var o = Ot[e.type];
                    if (o) {
                        var a = i.ShaderLib[o];
                        e.__webglShader = {
                            uniforms: i.UniformsUtils.clone(a.uniforms),
                            vertexShader: a.vertexShader,
                            fragmentShader: a.fragmentShader
                        }
                    } else e.__webglShader = {
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                    var s = ce(t),
                        l = he(t),
                        c = le(r),
                        h = {
                            precision: pe,
                            supportsVertexTextures: ct,
                            map: !!e.map,
                            envMap: !!e.envMap,
                            envMapMode: e.envMap && e.envMap.mapping,
                            lightMap: !!e.lightMap,
                            bumpMap: !!e.bumpMap,
                            normalMap: !!e.normalMap,
                            specularMap: !!e.specularMap,
                            alphaMap: !!e.alphaMap,
                            combine: e.combine,
                            vertexColors: e.vertexColors,
                            fog: n,
                            useFog: e.fog,
                            fogExp: n instanceof i.FogExp2,
                            flatShading: e.shading === i.FlatShading,
                            sizeAttenuation: e.sizeAttenuation,
                            logarithmicDepthBuffer: _e,
                            skinning: e.skinning,
                            maxBones: c,
                            useVertexTexture: ht && r && r.skeleton && r.skeleton.useVertexTexture,
                            morphTargets: e.morphTargets,
                            morphNormals: e.morphNormals,
                            maxMorphTargets: Re.maxMorphTargets,
                            maxMorphNormals: Re.maxMorphNormals,
                            maxDirLights: s.directional,
                            maxPointLights: s.point,
                            maxSpotLights: s.spot,
                            maxHemiLights: s.hemi,
                            maxShadows: l,
                            shadowMapEnabled: Re.shadowMapEnabled && r.receiveShadow && l > 0,
                            shadowMapType: Re.shadowMapType,
                            shadowMapDebug: Re.shadowMapDebug,
                            shadowMapCascade: Re.shadowMapCascade,
                            alphaTest: e.alphaTest,
                            metal: e.metal,
                            wrapAround: e.wrapAround,
                            doubleSided: e.side === i.DoubleSide,
                            flipSided: e.side === i.BackSide
                        },
                        u = [];
                    if (o ? u.push(o) : (u.push(e.fragmentShader), u.push(e.vertexShader)), void 0 !== e.defines)
                        for (var f in e.defines) u.push(f), u.push(e.defines[f]);
                    for (var f in h) u.push(f), u.push(h[f]);
                    for (var d, p = u.join(), m = 0, v = Oe.length; v > m; m++) {
                        var g = Oe[m];
                        if (g.code === p) {
                            d = g, d.usedTimes++;
                            break
                        }
                    }
                    void 0 === d && (d = new i.WebGLProgram(Re, p, e, h), Oe.push(d), Re.info.memory.programs = Oe.length), e.program = d;
                    var y = d.attributes;
                    if (e.morphTargets) {
                        e.numSupportedMorphTargets = 0;
                        for (var x, w = "morphTarget", _ = 0; _ < Re.maxMorphTargets; _++) x = w + _, y[x] >= 0 && e.numSupportedMorphTargets++
                    }
                    if (e.morphNormals) {
                        e.numSupportedMorphNormals = 0;
                        var x, w = "morphNormal";
                        for (_ = 0; _ < Re.maxMorphNormals; _++) x = w + _, y[x] >= 0 && e.numSupportedMorphNormals++
                    }
                    e.uniformsList = [];
                    for (var b in e.__webglShader.uniforms) {
                        var E = e.program.uniforms[b];
                        E && e.uniformsList.push([e.__webglShader.uniforms[b], E])
                    }
                }

                function U(e) {
                    e.transparent === !0 ? et.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha) : et.setBlending(i.NoBlending), et.setDepthTest(e.depthTest), et.setDepthWrite(e.depthWrite), et.setColorWrite(e.colorWrite), et.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                }

                function F(e, t, n, r, o) {
                    Ie = 0, r.needsUpdate && (r.program && Dt(r), N(r, t, n, o), r.needsUpdate = !1), r.morphTargets && (o.__webglMorphTargetInfluences || (o.__webglMorphTargetInfluences = new Float32Array(Re.maxMorphTargets)));
                    var a = !1,
                        s = !1,
                        l = !1,
                        c = r.program,
                        h = c.uniforms,
                        u = r.__webglShader.uniforms;
                    if (c.id !== Ne && (Le.useProgram(c.program), Ne = c.id, a = !0, s = !0, l = !0), r.id !== Fe && (-1 === Fe && (l = !0), Fe = r.id, s = !0), (a || e !== He) && (Le.uniformMatrix4fv(h.projectionMatrix, !1, e.projectionMatrix.elements), _e && Le.uniform1f(h.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)), e !== He && (He = e), (r instanceof i.ShaderMaterial || r instanceof i.MeshPhongMaterial || r.envMap) && null !== h.cameraPosition && (Ke.setFromMatrixPosition(e.matrixWorld), Le.uniform3f(h.cameraPosition, Ke.x, Ke.y, Ke.z)), (r instanceof i.MeshPhongMaterial || r instanceof i.MeshLambertMaterial || r instanceof i.MeshBasicMaterial || r instanceof i.ShaderMaterial || r.skinning) && null !== h.viewMatrix && Le.uniformMatrix4fv(h.viewMatrix, !1, e.matrixWorldInverse.elements)), r.skinning)
                        if (o.bindMatrix && null !== h.bindMatrix && Le.uniformMatrix4fv(h.bindMatrix, !1, o.bindMatrix.elements), o.bindMatrixInverse && null !== h.bindMatrixInverse && Le.uniformMatrix4fv(h.bindMatrixInverse, !1, o.bindMatrixInverse.elements), ht && o.skeleton && o.skeleton.useVertexTexture) {
                            if (null !== h.boneTexture) {
                                var f = K();
                                Le.uniform1i(h.boneTexture, f), Re.setTexture(o.skeleton.boneTexture, f)
                            }
                            null !== h.boneTextureWidth && Le.uniform1i(h.boneTextureWidth, o.skeleton.boneTextureWidth), null !== h.boneTextureHeight && Le.uniform1i(h.boneTextureHeight, o.skeleton.boneTextureHeight)
                        } else o.skeleton && o.skeleton.boneMatrices && null !== h.boneGlobalMatrices && Le.uniformMatrix4fv(h.boneGlobalMatrices, !1, o.skeleton.boneMatrices);
                    return s && (n && r.fog && z(u, n), (r instanceof i.MeshPhongMaterial || r instanceof i.MeshLambertMaterial || r.lights) && ($e && (l = !0,
                        Z(t), $e = !1), l ? (G(u, Je), W(u, !0)) : W(u, !1)), (r instanceof i.MeshBasicMaterial || r instanceof i.MeshLambertMaterial || r instanceof i.MeshPhongMaterial) && k(u, r), r instanceof i.LineBasicMaterial ? H(u, r) : r instanceof i.LineDashedMaterial ? (H(u, r), I(u, r)) : r instanceof i.PointCloudMaterial ? V(u, r) : r instanceof i.MeshPhongMaterial ? B(u, r) : r instanceof i.MeshLambertMaterial ? j(u, r) : r instanceof i.MeshDepthMaterial ? (u.mNear.value = e.near, u.mFar.value = e.far, u.opacity.value = r.opacity) : r instanceof i.MeshNormalMaterial && (u.opacity.value = r.opacity), o.receiveShadow && !r._shadowPass && X(u, t), Y(r.uniformsList)), q(h, o), null !== h.modelMatrix && Le.uniformMatrix4fv(h.modelMatrix, !1, o.matrixWorld.elements), c
                }

                function k(e, t) {
                    e.opacity.value = t.opacity, e.diffuse.value = t.color, e.map.value = t.map, e.lightMap.value = t.lightMap, e.specularMap.value = t.specularMap, e.alphaMap.value = t.alphaMap, t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale));
                    var n;
                    if (t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.alphaMap && (n = t.alphaMap), void 0 !== n) {
                        var r = n.offset,
                            o = n.repeat;
                        e.offsetRepeat.value.set(r.x, r.y, o.x, o.y)
                    }
                    e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap instanceof i.WebGLRenderTargetCube ? 1 : -1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio
                }

                function H(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity
                }

                function I(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }

                function V(e, t) {
                    if (e.psColor.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size, e.scale.value = ue.height / 2, e.map.value = t.map, null !== t.map) {
                        var n = t.map.offset,
                            i = t.map.repeat;
                        e.offsetRepeat.value.set(n.x, n.y, i.x, i.y)
                    }
                }

                function z(e, t) {
                    e.fogColor.value = t.color, t instanceof i.Fog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t instanceof i.FogExp2 && (e.fogDensity.value = t.density)
                }

                function B(e, t) {
                    e.shininess.value = t.shininess, e.emissive.value = t.emissive, e.specular.value = t.specular, t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB)
                }

                function j(e, t) {
                    e.emissive.value = t.emissive, t.wrapAround && e.wrapRGB.value.copy(t.wrapRGB)
                }

                function G(e, t) {
                    e.ambientLightColor.value = t.ambient, e.directionalLightColor.value = t.directional.colors, e.directionalLightDirection.value = t.directional.positions, e.pointLightColor.value = t.point.colors, e.pointLightPosition.value = t.point.positions, e.pointLightDistance.value = t.point.distances, e.pointLightDecay.value = t.point.decays, e.spotLightColor.value = t.spot.colors, e.spotLightPosition.value = t.spot.positions, e.spotLightDistance.value = t.spot.distances, e.spotLightDirection.value = t.spot.directions, e.spotLightAngleCos.value = t.spot.anglesCos, e.spotLightExponent.value = t.spot.exponents, e.spotLightDecay.value = t.spot.decays, e.hemisphereLightSkyColor.value = t.hemi.skyColors, e.hemisphereLightGroundColor.value = t.hemi.groundColors, e.hemisphereLightDirection.value = t.hemi.positions
                }

                function W(e, t) {
                    e.ambientLightColor.needsUpdate = t, e.directionalLightColor.needsUpdate = t, e.directionalLightDirection.needsUpdate = t, e.pointLightColor.needsUpdate = t, e.pointLightPosition.needsUpdate = t, e.pointLightDistance.needsUpdate = t, e.pointLightDecay.needsUpdate = t, e.spotLightColor.needsUpdate = t, e.spotLightPosition.needsUpdate = t, e.spotLightDistance.needsUpdate = t, e.spotLightDirection.needsUpdate = t, e.spotLightAngleCos.needsUpdate = t, e.spotLightExponent.needsUpdate = t, e.spotLightDecay.needsUpdate = t, e.hemisphereLightSkyColor.needsUpdate = t, e.hemisphereLightGroundColor.needsUpdate = t, e.hemisphereLightDirection.needsUpdate = t
                }

                function X(e, t) {
                    if (e.shadowMatrix)
                        for (var n = 0, r = 0, o = t.length; o > r; r++) {
                            var a = t[r];
                            a.castShadow && (a instanceof i.SpotLight || a instanceof i.DirectionalLight && !a.shadowCascade) && (e.shadowMap.value[n] = a.shadowMap, e.shadowMapSize.value[n] = a.shadowMapSize, e.shadowMatrix.value[n] = a.shadowMatrix, e.shadowDarkness.value[n] = a.shadowDarkness, e.shadowBias.value[n] = a.shadowBias, n++)
                        }
                }

                function q(e, t) {
                    Le.uniformMatrix4fv(e.modelViewMatrix, !1, t._modelViewMatrix.elements), e.normalMatrix && Le.uniformMatrix3fv(e.normalMatrix, !1, t._normalMatrix.elements)
                }

                function K() {
                    var e = Ie;
                    return e >= ot && i.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + ot), Ie += 1, e
                }

                function Y(e) {
                    for (var t, n, r, o = 0, a = e.length; a > o; o++) {
                        var s = e[o][0];
                        if (s.needsUpdate !== !1) {
                            var l = s.type,
                                c = s.value,
                                h = e[o][1];
                            switch (l) {
                                case "1i":
                                    Le.uniform1i(h, c);
                                    break;
                                case "1f":
                                    Le.uniform1f(h, c);
                                    break;
                                case "2f":
                                    Le.uniform2f(h, c[0], c[1]);
                                    break;
                                case "3f":
                                    Le.uniform3f(h, c[0], c[1], c[2]);
                                    break;
                                case "4f":
                                    Le.uniform4f(h, c[0], c[1], c[2], c[3]);
                                    break;
                                case "1iv":
                                    Le.uniform1iv(h, c);
                                    break;
                                case "3iv":
                                    Le.uniform3iv(h, c);
                                    break;
                                case "1fv":
                                    Le.uniform1fv(h, c);
                                    break;
                                case "2fv":
                                    Le.uniform2fv(h, c);
                                    break;
                                case "3fv":
                                    Le.uniform3fv(h, c);
                                    break;
                                case "4fv":
                                    Le.uniform4fv(h, c);
                                    break;
                                case "Matrix3fv":
                                    Le.uniformMatrix3fv(h, !1, c);
                                    break;
                                case "Matrix4fv":
                                    Le.uniformMatrix4fv(h, !1, c);
                                    break;
                                case "i":
                                    Le.uniform1i(h, c);
                                    break;
                                case "f":
                                    Le.uniform1f(h, c);
                                    break;
                                case "v2":
                                    Le.uniform2f(h, c.x, c.y);
                                    break;
                                case "v3":
                                    Le.uniform3f(h, c.x, c.y, c.z);
                                    break;
                                case "v4":
                                    Le.uniform4f(h, c.x, c.y, c.z, c.w);
                                    break;
                                case "c":
                                    Le.uniform3f(h, c.r, c.g, c.b);
                                    break;
                                case "iv1":
                                    Le.uniform1iv(h, c);
                                    break;
                                case "iv":
                                    Le.uniform3iv(h, c);
                                    break;
                                case "fv1":
                                    Le.uniform1fv(h, c);
                                    break;
                                case "fv":
                                    Le.uniform3fv(h, c);
                                    break;
                                case "v2v":
                                    void 0 === s._array && (s._array = new Float32Array(2 * c.length));
                                    for (var u = 0, f = c.length; f > u; u++) r = 2 * u, s._array[r] = c[u].x, s._array[r + 1] = c[u].y;
                                    Le.uniform2fv(h, s._array);
                                    break;
                                case "v3v":
                                    void 0 === s._array && (s._array = new Float32Array(3 * c.length));
                                    for (var u = 0, f = c.length; f > u; u++) r = 3 * u, s._array[r] = c[u].x, s._array[r + 1] = c[u].y, s._array[r + 2] = c[u].z;
                                    Le.uniform3fv(h, s._array);
                                    break;
                                case "v4v":
                                    void 0 === s._array && (s._array = new Float32Array(4 * c.length));
                                    for (var u = 0, f = c.length; f > u; u++) r = 4 * u, s._array[r] = c[u].x, s._array[r + 1] = c[u].y, s._array[r + 2] = c[u].z, s._array[r + 3] = c[u].w;
                                    Le.uniform4fv(h, s._array);
                                    break;
                                case "m3":
                                    Le.uniformMatrix3fv(h, !1, c.elements);
                                    break;
                                case "m3v":
                                    void 0 === s._array && (s._array = new Float32Array(9 * c.length));
                                    for (var u = 0, f = c.length; f > u; u++) c[u].flattenToArrayOffset(s._array, 9 * u);
                                    Le.uniformMatrix3fv(h, !1, s._array);
                                    break;
                                case "m4":
                                    Le.uniformMatrix4fv(h, !1, c.elements);
                                    break;
                                case "m4v":
                                    void 0 === s._array && (s._array = new Float32Array(16 * c.length));
                                    for (var u = 0, f = c.length; f > u; u++) c[u].flattenToArrayOffset(s._array, 16 * u);
                                    Le.uniformMatrix4fv(h, !1, s._array);
                                    break;
                                case "t":
                                    if (t = c, n = K(), Le.uniform1i(h, n), !t) continue;
                                    t instanceof i.CubeTexture || t.image instanceof Array && 6 === t.image.length ? te(t, n) : t instanceof i.WebGLRenderTargetCube ? ne(t, n) : Re.setTexture(t, n);
                                    break;
                                case "tv":
                                    void 0 === s._array && (s._array = []);
                                    for (var u = 0, f = s.value.length; f > u; u++) s._array[u] = K();
                                    Le.uniform1iv(h, s._array);
                                    for (var u = 0, f = s.value.length; f > u; u++) t = s.value[u], n = s._array[u], t && Re.setTexture(t, n);
                                    break;
                                default:
                                    i.warn("THREE.WebGLRenderer: Unknown uniform type: " + l)
                            }
                        }
                    }
                }

                function $(e, t) {
                    e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix)
                }

                function J(e, t, n, i) {
                    e[t] = n.r * i, e[t + 1] = n.g * i, e[t + 2] = n.b * i
                }

                function Z(e) {
                    var t, n, r, o, a, s, l, c, h = 0,
                        u = 0,
                        f = 0,
                        d = Je,
                        p = d.directional.colors,
                        m = d.directional.positions,
                        v = d.point.colors,
                        g = d.point.positions,
                        y = d.point.distances,
                        x = d.point.decays,
                        w = d.spot.colors,
                        _ = d.spot.positions,
                        b = d.spot.distances,
                        E = d.spot.directions,
                        M = d.spot.anglesCos,
                        S = d.spot.exponents,
                        T = d.spot.decays,
                        C = d.hemi.skyColors,
                        A = d.hemi.groundColors,
                        P = d.hemi.positions,
                        D = 0,
                        L = 0,
                        R = 0,
                        O = 0,
                        N = 0,
                        U = 0,
                        F = 0,
                        k = 0,
                        H = 0,
                        I = 0,
                        V = 0,
                        z = 0;
                    for (t = 0, n = e.length; n > t; t++)
                        if (r = e[t], !r.onlyShadow)
                            if (o = r.color, l = r.intensity, c = r.distance, r instanceof i.AmbientLight) {
                                if (!r.visible) continue;
                                h += o.r, u += o.g, f += o.b
                            } else if (r instanceof i.DirectionalLight) {
                                if (N += 1, !r.visible) continue;
                                Ye.setFromMatrixPosition(r.matrixWorld), Ke.setFromMatrixPosition(r.target.matrixWorld), Ye.sub(Ke), Ye.normalize(), H = 3 * D, m[H] = Ye.x, m[H + 1] = Ye.y, m[H + 2] = Ye.z, J(p, H, o, l), D += 1
                            } else if (r instanceof i.PointLight) {
                                if (U += 1, !r.visible) continue;
                                I = 3 * L, J(v, I, o, l), Ke.setFromMatrixPosition(r.matrixWorld), g[I] = Ke.x, g[I + 1] = Ke.y, g[I + 2] = Ke.z, y[L] = c, x[L] = 0 === r.distance ? 0 : r.decay, L += 1
                            } else if (r instanceof i.SpotLight) {
                                if (F += 1, !r.visible) continue;
                                V = 3 * R, J(w, V, o, l), Ye.setFromMatrixPosition(r.matrixWorld), _[V] = Ye.x, _[V + 1] = Ye.y, _[V + 2] = Ye.z, b[R] = c, Ke.setFromMatrixPosition(r.target.matrixWorld), Ye.sub(Ke), Ye.normalize(), E[V] = Ye.x, E[V + 1] = Ye.y, E[V + 2] = Ye.z, M[R] = Math.cos(r.angle), S[R] = r.exponent, T[R] = 0 === r.distance ? 0 : r.decay, R += 1
                            } else if (r instanceof i.HemisphereLight) {
                                if (k += 1, !r.visible) continue;
                                Ye.setFromMatrixPosition(r.matrixWorld), Ye.normalize(), z = 3 * O, P[z] = Ye.x, P[z + 1] = Ye.y, P[z + 2] = Ye.z, a = r.color, s = r.groundColor, J(C, z, a, l), J(A, z, s, l), O += 1
                            }
                    for (t = 3 * D, n = Math.max(p.length, 3 * N); n > t; t++) p[t] = 0;
                    for (t = 3 * L, n = Math.max(v.length, 3 * U); n > t; t++) v[t] = 0;
                    for (t = 3 * R, n = Math.max(w.length, 3 * F); n > t; t++) w[t] = 0;
                    for (t = 3 * O, n = Math.max(C.length, 3 * k); n > t; t++) C[t] = 0;
                    for (t = 3 * O, n = Math.max(A.length, 3 * k); n > t; t++) A[t] = 0;
                    d.directional.length = D, d.point.length = L, d.spot.length = R, d.hemi.length = O, d.ambient[0] = h, d.ambient[1] = u, d.ambient[2] = f
                }

                function Q(e, t, n) {
                    var r;
                    n ? (Le.texParameteri(e, Le.TEXTURE_WRAP_S, se(t.wrapS)), Le.texParameteri(e, Le.TEXTURE_WRAP_T, se(t.wrapT)), Le.texParameteri(e, Le.TEXTURE_MAG_FILTER, se(t.magFilter)), Le.texParameteri(e, Le.TEXTURE_MIN_FILTER, se(t.minFilter))) : (Le.texParameteri(e, Le.TEXTURE_WRAP_S, Le.CLAMP_TO_EDGE), Le.texParameteri(e, Le.TEXTURE_WRAP_T, Le.CLAMP_TO_EDGE), t.wrapS === i.ClampToEdgeWrapping && t.wrapT === i.ClampToEdgeWrapping || i.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + t.sourceFile + " )"), Le.texParameteri(e, Le.TEXTURE_MAG_FILTER, ae(t.magFilter)), Le.texParameteri(e, Le.TEXTURE_MIN_FILTER, ae(t.minFilter)), t.minFilter !== i.NearestFilter && t.minFilter !== i.LinearFilter && i.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + t.sourceFile + " )")), r = tt.get("EXT_texture_filter_anisotropic"), r && t.type !== i.FloatType && t.type !== i.HalfFloatType && (t.anisotropy > 1 || t.__currentAnisotropy) && (Le.texParameterf(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, Re.getMaxAnisotropy())), t.__currentAnisotropy = t.anisotropy)
                }

                function ee(e, t) {
                    if (e.width > t || e.height > t) {
                        var n = t / Math.max(e.width, e.height),
                            r = document.createElement("canvas");
                        r.width = Math.floor(e.width * n), r.height = Math.floor(e.height * n);
                        var o = r.getContext("2d");
                        return o.drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), i.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e), r
                    }
                    return e
                }

                function te(e, t) {
                    if (6 === e.image.length)
                        if (e.needsUpdate) {
                            e.image.__webglTextureCube || (e.addEventListener("dispose", Et), e.image.__webglTextureCube = Le.createTexture(), Re.info.memory.textures++), Le.activeTexture(Le.TEXTURE0 + t), Le.bindTexture(Le.TEXTURE_CUBE_MAP, e.image.__webglTextureCube), Le.pixelStorei(Le.UNPACK_FLIP_Y_WEBGL, e.flipY);
                            for (var n = e instanceof i.CompressedTexture, r = e.image[0] instanceof i.DataTexture, o = [], a = 0; 6 > a; a++)!Re.autoScaleCubemaps || n || r ? o[a] = r ? e.image[a].image : e.image[a] : o[a] = ee(e.image[a], lt);
                            var s = o[0],
                                l = i.Math.isPowerOfTwo(s.width) && i.Math.isPowerOfTwo(s.height),
                                c = se(e.format),
                                h = se(e.type);
                            Q(Le.TEXTURE_CUBE_MAP, e, l);
                            for (var a = 0; 6 > a; a++)
                                if (n)
                                    for (var u, f = o[a].mipmaps, d = 0, p = f.length; p > d; d++) u = f[d], e.format !== i.RGBAFormat && e.format !== i.RGBFormat ? mt().indexOf(c) > -1 ? Le.compressedTexImage2D(Le.TEXTURE_CUBE_MAP_POSITIVE_X + a, d, c, u.width, u.height, 0, u.data) : i.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : Le.texImage2D(Le.TEXTURE_CUBE_MAP_POSITIVE_X + a, d, c, u.width, u.height, 0, c, h, u.data);
                                else r ? Le.texImage2D(Le.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, c, o[a].width, o[a].height, 0, c, h, o[a].data) : Le.texImage2D(Le.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, c, c, h, o[a]);
                            e.generateMipmaps && l && Le.generateMipmap(Le.TEXTURE_CUBE_MAP), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
                        } else Le.activeTexture(Le.TEXTURE0 + t), Le.bindTexture(Le.TEXTURE_CUBE_MAP, e.image.__webglTextureCube)
                }

                function ne(e, t) {
                    Le.activeTexture(Le.TEXTURE0 + t), Le.bindTexture(Le.TEXTURE_CUBE_MAP, e.__webglTexture)
                }

                function ie(e, t, n) {
                    Le.bindFramebuffer(Le.FRAMEBUFFER, e), Le.framebufferTexture2D(Le.FRAMEBUFFER, Le.COLOR_ATTACHMENT0, n, t.__webglTexture, 0)
                }

                function re(e, t) {
                    Le.bindRenderbuffer(Le.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (Le.renderbufferStorage(Le.RENDERBUFFER, Le.DEPTH_COMPONENT16, t.width, t.height), Le.framebufferRenderbuffer(Le.FRAMEBUFFER, Le.DEPTH_ATTACHMENT, Le.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (Le.renderbufferStorage(Le.RENDERBUFFER, Le.DEPTH_STENCIL, t.width, t.height), Le.framebufferRenderbuffer(Le.FRAMEBUFFER, Le.DEPTH_STENCIL_ATTACHMENT, Le.RENDERBUFFER, e)) : Le.renderbufferStorage(Le.RENDERBUFFER, Le.RGBA4, t.width, t.height)
                }

                function oe(e) {
                    e instanceof i.WebGLRenderTargetCube ? (Le.bindTexture(Le.TEXTURE_CUBE_MAP, e.__webglTexture), Le.generateMipmap(Le.TEXTURE_CUBE_MAP), Le.bindTexture(Le.TEXTURE_CUBE_MAP, null)) : (Le.bindTexture(Le.TEXTURE_2D, e.__webglTexture), Le.generateMipmap(Le.TEXTURE_2D), Le.bindTexture(Le.TEXTURE_2D, null))
                }

                function ae(e) {
                    return e === i.NearestFilter || e === i.NearestMipMapNearestFilter || e === i.NearestMipMapLinearFilter ? Le.NEAREST : Le.LINEAR
                }

                function se(e) {
                    var t;
                    if (e === i.RepeatWrapping) return Le.REPEAT;
                    if (e === i.ClampToEdgeWrapping) return Le.CLAMP_TO_EDGE;
                    if (e === i.MirroredRepeatWrapping) return Le.MIRRORED_REPEAT;
                    if (e === i.NearestFilter) return Le.NEAREST;
                    if (e === i.NearestMipMapNearestFilter) return Le.NEAREST_MIPMAP_NEAREST;
                    if (e === i.NearestMipMapLinearFilter) return Le.NEAREST_MIPMAP_LINEAR;
                    if (e === i.LinearFilter) return Le.LINEAR;
                    if (e === i.LinearMipMapNearestFilter) return Le.LINEAR_MIPMAP_NEAREST;
                    if (e === i.LinearMipMapLinearFilter) return Le.LINEAR_MIPMAP_LINEAR;
                    if (e === i.UnsignedByteType) return Le.UNSIGNED_BYTE;
                    if (e === i.UnsignedShort4444Type) return Le.UNSIGNED_SHORT_4_4_4_4;
                    if (e === i.UnsignedShort5551Type) return Le.UNSIGNED_SHORT_5_5_5_1;
                    if (e === i.UnsignedShort565Type) return Le.UNSIGNED_SHORT_5_6_5;
                    if (e === i.ByteType) return Le.BYTE;
                    if (e === i.ShortType) return Le.SHORT;
                    if (e === i.UnsignedShortType) return Le.UNSIGNED_SHORT;
                    if (e === i.IntType) return Le.INT;
                    if (e === i.UnsignedIntType) return Le.UNSIGNED_INT;
                    if (e === i.FloatType) return Le.FLOAT;
                    if (t = tt.get("OES_texture_half_float"), null !== t && e === i.HalfFloatType) return t.HALF_FLOAT_OES;
                    if (e === i.AlphaFormat) return Le.ALPHA;
                    if (e === i.RGBFormat) return Le.RGB;
                    if (e === i.RGBAFormat) return Le.RGBA;
                    if (e === i.LuminanceFormat) return Le.LUMINANCE;
                    if (e === i.LuminanceAlphaFormat) return Le.LUMINANCE_ALPHA;
                    if (e === i.AddEquation) return Le.FUNC_ADD;
                    if (e === i.SubtractEquation) return Le.FUNC_SUBTRACT;
                    if (e === i.ReverseSubtractEquation) return Le.FUNC_REVERSE_SUBTRACT;
                    if (e === i.ZeroFactor) return Le.ZERO;
                    if (e === i.OneFactor) return Le.ONE;
                    if (e === i.SrcColorFactor) return Le.SRC_COLOR;
                    if (e === i.OneMinusSrcColorFactor) return Le.ONE_MINUS_SRC_COLOR;
                    if (e === i.SrcAlphaFactor) return Le.SRC_ALPHA;
                    if (e === i.OneMinusSrcAlphaFactor) return Le.ONE_MINUS_SRC_ALPHA;
                    if (e === i.DstAlphaFactor) return Le.DST_ALPHA;
                    if (e === i.OneMinusDstAlphaFactor) return Le.ONE_MINUS_DST_ALPHA;
                    if (e === i.DstColorFactor) return Le.DST_COLOR;
                    if (e === i.OneMinusDstColorFactor) return Le.ONE_MINUS_DST_COLOR;
                    if (e === i.SrcAlphaSaturateFactor) return Le.SRC_ALPHA_SATURATE;
                    if (t = tt.get("WEBGL_compressed_texture_s3tc"), null !== t) {
                        if (e === i.RGB_S3TC_DXT1_Format) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (e === i.RGBA_S3TC_DXT1_Format) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (e === i.RGBA_S3TC_DXT3_Format) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (e === i.RGBA_S3TC_DXT5_Format) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t = tt.get("WEBGL_compressed_texture_pvrtc"), null !== t) {
                        if (e === i.RGB_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (e === i.RGB_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (e === i.RGBA_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (e === i.RGBA_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t = tt.get("EXT_blend_minmax"), null !== t) {
                        if (e === i.MinEquation) return t.MIN_EXT;
                        if (e === i.MaxEquation) return t.MAX_EXT
                    }
                    return 0
                }

                function le(e) {
                    if (ht && e && e.skeleton && e.skeleton.useVertexTexture) return 1024;
                    var t = Le.getParameter(Le.MAX_VERTEX_UNIFORM_VECTORS),
                        n = Math.floor((t - 20) / 4),
                        r = n;
                    return void 0 !== e && e instanceof i.SkinnedMesh && (r = Math.min(e.skeleton.bones.length, r), r < e.skeleton.bones.length && i.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + r + " (try OpenGL instead of ANGLE)")), r
                }

                function ce(e) {
                    for (var t = 0, n = 0, r = 0, o = 0, a = 0, s = e.length; s > a; a++) {
                        var l = e[a];
                        l.onlyShadow || l.visible === !1 || (l instanceof i.DirectionalLight && t++, l instanceof i.PointLight && n++, l instanceof i.SpotLight && r++, l instanceof i.HemisphereLight && o++)
                    }
                    return {
                        directional: t,
                        point: n,
                        spot: r,
                        hemi: o
                    }
                }

                function he(e) {
                    for (var t = 0, n = 0, r = e.length; r > n; n++) {
                        var o = e[n];
                        o.castShadow && (o instanceof i.SpotLight && t++, o instanceof i.DirectionalLight && !o.shadowCascade && t++)
                    }
                    return t
                }
                console.log("THREE.WebGLRenderer", i.REVISION), e = e || {};
                var ue = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
                    fe = void 0 !== e.context ? e.context : null,
                    de = 1,
                    pe = void 0 !== e.precision ? e.precision : "highp",
                    me = void 0 !== e.alpha ? e.alpha : !1,
                    ve = void 0 !== e.depth ? e.depth : !0,
                    ge = void 0 !== e.stencil ? e.stencil : !0,
                    ye = void 0 !== e.antialias ? e.antialias : !1,
                    xe = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
                    we = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
                    _e = void 0 !== e.logarithmicDepthBuffer ? e.logarithmicDepthBuffer : !1,
                    be = new i.Color(0),
                    Ee = 0,
                    Me = [],
                    Se = {},
                    Te = [],
                    Ce = [],
                    Ae = [],
                    Pe = [],
                    De = [];
                this.domElement = ue, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.shadowMapEnabled = !1, this.shadowMapType = i.PCFShadowMap, this.shadowMapCullFace = i.CullFaceFront, this.shadowMapDebug = !1, this.shadowMapCascade = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.info = {
                    memory: {
                        programs: 0,
                        geometries: 0,
                        textures: 0
                    },
                    render: {
                        calls: 0,
                        vertices: 0,
                        faces: 0,
                        points: 0
                    }
                };
                var Le, Re = this,
                    Oe = [],
                    Ne = null,
                    Ue = null,
                    Fe = -1,
                    ke = "",
                    He = null,
                    Ie = 0,
                    Ve = 0,
                    ze = 0,
                    Be = ue.width,
                    je = ue.height,
                    Ge = 0,
                    We = 0,
                    Xe = new i.Frustum,
                    qe = new i.Matrix4,
                    Ke = new i.Vector3,
                    Ye = new i.Vector3,
                    $e = !0,
                    Je = {
                        ambient: [0, 0, 0],
                        directional: {
                            length: 0,
                            colors: [],
                            positions: []
                        },
                        point: {
                            length: 0,
                            colors: [],
                            positions: [],
                            distances: [],
                            decays: []
                        },
                        spot: {
                            length: 0,
                            colors: [],
                            positions: [],
                            distances: [],
                            directions: [],
                            anglesCos: [],
                            exponents: [],
                            decays: []
                        },
                        hemi: {
                            length: 0,
                            skyColors: [],
                            groundColors: [],
                            positions: []
                        }
                    };
                try {
                    var Ze = {
                        alpha: me,
                        depth: ve,
                        stencil: ge,
                        antialias: ye,
                        premultipliedAlpha: xe,
                        preserveDrawingBuffer: we
                    };
                    if (Le = fe || ue.getContext("webgl", Ze) || ue.getContext("experimental-webgl", Ze), null === Le) throw null !== ue.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                    ue.addEventListener("webglcontextlost", function(e) {
                        e.preventDefault(), rt(), it(), Se = {}
                    }, !1)
                } catch (Qe) {
                    i.error("THREE.WebGLRenderer: " + Qe)
                }
                var et = new i.WebGLState(Le, se);
                void 0 === Le.getShaderPrecisionFormat && (Le.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                });
                var tt = new i.WebGLExtensions(Le);
                tt.get("OES_texture_float"), tt.get("OES_texture_float_linear"), tt.get("OES_texture_half_float"), tt.get("OES_texture_half_float_linear"), tt.get("OES_standard_derivatives"), _e && tt.get("EXT_frag_depth");
                var nt = function(e, t, n, i) {
                        xe === !0 && (e *= i, t *= i, n *= i), Le.clearColor(e, t, n, i)
                    },
                    it = function() {
                        Le.clearColor(0, 0, 0, 1), Le.clearDepth(1), Le.clearStencil(0), Le.enable(Le.DEPTH_TEST), Le.depthFunc(Le.LEQUAL), Le.frontFace(Le.CCW), Le.cullFace(Le.BACK), Le.enable(Le.CULL_FACE), Le.enable(Le.BLEND), Le.blendEquation(Le.FUNC_ADD), Le.blendFunc(Le.SRC_ALPHA, Le.ONE_MINUS_SRC_ALPHA), Le.viewport(Ve, ze, Be, je), nt(be.r, be.g, be.b, Ee)
                    },
                    rt = function() {
                        Ne = null, He = null, ke = "", Fe = -1, $e = !0, et.reset()
                    };
                it(), this.context = Le, this.state = et;
                var ot = Le.getParameter(Le.MAX_TEXTURE_IMAGE_UNITS),
                    at = Le.getParameter(Le.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    st = Le.getParameter(Le.MAX_TEXTURE_SIZE),
                    lt = Le.getParameter(Le.MAX_CUBE_MAP_TEXTURE_SIZE),
                    ct = at > 0,
                    ht = ct && tt.get("OES_texture_float"),
                    ut = Le.getShaderPrecisionFormat(Le.VERTEX_SHADER, Le.HIGH_FLOAT),
                    ft = Le.getShaderPrecisionFormat(Le.VERTEX_SHADER, Le.MEDIUM_FLOAT),
                    dt = Le.getShaderPrecisionFormat(Le.FRAGMENT_SHADER, Le.HIGH_FLOAT),
                    pt = Le.getShaderPrecisionFormat(Le.FRAGMENT_SHADER, Le.MEDIUM_FLOAT),
                    mt = function() {
                        var e;
                        return function() {
                            if (void 0 !== e) return e;
                            if (e = [], tt.get("WEBGL_compressed_texture_pvrtc") || tt.get("WEBGL_compressed_texture_s3tc"))
                                for (var t = Le.getParameter(Le.COMPRESSED_TEXTURE_FORMATS), n = 0; n < t.length; n++) e.push(t[n]);
                            return e
                        }
                    }(),
                    vt = ut.precision > 0 && dt.precision > 0,
                    gt = ft.precision > 0 && pt.precision > 0;
                "highp" !== pe || vt || (gt ? (pe = "mediump", i.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (pe = "lowp", i.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== pe || gt || (pe = "lowp", i.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
                var yt = new i.ShadowMapPlugin(this, Me, Se, Te),
                    xt = new i.SpritePlugin(this, Pe),
                    wt = new i.LensFlarePlugin(this, De);
                this.getContext = function() {
                    return Le
                }, this.forceContextLoss = function() {
                    tt.get("WEBGL_lose_context").loseContext()
                }, this.supportsVertexTextures = function() {
                    return ct
                }, this.supportsFloatTextures = function() {
                    return tt.get("OES_texture_float")
                }, this.supportsHalfFloatTextures = function() {
                    return tt.get("OES_texture_half_float")
                }, this.supportsStandardDerivatives = function() {
                    return tt.get("OES_standard_derivatives")
                }, this.supportsCompressedTextureS3TC = function() {
                    return tt.get("WEBGL_compressed_texture_s3tc")
                }, this.supportsCompressedTexturePVRTC = function() {
                    return tt.get("WEBGL_compressed_texture_pvrtc")
                }, this.supportsBlendMinMax = function() {
                    return tt.get("EXT_blend_minmax")
                }, this.getMaxAnisotropy = function() {
                    var e;
                    return function() {
                        if (void 0 !== e) return e;
                        var t = tt.get("EXT_texture_filter_anisotropic");
                        return e = null !== t ? Le.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    }
                }(), this.getPrecision = function() {
                    return pe
                }, this.getPixelRatio = function() {
                    return de
                }, this.setPixelRatio = function(e) {
                    de = e
                }, this.setSize = function(e, t, n) {
                    ue.width = e * de, ue.height = t * de, n !== !1 && (ue.style.width = e + "px", ue.style.height = t + "px"), this.setViewport(0, 0, e, t)
                }, this.setViewport = function(e, t, n, i) {
                    Ve = e * de, ze = t * de, Be = n * de, je = i * de, Le.viewport(Ve, ze, Be, je)
                }, this.setScissor = function(e, t, n, i) {
                    Le.scissor(e * de, t * de, n * de, i * de)
                }, this.enableScissorTest = function(e) {
                    e ? Le.enable(Le.SCISSOR_TEST) : Le.disable(Le.SCISSOR_TEST)
                }, this.getClearColor = function() {
                    return be
                }, this.setClearColor = function(e, t) {
                    be.set(e), Ee = void 0 !== t ? t : 1, nt(be.r, be.g, be.b, Ee)
                }, this.getClearAlpha = function() {
                    return Ee
                }, this.setClearAlpha = function(e) {
                    Ee = e, nt(be.r, be.g, be.b, Ee)
                }, this.clear = function(e, t, n) {
                    var i = 0;
                    (void 0 === e || e) && (i |= Le.COLOR_BUFFER_BIT), (void 0 === t || t) && (i |= Le.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= Le.STENCIL_BUFFER_BIT), Le.clear(i)
                }, this.clearColor = function() {
                    Le.clear(Le.COLOR_BUFFER_BIT)
                }, this.clearDepth = function() {
                    Le.clear(Le.DEPTH_BUFFER_BIT)
                }, this.clearStencil = function() {
                    Le.clear(Le.STENCIL_BUFFER_BIT)
                }, this.clearTarget = function(e, t, n, i) {
                    this.setRenderTarget(e), this.clear(t, n, i)
                }, this.resetGLState = rt;
                var _t = function(e) {
                        var t = e.target;
                        t.traverse(function(e) {
                            e.removeEventListener("remove", _t), R(e)
                        })
                    },
                    bt = function(e) {
                        var t = e.target;
                        t.removeEventListener("dispose", bt), Ct(t)
                    },
                    Et = function(e) {
                        var t = e.target;
                        t.removeEventListener("dispose", Et), At(t), Re.info.memory.textures--
                    },
                    Mt = function(e) {
                        var t = e.target;
                        t.removeEventListener("dispose", Mt), Pt(t), Re.info.memory.textures--
                    },
                    St = function(e) {
                        var t = e.target;
                        t.removeEventListener("dispose", St), Dt(t)
                    },
                    Tt = function(e) {
                        for (var t = ["__webglVertexBuffer", "__webglNormalBuffer", "__webglTangentBuffer", "__webglColorBuffer", "__webglUVBuffer", "__webglUV2Buffer", "__webglSkinIndicesBuffer", "__webglSkinWeightsBuffer", "__webglFaceBuffer", "__webglLineBuffer", "__webglLineDistanceBuffer"], n = 0, i = t.length; i > n; n++) {
                            var r = t[n];
                            void 0 !== e[r] && (Le.deleteBuffer(e[r]), delete e[r])
                        }
                        if (void 0 !== e.__webglCustomAttributesList) {
                            for (var r in e.__webglCustomAttributesList) Le.deleteBuffer(e.__webglCustomAttributesList[r].buffer);
                            delete e.__webglCustomAttributesList
                        }
                        Re.info.memory.geometries--
                    },
                    Ct = function(e) {
                        if (delete e.__webglInit, e instanceof i.BufferGeometry) {
                            for (var t in e.attributes) {
                                var n = e.attributes[t];
                                void 0 !== n.buffer && (Le.deleteBuffer(n.buffer), delete n.buffer)
                            }
                            Re.info.memory.geometries--
                        } else {
                            var r = Lt[e.id];
                            if (void 0 !== r) {
                                for (var o = 0, a = r.length; a > o; o++) {
                                    var s = r[o];
                                    if (void 0 !== s.numMorphTargets) {
                                        for (var l = 0, c = s.numMorphTargets; c > l; l++) Le.deleteBuffer(s.__webglMorphTargetsBuffers[l]);
                                        delete s.__webglMorphTargetsBuffers
                                    }
                                    if (void 0 !== s.numMorphNormals) {
                                        for (var l = 0, c = s.numMorphNormals; c > l; l++) Le.deleteBuffer(s.__webglMorphNormalsBuffers[l]);
                                        delete s.__webglMorphNormalsBuffers
                                    }
                                    Tt(s)
                                }
                                delete Lt[e.id]
                            } else Tt(e)
                        }
                        ke = ""
                    },
                    At = function(e) {
                        if (e.image && e.image.__webglTextureCube) Le.deleteTexture(e.image.__webglTextureCube), delete e.image.__webglTextureCube;
                        else {
                            if (void 0 === e.__webglInit) return;
                            Le.deleteTexture(e.__webglTexture), delete e.__webglTexture, delete e.__webglInit
                        }
                    },
                    Pt = function(e) {
                        if (e && void 0 !== e.__webglTexture) {
                            if (Le.deleteTexture(e.__webglTexture), delete e.__webglTexture, e instanceof i.WebGLRenderTargetCube)
                                for (var t = 0; 6 > t; t++) Le.deleteFramebuffer(e.__webglFramebuffer[t]), Le.deleteRenderbuffer(e.__webglRenderbuffer[t]);
                            else Le.deleteFramebuffer(e.__webglFramebuffer), Le.deleteRenderbuffer(e.__webglRenderbuffer);
                            delete e.__webglFramebuffer, delete e.__webglRenderbuffer
                        }
                    },
                    Dt = function(e) {
                        var t = e.program.program;
                        if (void 0 !== t) {
                            e.program = void 0;
                            var n, i, r, o = !1;
                            for (n = 0, i = Oe.length; i > n; n++)
                                if (r = Oe[n], r.program === t) {
                                    r.usedTimes--, 0 === r.usedTimes && (o = !0);
                                    break
                                }
                            if (o === !0) {
                                var a = [];
                                for (n = 0, i = Oe.length; i > n; n++) r = Oe[n], r.program !== t && a.push(r);
                                Oe = a, Le.deleteProgram(t), Re.info.memory.programs--
                            }
                        }
                    };
                this.renderBufferImmediate = function(e, t, n) {
                    if (et.initAttributes(), e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = Le.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = Le.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = Le.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = Le.createBuffer()), e.hasPositions && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglVertexBuffer), Le.bufferData(Le.ARRAY_BUFFER, e.positionArray, Le.DYNAMIC_DRAW), et.enableAttribute(t.attributes.position), Le.vertexAttribPointer(t.attributes.position, 3, Le.FLOAT, !1, 0, 0)), e.hasNormals) {
                        if (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglNormalBuffer), n instanceof i.MeshPhongMaterial == !1 && n.shading === i.FlatShading) {
                            var r, o, a, s, l, c, h, u, f, d, p, m, v, g, y = 3 * e.count;
                            for (g = 0; y > g; g += 9) v = e.normalArray, s = v[g], h = v[g + 1], d = v[g + 2], l = v[g + 3], u = v[g + 4], p = v[g + 5], c = v[g + 6], f = v[g + 7], m = v[g + 8], r = (s + l + c) / 3, o = (h + u + f) / 3, a = (d + p + m) / 3, v[g] = r, v[g + 1] = o, v[g + 2] = a, v[g + 3] = r, v[g + 4] = o, v[g + 5] = a, v[g + 6] = r, v[g + 7] = o, v[g + 8] = a
                        }
                        Le.bufferData(Le.ARRAY_BUFFER, e.normalArray, Le.DYNAMIC_DRAW), et.enableAttribute(t.attributes.normal), Le.vertexAttribPointer(t.attributes.normal, 3, Le.FLOAT, !1, 0, 0)
                    }
                    e.hasUvs && n.map && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglUvBuffer), Le.bufferData(Le.ARRAY_BUFFER, e.uvArray, Le.DYNAMIC_DRAW), et.enableAttribute(t.attributes.uv), Le.vertexAttribPointer(t.attributes.uv, 2, Le.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== i.NoColors && (Le.bindBuffer(Le.ARRAY_BUFFER, e.__webglColorBuffer), Le.bufferData(Le.ARRAY_BUFFER, e.colorArray, Le.DYNAMIC_DRAW), et.enableAttribute(t.attributes.color), Le.vertexAttribPointer(t.attributes.color, 3, Le.FLOAT, !1, 0, 0)), et.disableUnusedAttributes(), Le.drawArrays(Le.TRIANGLES, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function(e, t, n, r, o, a) {
                    if (r.visible !== !1) {
                        P(a);
                        var s = F(e, t, n, r, a),
                            l = !1,
                            c = r.wireframe ? 1 : 0,
                            h = "direct_" + o.id + "_" + s.id + "_" + c;
                        if (h !== ke && (ke = h, l = !0), l && et.initAttributes(), a instanceof i.Mesh) {
                            var u = r.wireframe === !0 ? Le.LINES : Le.TRIANGLES,
                                f = o.attributes.index;
                            if (f) {
                                var d, m;
                                f.array instanceof Uint32Array && tt.get("OES_element_index_uint") ? (d = Le.UNSIGNED_INT, m = 4) : (d = Le.UNSIGNED_SHORT, m = 2);
                                var v = o.offsets;
                                if (0 === v.length) l && (p(r, s, o, 0), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, f.array.length, d, 0), Re.info.render.calls++, Re.info.render.vertices += f.array.length, Re.info.render.faces += f.array.length / 3;
                                else {
                                    l = !0;
                                    for (var g = 0, y = v.length; y > g; g++) {
                                        var x = v[g].index;
                                        l && (p(r, s, o, x), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, v[g].count, d, v[g].start * m), Re.info.render.calls++, Re.info.render.vertices += v[g].count, Re.info.render.faces += v[g].count / 3
                                    }
                                }
                            } else {
                                l && p(r, s, o, 0);
                                var w = o.attributes.position;
                                Le.drawArrays(u, 0, w.array.length / w.itemSize), Re.info.render.calls++, Re.info.render.vertices += w.array.length / w.itemSize, Re.info.render.faces += w.array.length / (3 * w.itemSize)
                            }
                        } else if (a instanceof i.PointCloud) {
                            var u = Le.POINTS,
                                f = o.attributes.index;
                            if (f) {
                                var d, m;
                                f.array instanceof Uint32Array && tt.get("OES_element_index_uint") ? (d = Le.UNSIGNED_INT, m = 4) : (d = Le.UNSIGNED_SHORT, m = 2);
                                var v = o.offsets;
                                if (0 === v.length) l && (p(r, s, o, 0), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, f.array.length, d, 0), Re.info.render.calls++, Re.info.render.points += f.array.length;
                                else {
                                    v.length > 1 && (l = !0);
                                    for (var g = 0, y = v.length; y > g; g++) {
                                        var x = v[g].index;
                                        l && (p(r, s, o, x), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, v[g].count, d, v[g].start * m), Re.info.render.calls++, Re.info.render.points += v[g].count
                                    }
                                }
                            } else {
                                l && p(r, s, o, 0);
                                var w = o.attributes.position,
                                    v = o.offsets;
                                if (0 === v.length) Le.drawArrays(u, 0, w.array.length / 3), Re.info.render.calls++, Re.info.render.points += w.array.length / 3;
                                else
                                    for (var g = 0, y = v.length; y > g; g++) Le.drawArrays(u, v[g].index, v[g].count), Re.info.render.calls++, Re.info.render.points += v[g].count
                            }
                        } else if (a instanceof i.Line) {
                            var u = a.mode === i.LineStrip ? Le.LINE_STRIP : Le.LINES;
                            et.setLineWidth(r.linewidth * de);
                            var f = o.attributes.index;
                            if (f) {
                                var d, m;
                                f.array instanceof Uint32Array ? (d = Le.UNSIGNED_INT, m = 4) : (d = Le.UNSIGNED_SHORT, m = 2);
                                var v = o.offsets;
                                if (0 === v.length) l && (p(r, s, o, 0), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, f.array.length, d, 0), Re.info.render.calls++, Re.info.render.vertices += f.array.length;
                                else {
                                    v.length > 1 && (l = !0);
                                    for (var g = 0, y = v.length; y > g; g++) {
                                        var x = v[g].index;
                                        l && (p(r, s, o, x), Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, f.buffer)), Le.drawElements(u, v[g].count, d, v[g].start * m), Re.info.render.calls++, Re.info.render.vertices += v[g].count
                                    }
                                }
                            } else {
                                l && p(r, s, o, 0);
                                var w = o.attributes.position,
                                    v = o.offsets;
                                if (0 === v.length) Le.drawArrays(u, 0, w.array.length / 3), Re.info.render.calls++, Re.info.render.vertices += w.array.length / 3;
                                else
                                    for (var g = 0, y = v.length; y > g; g++) Le.drawArrays(u, v[g].index, v[g].count), Re.info.render.calls++, Re.info.render.vertices += v[g].count
                            }
                        }
                    }
                }, this.renderBuffer = function(e, t, n, r, o, a) {
                    if (r.visible !== !1) {
                        P(a);
                        var s = F(e, t, n, r, a),
                            l = s.attributes,
                            c = !1,
                            h = r.wireframe ? 1 : 0,
                            u = o.id + "_" + s.id + "_" + h;
                        if (u !== ke && (ke = u, c = !0), c && et.initAttributes(), !r.morphTargets && l.position >= 0 ? c && (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglVertexBuffer), et.enableAttribute(l.position), Le.vertexAttribPointer(l.position, 3, Le.FLOAT, !1, 0, 0)) : a.morphTargetBase && m(r, o, a), c) {
                            if (o.__webglCustomAttributesList)
                                for (var f = 0, d = o.__webglCustomAttributesList.length; d > f; f++) {
                                    var p = o.__webglCustomAttributesList[f];
                                    l[p.buffer.belongsToAttribute] >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, p.buffer), et.enableAttribute(l[p.buffer.belongsToAttribute]), Le.vertexAttribPointer(l[p.buffer.belongsToAttribute], p.size, Le.FLOAT, !1, 0, 0))
                                }
                            l.color >= 0 && (a.geometry.colors.length > 0 || a.geometry.faces.length > 0 ? (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglColorBuffer), et.enableAttribute(l.color), Le.vertexAttribPointer(l.color, 3, Le.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && Le.vertexAttrib3fv(l.color, r.defaultAttributeValues.color)), l.normal >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglNormalBuffer), et.enableAttribute(l.normal), Le.vertexAttribPointer(l.normal, 3, Le.FLOAT, !1, 0, 0)), l.tangent >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglTangentBuffer), et.enableAttribute(l.tangent), Le.vertexAttribPointer(l.tangent, 4, Le.FLOAT, !1, 0, 0)), l.uv >= 0 && (a.geometry.faceVertexUvs[0] ? (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglUVBuffer), et.enableAttribute(l.uv), Le.vertexAttribPointer(l.uv, 2, Le.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && Le.vertexAttrib2fv(l.uv, r.defaultAttributeValues.uv)),
                            l.uv2 >= 0 && (a.geometry.faceVertexUvs[1] ? (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglUV2Buffer), et.enableAttribute(l.uv2), Le.vertexAttribPointer(l.uv2, 2, Le.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && Le.vertexAttrib2fv(l.uv2, r.defaultAttributeValues.uv2)), r.skinning && l.skinIndex >= 0 && l.skinWeight >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglSkinIndicesBuffer), et.enableAttribute(l.skinIndex), Le.vertexAttribPointer(l.skinIndex, 4, Le.FLOAT, !1, 0, 0), Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglSkinWeightsBuffer), et.enableAttribute(l.skinWeight), Le.vertexAttribPointer(l.skinWeight, 4, Le.FLOAT, !1, 0, 0)), l.lineDistance >= 0 && (Le.bindBuffer(Le.ARRAY_BUFFER, o.__webglLineDistanceBuffer), et.enableAttribute(l.lineDistance), Le.vertexAttribPointer(l.lineDistance, 1, Le.FLOAT, !1, 0, 0))
                        }
                        if (et.disableUnusedAttributes(), a instanceof i.Mesh) {
                            var v = o.__typeArray === Uint32Array ? Le.UNSIGNED_INT : Le.UNSIGNED_SHORT;
                            r.wireframe ? (et.setLineWidth(r.wireframeLinewidth * de), c && Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, o.__webglLineBuffer), Le.drawElements(Le.LINES, o.__webglLineCount, v, 0)) : (c && Le.bindBuffer(Le.ELEMENT_ARRAY_BUFFER, o.__webglFaceBuffer), Le.drawElements(Le.TRIANGLES, o.__webglFaceCount, v, 0)), Re.info.render.calls++, Re.info.render.vertices += o.__webglFaceCount, Re.info.render.faces += o.__webglFaceCount / 3
                        } else if (a instanceof i.Line) {
                            var g = a.mode === i.LineStrip ? Le.LINE_STRIP : Le.LINES;
                            et.setLineWidth(r.linewidth * de), Le.drawArrays(g, 0, o.__webglLineCount), Re.info.render.calls++
                        } else a instanceof i.PointCloud && (Le.drawArrays(Le.POINTS, 0, o.__webglParticleCount), Re.info.render.calls++, Re.info.render.points += o.__webglParticleCount)
                    }
                }, this.render = function(e, t, n, r) {
                    if (t instanceof i.Camera == !1) return void i.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    var o = e.fog;
                    ke = "", Fe = -1, He = null, $e = !0, e.autoUpdate === !0 && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), e.traverse(function(e) {
                        e instanceof i.SkinnedMesh && e.skeleton.update()
                    }), t.matrixWorldInverse.getInverse(t.matrixWorld), qe.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Xe.setFromMatrix(qe), Me.length = 0, Ce.length = 0, Ae.length = 0, Pe.length = 0, De.length = 0, x(e), Re.sortObjects === !0 && (Ce.sort(v), Ae.sort(g)), yt.render(e, t), Re.info.render.calls = 0, Re.info.render.vertices = 0, Re.info.render.faces = 0, Re.info.render.points = 0, this.setRenderTarget(n), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
                    for (var a = 0, s = Te.length; s > a; a++) {
                        var l = Te[a],
                            c = l.object;
                        c.visible && ($(c, t), b(l))
                    }
                    if (e.overrideMaterial) {
                        var h = e.overrideMaterial;
                        U(h), w(Ce, t, Me, o, h), w(Ae, t, Me, o, h), _(Te, "", t, Me, o, h)
                    } else et.setBlending(i.NoBlending), w(Ce, t, Me, o, null), _(Te, "opaque", t, Me, o, null), w(Ae, t, Me, o, null), _(Te, "transparent", t, Me, o, null);
                    xt.render(e, t), wt.render(e, t, Ge, We), n && n.generateMipmaps && n.minFilter !== i.NearestFilter && n.minFilter !== i.LinearFilter && oe(n), et.setDepthTest(!0), et.setDepthWrite(!0), et.setColorWrite(!0)
                }, this.renderImmediateObject = function(e, t, n, i, r) {
                    var o = F(e, t, n, i, r);
                    ke = "", Re.setMaterialFaces(i), r.immediateRenderCallback ? r.immediateRenderCallback(o, Le, Xe) : r.render(function(e) {
                        Re.renderBufferImmediate(e, o, i)
                    })
                };
                var Lt = {},
                    Rt = 0,
                    Ot = {
                        MeshDepthMaterial: "depth",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointCloudMaterial: "particle_basic"
                    };
                this.setFaceCulling = function(e, t) {
                    e === i.CullFaceNone ? Le.disable(Le.CULL_FACE) : (t === i.FrontFaceDirectionCW ? Le.frontFace(Le.CW) : Le.frontFace(Le.CCW), e === i.CullFaceBack ? Le.cullFace(Le.BACK) : e === i.CullFaceFront ? Le.cullFace(Le.FRONT) : Le.cullFace(Le.FRONT_AND_BACK), Le.enable(Le.CULL_FACE))
                }, this.setMaterialFaces = function(e) {
                    et.setDoubleSided(e.side === i.DoubleSide), et.setFlipSided(e.side === i.BackSide)
                }, this.uploadTexture = function(e) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, e.addEventListener("dispose", Et), e.__webglTexture = Le.createTexture(), Re.info.memory.textures++), Le.bindTexture(Le.TEXTURE_2D, e.__webglTexture), Le.pixelStorei(Le.UNPACK_FLIP_Y_WEBGL, e.flipY), Le.pixelStorei(Le.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), Le.pixelStorei(Le.UNPACK_ALIGNMENT, e.unpackAlignment), e.image = ee(e.image, st);
                    var t = e.image,
                        n = i.Math.isPowerOfTwo(t.width) && i.Math.isPowerOfTwo(t.height),
                        r = se(e.format),
                        o = se(e.type);
                    Q(Le.TEXTURE_2D, e, n);
                    var a, s = e.mipmaps;
                    if (e instanceof i.DataTexture)
                        if (s.length > 0 && n) {
                            for (var l = 0, c = s.length; c > l; l++) a = s[l], Le.texImage2D(Le.TEXTURE_2D, l, r, a.width, a.height, 0, r, o, a.data);
                            e.generateMipmaps = !1
                        } else Le.texImage2D(Le.TEXTURE_2D, 0, r, t.width, t.height, 0, r, o, t.data);
                    else if (e instanceof i.CompressedTexture)
                        for (var l = 0, c = s.length; c > l; l++) a = s[l], e.format !== i.RGBAFormat && e.format !== i.RGBFormat ? mt().indexOf(r) > -1 ? Le.compressedTexImage2D(Le.TEXTURE_2D, l, r, a.width, a.height, 0, a.data) : i.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Le.texImage2D(Le.TEXTURE_2D, l, r, a.width, a.height, 0, r, o, a.data);
                    else if (s.length > 0 && n) {
                        for (var l = 0, c = s.length; c > l; l++) a = s[l], Le.texImage2D(Le.TEXTURE_2D, l, r, r, o, a);
                        e.generateMipmaps = !1
                    } else Le.texImage2D(Le.TEXTURE_2D, 0, r, r, o, e.image);
                    e.generateMipmaps && n && Le.generateMipmap(Le.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
                }, this.setTexture = function(e, t) {
                    Le.activeTexture(Le.TEXTURE0 + t), e.needsUpdate ? Re.uploadTexture(e) : Le.bindTexture(Le.TEXTURE_2D, e.__webglTexture)
                }, this.setRenderTarget = function(e) {
                    var t = e instanceof i.WebGLRenderTargetCube;
                    if (e && void 0 === e.__webglFramebuffer) {
                        void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", Mt), e.__webglTexture = Le.createTexture(), Re.info.memory.textures++;
                        var n = i.Math.isPowerOfTwo(e.width) && i.Math.isPowerOfTwo(e.height),
                            r = se(e.format),
                            o = se(e.type);
                        if (t) {
                            e.__webglFramebuffer = [], e.__webglRenderbuffer = [], Le.bindTexture(Le.TEXTURE_CUBE_MAP, e.__webglTexture), Q(Le.TEXTURE_CUBE_MAP, e, n);
                            for (var a = 0; 6 > a; a++) e.__webglFramebuffer[a] = Le.createFramebuffer(), e.__webglRenderbuffer[a] = Le.createRenderbuffer(), Le.texImage2D(Le.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, r, e.width, e.height, 0, r, o, null), ie(e.__webglFramebuffer[a], e, Le.TEXTURE_CUBE_MAP_POSITIVE_X + a), re(e.__webglRenderbuffer[a], e);
                            n && Le.generateMipmap(Le.TEXTURE_CUBE_MAP)
                        } else e.__webglFramebuffer = Le.createFramebuffer(), e.shareDepthFrom ? e.__webglRenderbuffer = e.shareDepthFrom.__webglRenderbuffer : e.__webglRenderbuffer = Le.createRenderbuffer(), Le.bindTexture(Le.TEXTURE_2D, e.__webglTexture), Q(Le.TEXTURE_2D, e, n), Le.texImage2D(Le.TEXTURE_2D, 0, r, e.width, e.height, 0, r, o, null), ie(e.__webglFramebuffer, e, Le.TEXTURE_2D), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? Le.framebufferRenderbuffer(Le.FRAMEBUFFER, Le.DEPTH_ATTACHMENT, Le.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && Le.framebufferRenderbuffer(Le.FRAMEBUFFER, Le.DEPTH_STENCIL_ATTACHMENT, Le.RENDERBUFFER, e.__webglRenderbuffer) : re(e.__webglRenderbuffer, e), n && Le.generateMipmap(Le.TEXTURE_2D);
                        t ? Le.bindTexture(Le.TEXTURE_CUBE_MAP, null) : Le.bindTexture(Le.TEXTURE_2D, null), Le.bindRenderbuffer(Le.RENDERBUFFER, null), Le.bindFramebuffer(Le.FRAMEBUFFER, null)
                    }
                    var s, l, c, h, u;
                    e ? (s = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, l = e.width, c = e.height, h = 0, u = 0) : (s = null, l = Be, c = je, h = Ve, u = ze), s !== Ue && (Le.bindFramebuffer(Le.FRAMEBUFFER, s), Le.viewport(h, u, l, c), Ue = s), Ge = l, We = c
                }, this.readRenderTargetPixels = function(e, t, n, r, o, a) {
                    if (!(e instanceof i.WebGLRenderTarget)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    if (e.__webglFramebuffer) {
                        if (e.format !== i.RGBAFormat) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.");
                        var s = !1;
                        e.__webglFramebuffer !== Ue && (Le.bindFramebuffer(Le.FRAMEBUFFER, e.__webglFramebuffer), s = !0), Le.checkFramebufferStatus(Le.FRAMEBUFFER) === Le.FRAMEBUFFER_COMPLETE ? Le.readPixels(t, n, r, o, Le.RGBA, Le.UNSIGNED_BYTE, a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."), s && Le.bindFramebuffer(Le.FRAMEBUFFER, Ue)
                    }
                }, this.initMaterial = function() {
                    i.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                }, this.addPrePlugin = function() {
                    i.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                }, this.addPostPlugin = function() {
                    i.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                }, this.updateShadowMap = function() {
                    i.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }
            }, i.WebGLRenderTarget = function(e, t, n) {
                this.width = e, this.height = t, n = n || {}, this.wrapS = void 0 !== n.wrapS ? n.wrapS : i.ClampToEdgeWrapping, this.wrapT = void 0 !== n.wrapT ? n.wrapT : i.ClampToEdgeWrapping, this.magFilter = void 0 !== n.magFilter ? n.magFilter : i.LinearFilter, this.minFilter = void 0 !== n.minFilter ? n.minFilter : i.LinearMipMapLinearFilter, this.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, this.offset = new i.Vector2(0, 0), this.repeat = new i.Vector2(1, 1), this.format = void 0 !== n.format ? n.format : i.RGBAFormat, this.type = void 0 !== n.type ? n.type : i.UnsignedByteType, this.depthBuffer = void 0 !== n.depthBuffer ? n.depthBuffer : !0, this.stencilBuffer = void 0 !== n.stencilBuffer ? n.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = void 0 !== n.shareDepthFrom ? n.shareDepthFrom : null
            }, i.WebGLRenderTarget.prototype = {
                constructor: i.WebGLRenderTarget,
                setSize: function(e, t) {
                    this.width = e, this.height = t
                },
                clone: function() {
                    var e = new i.WebGLRenderTarget(this.width, this.height);
                    return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, i.EventDispatcher.prototype.apply(i.WebGLRenderTarget.prototype), i.WebGLRenderTargetCube = function(e, t, n) {
                i.WebGLRenderTarget.call(this, e, t, n), this.activeCubeFace = 0
            }, i.WebGLRenderTargetCube.prototype = Object.create(i.WebGLRenderTarget.prototype), i.WebGLRenderTargetCube.prototype.constructor = i.WebGLRenderTargetCube, i.WebGLExtensions = function(e) {
                var t = {};
                this.get = function(n) {
                    if (void 0 !== t[n]) return t[n];
                    var r;
                    switch (n) {
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return null === r && i.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = r, r
                }
            }, i.WebGLProgram = function() {
                var e = 0,
                    t = function(e) {
                        var t, n, i = [];
                        for (var r in e) t = e[r], t !== !1 && (n = "#define " + r + " " + t, i.push(n));
                        return i.join("\n")
                    },
                    n = function(e, t, n) {
                        for (var i = {}, r = 0, o = n.length; o > r; r++) {
                            var a = n[r];
                            i[a] = e.getUniformLocation(t, a)
                        }
                        return i
                    },
                    r = function(e, t, n) {
                        for (var i = {}, r = 0, o = n.length; o > r; r++) {
                            var a = n[r];
                            i[a] = e.getAttribLocation(t, a)
                        }
                        return i
                    };
                return function(o, a, s, l) {
                    var c = o,
                        h = c.context,
                        u = s.defines,
                        f = s.__webglShader.uniforms,
                        d = s.attributes,
                        p = s.__webglShader.vertexShader,
                        m = s.__webglShader.fragmentShader,
                        v = s.index0AttributeName;
                    void 0 === v && l.morphTargets === !0 && (v = "position");
                    var g = "SHADOWMAP_TYPE_BASIC";
                    l.shadowMapType === i.PCFShadowMap ? g = "SHADOWMAP_TYPE_PCF" : l.shadowMapType === i.PCFSoftShadowMap && (g = "SHADOWMAP_TYPE_PCF_SOFT");
                    var y = "ENVMAP_TYPE_CUBE",
                        x = "ENVMAP_MODE_REFLECTION",
                        w = "ENVMAP_BLENDING_MULTIPLY";
                    if (l.envMap) {
                        switch (s.envMap.mapping) {
                            case i.CubeReflectionMapping:
                            case i.CubeRefractionMapping:
                                y = "ENVMAP_TYPE_CUBE";
                                break;
                            case i.EquirectangularReflectionMapping:
                            case i.EquirectangularRefractionMapping:
                                y = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case i.SphericalReflectionMapping:
                                y = "ENVMAP_TYPE_SPHERE"
                        }
                        switch (s.envMap.mapping) {
                            case i.CubeRefractionMapping:
                            case i.EquirectangularRefractionMapping:
                                x = "ENVMAP_MODE_REFRACTION"
                        }
                        switch (s.combine) {
                            case i.MultiplyOperation:
                                w = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case i.MixOperation:
                                w = "ENVMAP_BLENDING_MIX";
                                break;
                            case i.AddOperation:
                                w = "ENVMAP_BLENDING_ADD"
                        }
                    }
                    var _, b, E = o.gammaFactor > 0 ? o.gammaFactor : 1,
                        M = t(u),
                        S = h.createProgram();
                    s instanceof i.RawShaderMaterial ? (_ = "", b = "") : (_ = ["precision " + l.precision + " float;", "precision " + l.precision + " int;", M, l.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", c.gammaInput ? "#define GAMMA_INPUT" : "", c.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + E, "#define MAX_DIR_LIGHTS " + l.maxDirLights, "#define MAX_POINT_LIGHTS " + l.maxPointLights, "#define MAX_SPOT_LIGHTS " + l.maxSpotLights, "#define MAX_HEMI_LIGHTS " + l.maxHemiLights, "#define MAX_SHADOWS " + l.maxShadows, "#define MAX_BONES " + l.maxBones, l.map ? "#define USE_MAP" : "", l.envMap ? "#define USE_ENVMAP" : "", l.envMap ? "#define " + x : "", l.lightMap ? "#define USE_LIGHTMAP" : "", l.bumpMap ? "#define USE_BUMPMAP" : "", l.normalMap ? "#define USE_NORMALMAP" : "", l.specularMap ? "#define USE_SPECULARMAP" : "", l.alphaMap ? "#define USE_ALPHAMAP" : "", l.vertexColors ? "#define USE_COLOR" : "", l.flatShading ? "#define FLAT_SHADED" : "", l.skinning ? "#define USE_SKINNING" : "", l.useVertexTexture ? "#define BONE_TEXTURE" : "", l.morphTargets ? "#define USE_MORPHTARGETS" : "", l.morphNormals ? "#define USE_MORPHNORMALS" : "", l.wrapAround ? "#define WRAP_AROUND" : "", l.doubleSided ? "#define DOUBLE_SIDED" : "", l.flipSided ? "#define FLIP_SIDED" : "", l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", l.shadowMapEnabled ? "#define " + g : "", l.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", l.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", l.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", ""].join("\n"), b = [l.bumpMap || l.normalMap || l.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", "precision " + l.precision + " float;", "precision " + l.precision + " int;", M, "#define MAX_DIR_LIGHTS " + l.maxDirLights, "#define MAX_POINT_LIGHTS " + l.maxPointLights, "#define MAX_SPOT_LIGHTS " + l.maxSpotLights, "#define MAX_HEMI_LIGHTS " + l.maxHemiLights, "#define MAX_SHADOWS " + l.maxShadows, l.alphaTest ? "#define ALPHATEST " + l.alphaTest : "", c.gammaInput ? "#define GAMMA_INPUT" : "", c.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + E, l.useFog && l.fog ? "#define USE_FOG" : "", l.useFog && l.fogExp ? "#define FOG_EXP2" : "", l.map ? "#define USE_MAP" : "", l.envMap ? "#define USE_ENVMAP" : "", l.envMap ? "#define " + y : "", l.envMap ? "#define " + x : "", l.envMap ? "#define " + w : "", l.lightMap ? "#define USE_LIGHTMAP" : "", l.bumpMap ? "#define USE_BUMPMAP" : "", l.normalMap ? "#define USE_NORMALMAP" : "", l.specularMap ? "#define USE_SPECULARMAP" : "", l.alphaMap ? "#define USE_ALPHAMAP" : "", l.vertexColors ? "#define USE_COLOR" : "", l.flatShading ? "#define FLAT_SHADED" : "", l.metal ? "#define METAL" : "", l.wrapAround ? "#define WRAP_AROUND" : "", l.doubleSided ? "#define DOUBLE_SIDED" : "", l.flipSided ? "#define FLIP_SIDED" : "", l.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", l.shadowMapEnabled ? "#define " + g : "", l.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", l.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", l.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", ""].join("\n"));
                    var T = new i.WebGLShader(h, h.VERTEX_SHADER, _ + p),
                        C = new i.WebGLShader(h, h.FRAGMENT_SHADER, b + m);
                    h.attachShader(S, T), h.attachShader(S, C), void 0 !== v && h.bindAttribLocation(S, 0, v), h.linkProgram(S);
                    var A = h.getProgramInfoLog(S);
                    h.getProgramParameter(S, h.LINK_STATUS) === !1 && i.error("THREE.WebGLProgram: shader error: " + h.getError(), "gl.VALIDATE_STATUS", h.getProgramParameter(S, h.VALIDATE_STATUS), "gl.getPRogramInfoLog", A), "" !== A && i.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + A), h.deleteShader(T), h.deleteShader(C);
                    var P = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences", "bindMatrix", "bindMatrixInverse"];
                    l.useVertexTexture ? (P.push("boneTexture"), P.push("boneTextureWidth"), P.push("boneTextureHeight")) : P.push("boneGlobalMatrices"), l.logarithmicDepthBuffer && P.push("logDepthBufFC");
                    for (var D in f) P.push(D);
                    this.uniforms = n(h, S, P), P = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"];
                    for (var L = 0; L < l.maxMorphTargets; L++) P.push("morphTarget" + L);
                    for (var L = 0; L < l.maxMorphNormals; L++) P.push("morphNormal" + L);
                    for (var R in d) P.push(R);
                    return this.attributes = r(h, S, P), this.attributesKeys = Object.keys(this.attributes), this.id = e++, this.code = a, this.usedTimes = 1, this.program = S, this.vertexShader = T, this.fragmentShader = C, this
                }
            }(), i.WebGLShader = function() {
                var e = function(e) {
                    for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                    return t.join("\n")
                };
                return function(t, n, r) {
                    var o = t.createShader(n);
                    return t.shaderSource(o, r), t.compileShader(o), t.getShaderParameter(o, t.COMPILE_STATUS) === !1 && i.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(o) && i.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t.getShaderInfoLog(o), e(r)), o
                }
            }(), i.WebGLState = function(e, t) {
                var n = new Uint8Array(16),
                    r = new Uint8Array(16),
                    o = null,
                    a = null,
                    s = null,
                    l = null,
                    c = null,
                    h = null,
                    u = null,
                    f = null,
                    d = null,
                    p = null,
                    m = null,
                    v = null,
                    g = null,
                    y = null,
                    x = null,
                    w = null;
                this.initAttributes = function() {
                    for (var e = 0, t = n.length; t > e; e++) n[e] = 0
                }, this.enableAttribute = function(t) {
                    n[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1)
                }, this.disableUnusedAttributes = function() {
                    for (var t = 0, i = r.length; i > t; t++) r[t] !== n[t] && (e.disableVertexAttribArray(t), r[t] = 0)
                }, this.setBlending = function(n, r, f, d, p, m, v) {
                    n !== o && (n === i.NoBlending ? e.disable(e.BLEND) : n === i.AdditiveBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : n === i.SubtractiveBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : n === i.MultiplyBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : n === i.CustomBlending ? e.enable(e.BLEND) : (e.enable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)), o = n), n === i.CustomBlending ? (p = p || r, m = m || f, v = v || d, r === a && p === c || (e.blendEquationSeparate(t(r), t(p)), a = r, c = p), f === s && d === l && m === h && v === u || (e.blendFuncSeparate(t(f), t(d), t(m), t(v)), s = f, l = d, h = m, u = v)) : (a = null, s = null, l = null, c = null, h = null, u = null)
                }, this.setDepthTest = function(t) {
                    f !== t && (t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), f = t)
                }, this.setDepthWrite = function(t) {
                    d !== t && (e.depthMask(t), d = t)
                }, this.setColorWrite = function(t) {
                    p !== t && (e.colorMask(t, t, t, t), p = t)
                }, this.setDoubleSided = function(t) {
                    m !== t && (t ? e.disable(e.CULL_FACE) : e.enable(e.CULL_FACE), m = t)
                }, this.setFlipSided = function(t) {
                    v !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), v = t)
                }, this.setLineWidth = function(t) {
                    t !== g && (e.lineWidth(t), g = t)
                }, this.setPolygonOffset = function(t, n, i) {
                    y !== t && (t ? e.enable(e.POLYGON_OFFSET_FILL) : e.disable(e.POLYGON_OFFSET_FILL), y = t), !t || x === n && w === i || (e.polygonOffset(n, i), x = n, w = i)
                }, this.reset = function() {
                    for (var e = 0; e < r.length; e++) r[e] = 0;
                    o = null, f = null, d = null, p = null, m = null, v = null
                }
            }, i.LensFlarePlugin = function(e, t) {
                function n(t) {
                    var n = f.createProgram(),
                        i = f.createShader(f.FRAGMENT_SHADER),
                        r = f.createShader(f.VERTEX_SHADER),
                        o = "precision " + e.getPrecision() + " float;\n";
                    return f.shaderSource(i, o + t.fragmentShader), f.shaderSource(r, o + t.vertexShader), f.compileShader(i), f.compileShader(r), f.attachShader(n, i), f.attachShader(n, r), f.linkProgram(n), n
                }
                var r, o, a, s, l, c, h, u, f = e.context,
                    d = function() {
                        var e = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                            t = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        r = f.createBuffer(), o = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, r), f.bufferData(f.ARRAY_BUFFER, e, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, o), f.bufferData(f.ELEMENT_ARRAY_BUFFER, t, f.STATIC_DRAW), h = f.createTexture(), u = f.createTexture(), f.bindTexture(f.TEXTURE_2D, h), f.texImage2D(f.TEXTURE_2D, 0, f.RGB, 16, 16, 0, f.RGB, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), f.bindTexture(f.TEXTURE_2D, u), f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, 16, 16, 0, f.RGBA, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), c = f.getParameter(f.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
                        var i;
                        i = c ? {
                            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                        } : {
                            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                        }, a = n(i), s = {
                            vertex: f.getAttribLocation(a, "position"),
                            uv: f.getAttribLocation(a, "uv")
                        }, l = {
                            renderType: f.getUniformLocation(a, "renderType"),
                            map: f.getUniformLocation(a, "map"),
                            occlusionMap: f.getUniformLocation(a, "occlusionMap"),
                            opacity: f.getUniformLocation(a, "opacity"),
                            color: f.getUniformLocation(a, "color"),
                            scale: f.getUniformLocation(a, "scale"),
                            rotation: f.getUniformLocation(a, "rotation"),
                            screenPosition: f.getUniformLocation(a, "screenPosition")
                        }
                    };
                this.render = function(n, p, m, v) {
                    if (0 !== t.length) {
                        var g = new i.Vector3,
                            y = v / m,
                            x = .5 * m,
                            w = .5 * v,
                            _ = 16 / v,
                            b = new i.Vector2(_ * y, _),
                            E = new i.Vector3(1, 1, 0),
                            M = new i.Vector2(1, 1);
                        void 0 === a && d(), f.useProgram(a), f.enableVertexAttribArray(s.vertex), f.enableVertexAttribArray(s.uv), f.uniform1i(l.occlusionMap, 0), f.uniform1i(l.map, 1), f.bindBuffer(f.ARRAY_BUFFER, r), f.vertexAttribPointer(s.vertex, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(s.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, o), f.disable(f.CULL_FACE), f.depthMask(!1);
                        for (var S = 0, T = t.length; T > S; S++) {
                            _ = 16 / v, b.set(_ * y, _);
                            var C = t[S];
                            if (g.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]), g.applyMatrix4(p.matrixWorldInverse), g.applyProjection(p.projectionMatrix), E.copy(g), M.x = E.x * x + x, M.y = E.y * w + w, c || M.x > 0 && M.x < m && M.y > 0 && M.y < v) {
                                f.activeTexture(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, h), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGB, M.x - 8, M.y - 8, 16, 16, 0), f.uniform1i(l.renderType, 0), f.uniform2f(l.scale, b.x, b.y), f.uniform3f(l.screenPosition, E.x, E.y, E.z), f.disable(f.BLEND), f.enable(f.DEPTH_TEST), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), f.activeTexture(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, u), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGBA, M.x - 8, M.y - 8, 16, 16, 0), f.uniform1i(l.renderType, 1), f.disable(f.DEPTH_TEST), f.activeTexture(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, h), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), C.positionScreen.copy(E), C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(), f.uniform1i(l.renderType, 2), f.enable(f.BLEND);
                                for (var A = 0, P = C.lensFlares.length; P > A; A++) {
                                    var D = C.lensFlares[A];
                                    D.opacity > .001 && D.scale > .001 && (E.x = D.x, E.y = D.y, E.z = D.z, _ = D.size * D.scale / v, b.x = _ * y, b.y = _, f.uniform3f(l.screenPosition, E.x, E.y, E.z), f.uniform2f(l.scale, b.x, b.y), f.uniform1f(l.rotation, D.rotation), f.uniform1f(l.opacity, D.opacity), f.uniform3f(l.color, D.color.r, D.color.g, D.color.b), e.state.setBlending(D.blending, D.blendEquation, D.blendSrc, D.blendDst), e.setTexture(D.texture, 1), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0))
                                }
                            }
                        }
                        f.enable(f.CULL_FACE), f.enable(f.DEPTH_TEST), f.depthMask(!0), e.resetGLState()
                    }
                }
            }, i.ShadowMapPlugin = function(e, t, n, r) {
                function o(e, t, i) {
                    if (t.visible) {
                        var r = n[t.id];
                        if (r && t.castShadow && (t.frustumCulled === !1 || m.intersectsObject(t) === !0))
                            for (var a = 0, s = r.length; s > a; a++) {
                                var l = r[a];
                                t._modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), w.push(l)
                            }
                        for (var a = 0, s = t.children.length; s > a; a++) o(e, t.children[a], i)
                    }
                }

                function a(e, t) {
                    var n = new i.DirectionalLight;
                    n.isVirtual = !0, n.onlyShadow = !0, n.castShadow = !0, n.shadowCameraNear = e.shadowCameraNear, n.shadowCameraFar = e.shadowCameraFar, n.shadowCameraLeft = e.shadowCameraLeft, n.shadowCameraRight = e.shadowCameraRight, n.shadowCameraBottom = e.shadowCameraBottom, n.shadowCameraTop = e.shadowCameraTop, n.shadowCameraVisible = e.shadowCameraVisible, n.shadowDarkness = e.shadowDarkness, n.shadowBias = e.shadowCascadeBias[t], n.shadowMapWidth = e.shadowCascadeWidth[t], n.shadowMapHeight = e.shadowCascadeHeight[t], n.pointsWorld = [], n.pointsFrustum = [];
                    for (var r = n.pointsWorld, o = n.pointsFrustum, a = 0; 8 > a; a++) r[a] = new i.Vector3, o[a] = new i.Vector3;
                    var s = e.shadowCascadeNearZ[t],
                        l = e.shadowCascadeFarZ[t];
                    return o[0].set(-1, -1, s), o[1].set(1, -1, s), o[2].set(-1, 1, s), o[3].set(1, 1, s), o[4].set(-1, -1, l), o[5].set(1, -1, l), o[6].set(-1, 1, l), o[7].set(1, 1, l), n
                }

                function s(e, t) {
                    var n = e.shadowCascadeArray[t];
                    n.position.copy(e.position), n.target.position.copy(e.target.position), n.lookAt(n.target), n.shadowCameraVisible = e.shadowCameraVisible, n.shadowDarkness = e.shadowDarkness, n.shadowBias = e.shadowCascadeBias[t];
                    var i = e.shadowCascadeNearZ[t],
                        r = e.shadowCascadeFarZ[t],
                        o = n.pointsFrustum;
                    o[0].z = i, o[1].z = i, o[2].z = i, o[3].z = i, o[4].z = r, o[5].z = r, o[6].z = r, o[7].z = r
                }

                function l(e, t) {
                    var n = t.shadowCamera,
                        i = t.pointsFrustum,
                        r = t.pointsWorld;
                    g.set(1 / 0, 1 / 0, 1 / 0), y.set(-(1 / 0), -(1 / 0), -(1 / 0));
                    for (var o = 0; 8 > o; o++) {
                        var a = r[o];
                        a.copy(i[o]), a.unproject(e), a.applyMatrix4(n.matrixWorldInverse), a.x < g.x && (g.x = a.x), a.x > y.x && (y.x = a.x), a.y < g.y && (g.y = a.y), a.y > y.y && (y.y = a.y), a.z < g.z && (g.z = a.z), a.z > y.z && (y.z = a.z)
                    }
                    n.left = g.x, n.right = y.x, n.top = y.y, n.bottom = g.y, n.updateProjectionMatrix()
                }

                function c(e) {
                    return e.material instanceof i.MeshFaceMaterial ? e.material.materials[0] : e.material
                }
                var h, u, f, d, p = e.context,
                    m = new i.Frustum,
                    v = new i.Matrix4,
                    g = new i.Vector3,
                    y = new i.Vector3,
                    x = new i.Vector3,
                    w = [],
                    _ = i.ShaderLib.depthRGBA,
                    b = i.UniformsUtils.clone(_.uniforms);
                h = new i.ShaderMaterial({
                    uniforms: b,
                    vertexShader: _.vertexShader,
                    fragmentShader: _.fragmentShader
                }), u = new i.ShaderMaterial({
                    uniforms: b,
                    vertexShader: _.vertexShader,
                    fragmentShader: _.fragmentShader,
                    morphTargets: !0
                }), f = new i.ShaderMaterial({
                    uniforms: b,
                    vertexShader: _.vertexShader,
                    fragmentShader: _.fragmentShader,
                    skinning: !0
                }), d = new i.ShaderMaterial({
                    uniforms: b,
                    vertexShader: _.vertexShader,
                    fragmentShader: _.fragmentShader,
                    morphTargets: !0,
                    skinning: !0
                }), h._shadowPass = !0, u._shadowPass = !0, f._shadowPass = !0, d._shadowPass = !0, this.render = function(n, g) {
                    if (e.shadowMapEnabled !== !1) {
                        var y, _, b, E, M, S, T, C, A, P, D, L, R, O = [],
                            N = 0,
                            U = null;
                        for (p.clearColor(1, 1, 1, 1), p.disable(p.BLEND), p.enable(p.CULL_FACE), p.frontFace(p.CCW), e.shadowMapCullFace === i.CullFaceFront ? p.cullFace(p.FRONT) : p.cullFace(p.BACK), e.state.setDepthTest(!0), y = 0, _ = t.length; _ > y; y++)
                            if (R = t[y], R.castShadow)
                                if (R instanceof i.DirectionalLight && R.shadowCascade)
                                    for (M = 0; M < R.shadowCascadeCount; M++) {
                                        var F;
                                        if (R.shadowCascadeArray[M]) F = R.shadowCascadeArray[M];
                                        else {
                                            F = a(R, M), F.originalCamera = g;
                                            var k = new i.Gyroscope;
                                            k.position.copy(R.shadowCascadeOffset), k.add(F), k.add(F.target), g.add(k), R.shadowCascadeArray[M] = F
                                        }
                                        s(R, M), O[N] = F, N++
                                    } else O[N] = R, N++;
                        for (y = 0, _ = O.length; _ > y; y++) {
                            if (R = O[y], !R.shadowMap) {
                                var H = i.LinearFilter;
                                e.shadowMapType === i.PCFSoftShadowMap && (H = i.NearestFilter);
                                var I = {
                                    minFilter: H,
                                    magFilter: H,
                                    format: i.RGBAFormat
                                };
                                R.shadowMap = new i.WebGLRenderTarget(R.shadowMapWidth, R.shadowMapHeight, I), R.shadowMapSize = new i.Vector2(R.shadowMapWidth, R.shadowMapHeight), R.shadowMatrix = new i.Matrix4
                            }
                            if (!R.shadowCamera) {
                                if (R instanceof i.SpotLight) R.shadowCamera = new i.PerspectiveCamera(R.shadowCameraFov, R.shadowMapWidth / R.shadowMapHeight, R.shadowCameraNear, R.shadowCameraFar);
                                else {
                                    if (!(R instanceof i.DirectionalLight)) {
                                        i.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", R);
                                        continue
                                    }
                                    R.shadowCamera = new i.OrthographicCamera(R.shadowCameraLeft, R.shadowCameraRight, R.shadowCameraTop, R.shadowCameraBottom, R.shadowCameraNear, R.shadowCameraFar)
                                }
                                n.add(R.shadowCamera), n.autoUpdate === !0 && n.updateMatrixWorld()
                            }
                            R.shadowCameraVisible && !R.cameraHelper && (R.cameraHelper = new i.CameraHelper(R.shadowCamera), n.add(R.cameraHelper)), R.isVirtual && F.originalCamera == g && l(g, R), S = R.shadowMap, T = R.shadowMatrix, C = R.shadowCamera, C.position.setFromMatrixPosition(R.matrixWorld), x.setFromMatrixPosition(R.target.matrixWorld), C.lookAt(x), C.updateMatrixWorld(), C.matrixWorldInverse.getInverse(C.matrixWorld), R.cameraHelper && (R.cameraHelper.visible = R.shadowCameraVisible), R.shadowCameraVisible && R.cameraHelper.update(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                T.multiply(C.projectionMatrix), T.multiply(C.matrixWorldInverse), v.multiplyMatrices(C.projectionMatrix, C.matrixWorldInverse), m.setFromMatrix(v), e.setRenderTarget(S), e.clear(), w.length = 0, o(n, n, C);
                            var V, z, B;
                            for (b = 0, E = w.length; E > b; b++) D = w[b], L = D.object, A = D.buffer, V = c(L), z = void 0 !== L.geometry.morphTargets && L.geometry.morphTargets.length > 0 && V.morphTargets, B = L instanceof i.SkinnedMesh && V.skinning, P = L.customDepthMaterial ? L.customDepthMaterial : B ? z ? d : f : z ? u : h, e.setMaterialFaces(V), A instanceof i.BufferGeometry ? e.renderBufferDirect(C, t, U, P, A, L) : e.renderBuffer(C, t, U, P, A, L);
                            for (b = 0, E = r.length; E > b; b++) D = r[b], L = D.object, L.visible && L.castShadow && (L._modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, L.matrixWorld), e.renderImmediateObject(C, t, U, h, L))
                        }
                        var j = e.getClearColor(),
                            G = e.getClearAlpha();
                        p.clearColor(j.r, j.g, j.b, G), p.enable(p.BLEND), e.shadowMapCullFace === i.CullFaceFront && p.cullFace(p.BACK), e.resetGLState()
                    }
                }
            }, i.SpritePlugin = function(e, t) {
                function n() {
                    var t = u.createProgram(),
                        n = u.createShader(u.VERTEX_SHADER),
                        i = u.createShader(u.FRAGMENT_SHADER);
                    return u.shaderSource(n, ["precision " + e.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), u.shaderSource(i, ["precision " + e.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), u.compileShader(n), u.compileShader(i), u.attachShader(t, n), u.attachShader(t, i), u.linkProgram(t), t
                }

                function r(e, t) {
                    return e.z !== t.z ? t.z - e.z : t.id - e.id
                }
                var o, a, s, l, c, h, u = e.context,
                    f = new i.Vector3,
                    d = new i.Quaternion,
                    p = new i.Vector3,
                    m = function() {
                        var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                            t = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        o = u.createBuffer(), a = u.createBuffer(), u.bindBuffer(u.ARRAY_BUFFER, o), u.bufferData(u.ARRAY_BUFFER, e, u.STATIC_DRAW), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, a), u.bufferData(u.ELEMENT_ARRAY_BUFFER, t, u.STATIC_DRAW), s = n(), l = {
                            position: u.getAttribLocation(s, "position"),
                            uv: u.getAttribLocation(s, "uv")
                        }, c = {
                            uvOffset: u.getUniformLocation(s, "uvOffset"),
                            uvScale: u.getUniformLocation(s, "uvScale"),
                            rotation: u.getUniformLocation(s, "rotation"),
                            scale: u.getUniformLocation(s, "scale"),
                            color: u.getUniformLocation(s, "color"),
                            map: u.getUniformLocation(s, "map"),
                            opacity: u.getUniformLocation(s, "opacity"),
                            modelViewMatrix: u.getUniformLocation(s, "modelViewMatrix"),
                            projectionMatrix: u.getUniformLocation(s, "projectionMatrix"),
                            fogType: u.getUniformLocation(s, "fogType"),
                            fogDensity: u.getUniformLocation(s, "fogDensity"),
                            fogNear: u.getUniformLocation(s, "fogNear"),
                            fogFar: u.getUniformLocation(s, "fogFar"),
                            fogColor: u.getUniformLocation(s, "fogColor"),
                            alphaTest: u.getUniformLocation(s, "alphaTest")
                        };
                        var r = document.createElement("canvas");
                        r.width = 8, r.height = 8;
                        var f = r.getContext("2d");
                        f.fillStyle = "white", f.fillRect(0, 0, 8, 8), h = new i.Texture(r), h.needsUpdate = !0
                    };
                this.render = function(n, v) {
                    if (0 !== t.length) {
                        void 0 === s && m(), u.useProgram(s), u.enableVertexAttribArray(l.position), u.enableVertexAttribArray(l.uv), u.disable(u.CULL_FACE), u.enable(u.BLEND), u.bindBuffer(u.ARRAY_BUFFER, o), u.vertexAttribPointer(l.position, 2, u.FLOAT, !1, 16, 0), u.vertexAttribPointer(l.uv, 2, u.FLOAT, !1, 16, 8), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, a), u.uniformMatrix4fv(c.projectionMatrix, !1, v.projectionMatrix.elements), u.activeTexture(u.TEXTURE0), u.uniform1i(c.map, 0);
                        var g = 0,
                            y = 0,
                            x = n.fog;
                        x ? (u.uniform3f(c.fogColor, x.color.r, x.color.g, x.color.b), x instanceof i.Fog ? (u.uniform1f(c.fogNear, x.near), u.uniform1f(c.fogFar, x.far), u.uniform1i(c.fogType, 1), g = 1, y = 1) : x instanceof i.FogExp2 && (u.uniform1f(c.fogDensity, x.density), u.uniform1i(c.fogType, 2), g = 2, y = 2)) : (u.uniform1i(c.fogType, 0), g = 0, y = 0);
                        for (var w = 0, _ = t.length; _ > w; w++) {
                            var b = t[w];
                            b._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, b.matrixWorld), b.z = -b._modelViewMatrix.elements[14]
                        }
                        t.sort(r);
                        for (var E = [], w = 0, _ = t.length; _ > w; w++) {
                            var b = t[w],
                                M = b.material;
                            u.uniform1f(c.alphaTest, M.alphaTest), u.uniformMatrix4fv(c.modelViewMatrix, !1, b._modelViewMatrix.elements), b.matrixWorld.decompose(f, d, p), E[0] = p.x, E[1] = p.y;
                            var S = 0;
                            n.fog && M.fog && (S = y), g !== S && (u.uniform1i(c.fogType, S), g = S), null !== M.map ? (u.uniform2f(c.uvOffset, M.map.offset.x, M.map.offset.y), u.uniform2f(c.uvScale, M.map.repeat.x, M.map.repeat.y)) : (u.uniform2f(c.uvOffset, 0, 0), u.uniform2f(c.uvScale, 1, 1)), u.uniform1f(c.opacity, M.opacity), u.uniform3f(c.color, M.color.r, M.color.g, M.color.b), u.uniform1f(c.rotation, M.rotation), u.uniform2fv(c.scale, E), e.state.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), e.state.setDepthTest(M.depthTest), e.state.setDepthWrite(M.depthWrite), M.map && M.map.image && M.map.image.width ? e.setTexture(M.map, 0) : e.setTexture(h, 0), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0)
                        }
                        u.enable(u.CULL_FACE), e.resetGLState()
                    }
                }
            }, i.GeometryUtils = {
                merge: function(e, t, n) {
                    i.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var r;
                    t instanceof i.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
                },
                center: function(e) {
                    return i.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            }, i.ImageUtils = {
                crossOrigin: void 0,
                loadTexture: function(e, t, n, r) {
                    var o = new i.ImageLoader;
                    o.crossOrigin = this.crossOrigin;
                    var a = new i.Texture(void 0, t);
                    return o.load(e, function(e) {
                        a.image = e, a.needsUpdate = !0, n && n(a)
                    }, void 0, function(e) {
                        r && r(e)
                    }), a.sourceFile = e, a
                },
                loadTextureCube: function(e, t, n, r) {
                    var o = [],
                        a = new i.ImageLoader;
                    a.crossOrigin = this.crossOrigin;
                    var s = new i.CubeTexture(o, t);
                    s.flipY = !1;
                    for (var l = 0, c = function(t) {
                        a.load(e[t], function(e) {
                            s.images[t] = e, l += 1, 6 === l && (s.needsUpdate = !0, n && n(s))
                        }, void 0, r)
                    }, h = 0, u = e.length; u > h; ++h) c(h);
                    return s
                },
                loadCompressedTexture: function() {
                    i.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    i.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                },
                getNormalMap: function(e, t) {
                    var n = function(e, t) {
                            return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
                        },
                        i = function(e, t) {
                            return [e[0] - t[0], e[1] - t[1], e[2] - t[2]]
                        },
                        r = function(e) {
                            var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
                            return [e[0] / t, e[1] / t, e[2] / t]
                        };
                    t = 1 | t;
                    var o = e.width,
                        a = e.height,
                        s = document.createElement("canvas");
                    s.width = o, s.height = a;
                    var l = s.getContext("2d");
                    l.drawImage(e, 0, 0);
                    for (var c = l.getImageData(0, 0, o, a).data, h = l.createImageData(o, a), u = h.data, f = 0; o > f; f++)
                        for (var d = 0; a > d; d++) {
                            var p = 0 > d - 1 ? 0 : d - 1,
                                m = d + 1 > a - 1 ? a - 1 : d + 1,
                                v = 0 > f - 1 ? 0 : f - 1,
                                g = f + 1 > o - 1 ? o - 1 : f + 1,
                                y = [],
                                x = [0, 0, c[4 * (d * o + f)] / 255 * t];
                            y.push([-1, 0, c[4 * (d * o + v)] / 255 * t]), y.push([-1, -1, c[4 * (p * o + v)] / 255 * t]), y.push([0, -1, c[4 * (p * o + f)] / 255 * t]), y.push([1, -1, c[4 * (p * o + g)] / 255 * t]), y.push([1, 0, c[4 * (d * o + g)] / 255 * t]), y.push([1, 1, c[4 * (m * o + g)] / 255 * t]), y.push([0, 1, c[4 * (m * o + f)] / 255 * t]), y.push([-1, 1, c[4 * (m * o + v)] / 255 * t]);
                            for (var w = [], _ = y.length, b = 0; _ > b; b++) {
                                var E = y[b],
                                    M = y[(b + 1) % _];
                                E = i(E, x), M = i(M, x), w.push(r(n(E, M)))
                            }
                            for (var S = [0, 0, 0], b = 0; b < w.length; b++) S[0] += w[b][0], S[1] += w[b][1], S[2] += w[b][2];
                            S[0] /= w.length, S[1] /= w.length, S[2] /= w.length;
                            var T = 4 * (d * o + f);
                            u[T] = (S[0] + 1) / 2 * 255 | 0, u[T + 1] = (S[1] + 1) / 2 * 255 | 0, u[T + 2] = 255 * S[2] | 0, u[T + 3] = 255
                        }
                    return l.putImageData(h, 0, 0), s
                },
                generateDataTexture: function(e, t, n) {
                    for (var r = e * t, o = new Uint8Array(3 * r), a = Math.floor(255 * n.r), s = Math.floor(255 * n.g), l = Math.floor(255 * n.b), c = 0; r > c; c++) o[3 * c] = a, o[3 * c + 1] = s, o[3 * c + 2] = l;
                    var h = new i.DataTexture(o, e, t, i.RGBFormat);
                    return h.needsUpdate = !0, h
                }
            }, i.SceneUtils = {
                createMultiMaterialObject: function(e, t) {
                    for (var n = new i.Object3D, r = 0, o = t.length; o > r; r++) n.add(new i.Mesh(e, t[r]));
                    return n
                },
                detach: function(e, t, n) {
                    e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
                },
                attach: function(e, t, n) {
                    var r = new i.Matrix4;
                    r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e)
                }
            }, i.FontUtils = {
                faces: {},
                face: "helvetiker",
                weight: "normal",
                style: "normal",
                size: 150,
                divisions: 10,
                getFace: function() {
                    try {
                        return this.faces[this.face][this.weight][this.style]
                    } catch (e) {
                        throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
                    }
                },
                loadFace: function(e) {
                    var t = e.familyName.toLowerCase(),
                        n = this;
                    return n.faces[t] = n.faces[t] || {}, n.faces[t][e.cssFontWeight] = n.faces[t][e.cssFontWeight] || {}, n.faces[t][e.cssFontWeight][e.cssFontStyle] = e, n.faces[t][e.cssFontWeight][e.cssFontStyle] = e, e
                },
                drawText: function(e) {
                    var t, n = this.getFace(),
                        r = this.size / n.resolution,
                        o = 0,
                        a = String(e).split(""),
                        s = a.length,
                        l = [];
                    for (t = 0; s > t; t++) {
                        var c = new i.Path,
                            h = this.extractGlyphPoints(a[t], n, r, o, c);
                        o += h.offset, l.push(h.path)
                    }
                    var u = o / 2;
                    return {
                        paths: l,
                        offset: u
                    }
                },
                extractGlyphPoints: function(e, t, n, r, o) {
                    var a, s, l, c, h, u, f, d, p, m, v, g, y, x, w, _, b, E, M, S = [],
                        T = t.glyphs[e] || t.glyphs["?"];
                    if (T) {
                        if (T.o)
                            for (c = T._cachedOutline || (T._cachedOutline = T.o.split(" ")), u = c.length, f = n, d = n, a = 0; u > a;) switch (h = c[a++]) {
                                case "m":
                                    p = c[a++] * f + r, m = c[a++] * d, o.moveTo(p, m);
                                    break;
                                case "l":
                                    p = c[a++] * f + r, m = c[a++] * d, o.lineTo(p, m);
                                    break;
                                case "q":
                                    if (v = c[a++] * f + r, g = c[a++] * d, w = c[a++] * f + r, _ = c[a++] * d, o.quadraticCurveTo(w, _, v, g), M = S[S.length - 1])
                                        for (y = M.x, x = M.y, s = 1, l = this.divisions; l >= s; s++) {
                                            var C = s / l;
                                            i.Shape.Utils.b2(C, y, w, v), i.Shape.Utils.b2(C, x, _, g)
                                        }
                                    break;
                                case "b":
                                    if (v = c[a++] * f + r, g = c[a++] * d, w = c[a++] * f + r, _ = c[a++] * d, b = c[a++] * f + r, E = c[a++] * d, o.bezierCurveTo(w, _, b, E, v, g), M = S[S.length - 1])
                                        for (y = M.x, x = M.y, s = 1, l = this.divisions; l >= s; s++) {
                                            var C = s / l;
                                            i.Shape.Utils.b3(C, y, w, b, v), i.Shape.Utils.b3(C, x, _, E, g)
                                        }
                            }
                        return {
                            offset: T.ha * n,
                            path: o
                        }
                    }
                }
            }, i.FontUtils.generateShapes = function(e, t) {
                t = t || {};
                var n = void 0 !== t.size ? t.size : 100,
                    r = void 0 !== t.curveSegments ? t.curveSegments : 4,
                    o = void 0 !== t.font ? t.font : "helvetiker",
                    a = void 0 !== t.weight ? t.weight : "normal",
                    s = void 0 !== t.style ? t.style : "normal";
                i.FontUtils.size = n, i.FontUtils.divisions = r, i.FontUtils.face = o, i.FontUtils.weight = a, i.FontUtils.style = s;
                for (var l = i.FontUtils.drawText(e), c = l.paths, h = [], u = 0, f = c.length; f > u; u++) Array.prototype.push.apply(h, c[u].toShapes());
                return h
            },
            function(e) {
                var t = 1e-10,
                    n = function(e, t) {
                        var n = e.length;
                        if (3 > n) return null;
                        var a, s, l, c = [],
                            h = [],
                            u = [];
                        if (r(e) > 0)
                            for (s = 0; n > s; s++) h[s] = s;
                        else
                            for (s = 0; n > s; s++) h[s] = n - 1 - s;
                        var f = n,
                            d = 2 * f;
                        for (s = f - 1; f > 2;) {
                            if (d-- <= 0) return i.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()"), t ? u : c;
                            if (a = s, a >= f && (a = 0), s = a + 1, s >= f && (s = 0), l = s + 1, l >= f && (l = 0), o(e, a, s, l, f, h)) {
                                var p, m, v, g, y;
                                for (p = h[a], m = h[s], v = h[l], c.push([e[p], e[m], e[v]]), u.push([h[a], h[s], h[l]]), g = s, y = s + 1; f > y; g++, y++) h[g] = h[y];
                                f--, d = 2 * f
                            }
                        }
                        return t ? u : c
                    },
                    r = function(e) {
                        for (var t = e.length, n = 0, i = t - 1, r = 0; t > r; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                        return .5 * n
                    },
                    o = function(e, n, i, r, o, a) {
                        var s, l, c, h, u, f, d, p, m;
                        if (l = e[a[n]].x, c = e[a[n]].y, h = e[a[i]].x, u = e[a[i]].y, f = e[a[r]].x, d = e[a[r]].y, t > (h - l) * (d - c) - (u - c) * (f - l)) return !1;
                        var v, g, y, x, w, _, b, E, M, S, T, C, A, P, D;
                        for (v = f - h, g = d - u, y = l - f, x = c - d, w = h - l, _ = u - c, s = 0; o > s; s++)
                            if (p = e[a[s]].x, m = e[a[s]].y, !(p === l && m === c || p === h && m === u || p === f && m === d) && (b = p - l, E = m - c, M = p - h, S = m - u, T = p - f, C = m - d, D = v * S - g * M, A = w * E - _ * b, P = y * C - x * T, D >= -t && P >= -t && A >= -t)) return !1;
                        return !0
                    };
                return e.Triangulate = n, e.Triangulate.area = r, e
            }(i.FontUtils), self._typeface_js = {
                faces: i.FontUtils.faces,
                loadFace: i.FontUtils.loadFace
            }, i.typeface_js = self._typeface_js, i.Audio = function(e) {
                i.Object3D.call(this), this.type = "Audio", this.context = e.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.panner = this.context.createPanner(), this.panner.connect(this.gain), this.autoplay = !1, this.startTime = 0, this.isPlaying = !1
            }, i.Audio.prototype = Object.create(i.Object3D.prototype), i.Audio.prototype.constructor = i.Audio, i.Audio.prototype.load = function(e) {
                var t = this,
                    n = new XMLHttpRequest;
                return n.open("GET", e, !0), n.responseType = "arraybuffer", n.onload = function(e) {
                    t.context.decodeAudioData(this.response, function(e) {
                        t.source.buffer = e, t.autoplay && t.play()
                    })
                }, n.send(), this
            }, i.Audio.prototype.play = function() {
                if (this.isPlaying === !0) return void i.warn("THREE.Audio: Audio is already playing.");
                var e = this.context.createBufferSource();
                e.buffer = this.source.buffer, e.loop = this.source.loop, e.onended = this.source.onended, e.connect(this.panner), e.start(0, this.startTime), this.isPlaying = !0, this.source = e
            }, i.Audio.prototype.pause = function() {
                this.source.stop(), this.startTime = this.context.currentTime
            }, i.Audio.prototype.stop = function() {
                this.source.stop(), this.startTime = 0
            }, i.Audio.prototype.onEnded = function() {
                this.isPlaying = !1
            }, i.Audio.prototype.setLoop = function(e) {
                this.source.loop = e
            }, i.Audio.prototype.setRefDistance = function(e) {
                this.panner.refDistance = e
            }, i.Audio.prototype.setRolloffFactor = function(e) {
                this.panner.rolloffFactor = e
            }, i.Audio.prototype.setVolume = function(e) {
                this.gain.gain.value = e
            }, i.Audio.prototype.updateMatrixWorld = function() {
                var e = new i.Vector3;
                return function(t) {
                    i.Object3D.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
                }
            }(), i.AudioListener = function() {
                i.Object3D.call(this), this.type = "AudioListener", this.context = new(window.AudioContext || window.webkitAudioContext)
            }, i.AudioListener.prototype = Object.create(i.Object3D.prototype), i.AudioListener.prototype.constructor = i.AudioListener, i.AudioListener.prototype.updateMatrixWorld = function() {
                var e = new i.Vector3,
                    t = new i.Quaternion,
                    n = new i.Vector3,
                    r = new i.Vector3,
                    o = new i.Vector3,
                    a = new i.Vector3;
                return function(s) {
                    i.Object3D.prototype.updateMatrixWorld.call(this, s);
                    var l = this.context.listener,
                        c = this.up;
                    this.matrixWorld.decompose(e, t, n), r.set(0, 0, -1).applyQuaternion(t), o.subVectors(e, a), l.setPosition(e.x, e.y, e.z), l.setOrientation(r.x, r.y, r.z, c.x, c.y, c.z), l.setVelocity(o.x, o.y, o.z), a.copy(e)
                }
            }(), i.Curve = function() {}, i.Curve.prototype.getPoint = function(e) {
                return i.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
            }, i.Curve.prototype.getPointAt = function(e) {
                var t = this.getUtoTmapping(e);
                return this.getPoint(t)
            }, i.Curve.prototype.getPoints = function(e) {
                e || (e = 5);
                var t, n = [];
                for (t = 0; e >= t; t++) n.push(this.getPoint(t / e));
                return n
            }, i.Curve.prototype.getSpacedPoints = function(e) {
                e || (e = 5);
                var t, n = [];
                for (t = 0; e >= t; t++) n.push(this.getPointAt(t / e));
                return n
            }, i.Curve.prototype.getLength = function() {
                var e = this.getLengths();
                return e[e.length - 1]
            }, i.Curve.prototype.getLengths = function(e) {
                if (e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var t, n, i = [],
                    r = this.getPoint(0),
                    o = 0;
                for (i.push(0), n = 1; e >= n; n++) t = this.getPoint(n / e), o += t.distanceTo(r), i.push(o), r = t;
                return this.cacheArcLengths = i, i
            }, i.Curve.prototype.updateArcLengths = function() {
                this.needsUpdate = !0, this.getLengths()
            }, i.Curve.prototype.getUtoTmapping = function(e, t) {
                var n, i = this.getLengths(),
                    r = 0,
                    o = i.length;
                n = t ? t : e * i[o - 1];
                for (var a, s = 0, l = o - 1; l >= s;)
                    if (r = Math.floor(s + (l - s) / 2), a = i[r] - n, 0 > a) s = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (r = l, i[r] == n) {
                    var c = r / (o - 1);
                    return c
                }
                var h = i[r],
                    u = i[r + 1],
                    f = u - h,
                    d = (n - h) / f,
                    c = (r + d) / (o - 1);
                return c
            }, i.Curve.prototype.getTangent = function(e) {
                var t = 1e-4,
                    n = e - t,
                    i = e + t;
                0 > n && (n = 0), i > 1 && (i = 1);
                var r = this.getPoint(n),
                    o = this.getPoint(i),
                    a = o.clone().sub(r);
                return a.normalize()
            }, i.Curve.prototype.getTangentAt = function(e) {
                var t = this.getUtoTmapping(e);
                return this.getTangent(t)
            }, i.Curve.Utils = {
                tangentQuadraticBezier: function(e, t, n, i) {
                    return 2 * (1 - e) * (n - t) + 2 * e * (i - n)
                },
                tangentCubicBezier: function(e, t, n, i, r) {
                    return -3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * i * (1 - e) - 3 * e * e * i + 3 * e * e * r
                },
                tangentSpline: function(e, t, n, i, r) {
                    var o = 6 * e * e - 6 * e,
                        a = 3 * e * e - 4 * e + 1,
                        s = -6 * e * e + 6 * e,
                        l = 3 * e * e - 2 * e;
                    return o + a + s + l
                },
                interpolate: function(e, t, n, i, r) {
                    var o = .5 * (n - e),
                        a = .5 * (i - t),
                        s = r * r,
                        l = r * s;
                    return (2 * t - 2 * n + o + a) * l + (-3 * t + 3 * n - 2 * o - a) * s + o * r + t
                }
            }, i.Curve.create = function(e, t) {
                return e.prototype = Object.create(i.Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, i.CurvePath = function() {
                this.curves = [], this.bends = [], this.autoClose = !1
            }, i.CurvePath.prototype = Object.create(i.Curve.prototype), i.CurvePath.prototype.constructor = i.CurvePath, i.CurvePath.prototype.add = function(e) {
                this.curves.push(e)
            }, i.CurvePath.prototype.checkConnection = function() {}, i.CurvePath.prototype.closePath = function() {
                var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new i.LineCurve(t, e))
            }, i.CurvePath.prototype.getPoint = function(e) {
                for (var t, n, i = e * this.getLength(), r = this.getCurveLengths(), o = 0; o < r.length;) {
                    if (r[o] >= i) {
                        t = r[o] - i, n = this.curves[o];
                        var a = 1 - t / n.getLength();
                        return n.getPointAt(a)
                    }
                    o++
                }
                return null
            }, i.CurvePath.prototype.getLength = function() {
                var e = this.getCurveLengths();
                return e[e.length - 1]
            }, i.CurvePath.prototype.getCurveLengths = function() {
                if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
                var e, t = [],
                    n = 0,
                    i = this.curves.length;
                for (e = 0; i > e; e++) n += this.curves[e].getLength(), t.push(n);
                return this.cacheLengths = t, t
            }, i.CurvePath.prototype.getBoundingBox = function() {
                var e, t, n, r, o, a, s = this.getPoints();
                e = t = Number.NEGATIVE_INFINITY, r = o = Number.POSITIVE_INFINITY;
                var l, c, h, u, f = s[0] instanceof i.Vector3;
                for (u = f ? new i.Vector3 : new i.Vector2, c = 0, h = s.length; h > c; c++) l = s[c], l.x > e ? e = l.x : l.x < r && (r = l.x), l.y > t ? t = l.y : l.y < o && (o = l.y), f && (l.z > n ? n = l.z : l.z < a && (a = l.z)), u.add(l);
                var d = {
                    minX: r,
                    minY: o,
                    maxX: e,
                    maxY: t
                };
                return f && (d.maxZ = n, d.minZ = a), d
            }, i.CurvePath.prototype.createPointsGeometry = function(e) {
                var t = this.getPoints(e, !0);
                return this.createGeometry(t)
            }, i.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
                var t = this.getSpacedPoints(e, !0);
                return this.createGeometry(t)
            }, i.CurvePath.prototype.createGeometry = function(e) {
                for (var t = new i.Geometry, n = 0; n < e.length; n++) t.vertices.push(new i.Vector3(e[n].x, e[n].y, e[n].z || 0));
                return t
            }, i.CurvePath.prototype.addWrapPath = function(e) {
                this.bends.push(e)
            }, i.CurvePath.prototype.getTransformedPoints = function(e, t) {
                var n, i, r = this.getPoints(e);
                for (t || (t = this.bends), n = 0, i = t.length; i > n; n++) r = this.getWrapPoints(r, t[n]);
                return r
            }, i.CurvePath.prototype.getTransformedSpacedPoints = function(e, t) {
                var n, i, r = this.getSpacedPoints(e);
                for (t || (t = this.bends), n = 0, i = t.length; i > n; n++) r = this.getWrapPoints(r, t[n]);
                return r
            }, i.CurvePath.prototype.getWrapPoints = function(e, t) {
                var n, i, r, o, a, s, l = this.getBoundingBox();
                for (n = 0, i = e.length; i > n; n++) {
                    r = e[n], o = r.x, a = r.y, s = o / l.maxX, s = t.getUtoTmapping(s, o);
                    var c = t.getPoint(s),
                        h = t.getTangent(s);
                    h.set(-h.y, h.x).multiplyScalar(a), r.x = c.x + h.x, r.y = c.y + h.y
                }
                return e
            }, i.Gyroscope = function() {
                i.Object3D.call(this)
            }, i.Gyroscope.prototype = Object.create(i.Object3D.prototype), i.Gyroscope.prototype.constructor = i.Gyroscope, i.Gyroscope.prototype.updateMatrixWorld = function() {
                var e = new i.Vector3,
                    t = new i.Quaternion,
                    n = new i.Vector3,
                    r = new i.Vector3,
                    o = new i.Quaternion,
                    a = new i.Vector3;
                return function(i) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || i) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(r, o, a), this.matrix.decompose(e, t, n), this.matrixWorld.compose(r, t, a)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, i = !0);
                    for (var s = 0, l = this.children.length; l > s; s++) this.children[s].updateMatrixWorld(i)
                }
            }(), i.Path = function(e) {
                i.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
            }, i.Path.prototype = Object.create(i.CurvePath.prototype), i.Path.prototype.constructor = i.Path, i.PathActions = {
                MOVE_TO: "moveTo",
                LINE_TO: "lineTo",
                QUADRATIC_CURVE_TO: "quadraticCurveTo",
                BEZIER_CURVE_TO: "bezierCurveTo",
                CSPLINE_THRU: "splineThru",
                ARC: "arc",
                ELLIPSE: "ellipse"
            }, i.Path.prototype.fromPoints = function(e) {
                this.moveTo(e[0].x, e[0].y);
                for (var t = 1, n = e.length; n > t; t++) this.lineTo(e[t].x, e[t].y)
            }, i.Path.prototype.moveTo = function(e, t) {
                var n = Array.prototype.slice.call(arguments);
                this.actions.push({
                    action: i.PathActions.MOVE_TO,
                    args: n
                })
            }, i.Path.prototype.lineTo = function(e, t) {
                var n = Array.prototype.slice.call(arguments),
                    r = this.actions[this.actions.length - 1].args,
                    o = r[r.length - 2],
                    a = r[r.length - 1],
                    s = new i.LineCurve(new i.Vector2(o, a), new i.Vector2(e, t));
                this.curves.push(s), this.actions.push({
                    action: i.PathActions.LINE_TO,
                    args: n
                })
            }, i.Path.prototype.quadraticCurveTo = function(e, t, n, r) {
                var o = Array.prototype.slice.call(arguments),
                    a = this.actions[this.actions.length - 1].args,
                    s = a[a.length - 2],
                    l = a[a.length - 1],
                    c = new i.QuadraticBezierCurve(new i.Vector2(s, l), new i.Vector2(e, t), new i.Vector2(n, r));
                this.curves.push(c), this.actions.push({
                    action: i.PathActions.QUADRATIC_CURVE_TO,
                    args: o
                })
            }, i.Path.prototype.bezierCurveTo = function(e, t, n, r, o, a) {
                var s = Array.prototype.slice.call(arguments),
                    l = this.actions[this.actions.length - 1].args,
                    c = l[l.length - 2],
                    h = l[l.length - 1],
                    u = new i.CubicBezierCurve(new i.Vector2(c, h), new i.Vector2(e, t), new i.Vector2(n, r), new i.Vector2(o, a));
                this.curves.push(u), this.actions.push({
                    action: i.PathActions.BEZIER_CURVE_TO,
                    args: s
                })
            }, i.Path.prototype.splineThru = function(e) {
                var t = Array.prototype.slice.call(arguments),
                    n = this.actions[this.actions.length - 1].args,
                    r = n[n.length - 2],
                    o = n[n.length - 1],
                    a = [new i.Vector2(r, o)];
                Array.prototype.push.apply(a, e);
                var s = new i.SplineCurve(a);
                this.curves.push(s), this.actions.push({
                    action: i.PathActions.CSPLINE_THRU,
                    args: t
                })
            }, i.Path.prototype.arc = function(e, t, n, i, r, o) {
                var a = this.actions[this.actions.length - 1].args,
                    s = a[a.length - 2],
                    l = a[a.length - 1];
                this.absarc(e + s, t + l, n, i, r, o)
            }, i.Path.prototype.absarc = function(e, t, n, i, r, o) {
                this.absellipse(e, t, n, n, i, r, o)
            }, i.Path.prototype.ellipse = function(e, t, n, i, r, o, a) {
                var s = this.actions[this.actions.length - 1].args,
                    l = s[s.length - 2],
                    c = s[s.length - 1];
                this.absellipse(e + l, t + c, n, i, r, o, a)
            }, i.Path.prototype.absellipse = function(e, t, n, r, o, a, s) {
                var l = Array.prototype.slice.call(arguments),
                    c = new i.EllipseCurve(e, t, n, r, o, a, s);
                this.curves.push(c);
                var h = c.getPoint(1);
                l.push(h.x), l.push(h.y), this.actions.push({
                    action: i.PathActions.ELLIPSE,
                    args: l
                })
            }, i.Path.prototype.getSpacedPoints = function(e, t) {
                e || (e = 40);
                for (var n = [], i = 0; e > i; i++) n.push(this.getPoint(i / e));
                return n
            }, i.Path.prototype.getPoints = function(e, t) {
                if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
                e = e || 12;
                var n, r, o, a, s, l, c, h, u, f, d, p, m, v, g, y, x, w, _ = [];
                for (n = 0, r = this.actions.length; r > n; n++) switch (o = this.actions[n], a = o.action, s = o.args, a) {
                    case i.PathActions.MOVE_TO:
                        _.push(new i.Vector2(s[0], s[1]));
                        break;
                    case i.PathActions.LINE_TO:
                        _.push(new i.Vector2(s[0], s[1]));
                        break;
                    case i.PathActions.QUADRATIC_CURVE_TO:
                        for (l = s[2], c = s[3], f = s[0], d = s[1], _.length > 0 ? (v = _[_.length - 1], p = v.x, m = v.y) : (v = this.actions[n - 1].args, p = v[v.length - 2], m = v[v.length - 1]), g = 1; e >= g; g++) y = g / e, x = i.Shape.Utils.b2(y, p, f, l), w = i.Shape.Utils.b2(y, m, d, c), _.push(new i.Vector2(x, w));
                        break;
                    case i.PathActions.BEZIER_CURVE_TO:
                        for (l = s[4], c = s[5], f = s[0], d = s[1], h = s[2], u = s[3], _.length > 0 ? (v = _[_.length - 1], p = v.x, m = v.y) : (v = this.actions[n - 1].args, p = v[v.length - 2], m = v[v.length - 1]), g = 1; e >= g; g++) y = g / e, x = i.Shape.Utils.b3(y, p, f, h, l), w = i.Shape.Utils.b3(y, m, d, u, c), _.push(new i.Vector2(x, w));
                        break;
                    case i.PathActions.CSPLINE_THRU:
                        v = this.actions[n - 1].args;
                        var b = new i.Vector2(v[v.length - 2], v[v.length - 1]),
                            E = [b],
                            M = e * s[0].length;
                        E = E.concat(s[0]);
                        var S = new i.SplineCurve(E);
                        for (g = 1; M >= g; g++) _.push(S.getPointAt(g / M));
                        break;
                    case i.PathActions.ARC:
                        var T, C = s[0],
                            A = s[1],
                            P = s[2],
                            D = s[3],
                            L = s[4],
                            R = !!s[5],
                            O = L - D,
                            N = 2 * e;
                        for (g = 1; N >= g; g++) y = g / N, R || (y = 1 - y), T = D + y * O, x = C + P * Math.cos(T), w = A + P * Math.sin(T), _.push(new i.Vector2(x, w));
                        break;
                    case i.PathActions.ELLIPSE:
                        var T, C = s[0],
                            A = s[1],
                            U = s[2],
                            F = s[3],
                            D = s[4],
                            L = s[5],
                            R = !!s[6],
                            O = L - D,
                            N = 2 * e;
                        for (g = 1; N >= g; g++) y = g / N, R || (y = 1 - y), T = D + y * O, x = C + U * Math.cos(T), w = A + F * Math.sin(T), _.push(new i.Vector2(x, w))
                }
                var k = _[_.length - 1],
                    H = 1e-10;
                return Math.abs(k.x - _[0].x) < H && Math.abs(k.y - _[0].y) < H && _.splice(_.length - 1, 1), t && _.push(_[0]), _
            }, i.Path.prototype.toShapes = function(e, t) {
                function n(e) {
                    var t, n, r, o, a, s = [],
                        l = new i.Path;
                    for (t = 0, n = e.length; n > t; t++) r = e[t], a = r.args, o = r.action, o == i.PathActions.MOVE_TO && 0 != l.actions.length && (s.push(l), l = new i.Path), l[o].apply(l, a);
                    return 0 != l.actions.length && s.push(l), s
                }

                function r(e) {
                    for (var t = [], n = 0, r = e.length; r > n; n++) {
                        var o = e[n],
                            a = new i.Shape;
                        a.actions = o.actions, a.curves = o.curves, t.push(a)
                    }
                    return t
                }

                function o(e, t) {
                    for (var n = 1e-10, i = t.length, r = !1, o = i - 1, a = 0; i > a; o = a++) {
                        var s = t[o],
                            l = t[a],
                            c = l.x - s.x,
                            h = l.y - s.y;
                        if (Math.abs(h) > n) {
                            if (0 > h && (s = t[a], c = -c, l = t[o], h = -h), e.y < s.y || e.y > l.y) continue;
                            if (e.y == s.y) {
                                if (e.x == s.x) return !0
                            } else {
                                var u = h * (e.x - s.x) - c * (e.y - s.y);
                                if (0 == u) return !0;
                                if (0 > u) continue;
                                r = !r
                            }
                        } else {
                            if (e.y != s.y) continue;
                            if (l.x <= e.x && e.x <= s.x || s.x <= e.x && e.x <= l.x) return !0
                        }
                    }
                    return r
                }
                var a = n(this.actions);
                if (0 == a.length) return [];
                if (t === !0) return r(a);
                var s, l, c, h = [];
                if (1 == a.length) return l = a[0], c = new i.Shape, c.actions = l.actions, c.curves = l.curves, h.push(c), h;
                var u = !i.Shape.Utils.isClockWise(a[0].getPoints());
                u = e ? !u : u;
                var f, d = [],
                    p = [],
                    m = [],
                    v = 0;
                p[v] = void 0, m[v] = [];
                var g, y;
                for (g = 0, y = a.length; y > g; g++) l = a[g], f = l.getPoints(), s = i.Shape.Utils.isClockWise(f), s = e ? !s : s, s ? (!u && p[v] && v++, p[v] = {
                    s: new i.Shape,
                    p: f
                }, p[v].s.actions = l.actions, p[v].s.curves = l.curves, u && v++, m[v] = []) : m[v].push({
                    h: l,
                    p: f[0]
                });
                if (!p[0]) return r(a);
                if (p.length > 1) {
                    for (var x = !1, w = [], _ = 0, b = p.length; b > _; _++) d[_] = [];
                    for (var _ = 0, b = p.length; b > _; _++)
                        for (var E = m[_], M = 0; M < E.length; M++) {
                            for (var S = E[M], T = !0, C = 0; C < p.length; C++) o(S.p, p[C].p) && (_ != C && w.push({
                                froms: _,
                                tos: C,
                                hole: M
                            }), T ? (T = !1, d[C].push(S)) : x = !0);
                            T && d[_].push(S)
                        }
                    w.length > 0 && (x || (m = d))
                }
                var A, P, D;
                for (g = 0, y = p.length; y > g; g++)
                    for (c = p[g].s, h.push(c), A = m[g], P = 0, D = A.length; D > P; P++) c.holes.push(A[P].h);
                return h
            }, i.Shape = function() {
                i.Path.apply(this, arguments), this.holes = []
            }, i.Shape.prototype = Object.create(i.Path.prototype), i.Shape.prototype.constructor = i.Shape, i.Shape.prototype.extrude = function(e) {
                var t = new i.ExtrudeGeometry(this, e);
                return t
            }, i.Shape.prototype.makeGeometry = function(e) {
                var t = new i.ShapeGeometry(this, e);
                return t
            }, i.Shape.prototype.getPointsHoles = function(e) {
                var t, n = this.holes.length,
                    i = [];
                for (t = 0; n > t; t++) i[t] = this.holes[t].getTransformedPoints(e, this.bends);
                return i
            }, i.Shape.prototype.getSpacedPointsHoles = function(e) {
                var t, n = this.holes.length,
                    i = [];
                for (t = 0; n > t; t++) i[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
                return i
            }, i.Shape.prototype.extractAllPoints = function(e) {
                return {
                    shape: this.getTransformedPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }, i.Shape.prototype.extractPoints = function(e) {
                return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
            }, i.Shape.prototype.extractAllSpacedPoints = function(e) {
                return {
                    shape: this.getTransformedSpacedPoints(e),
                    holes: this.getSpacedPointsHoles(e)
                }
            }, i.Shape.Utils = {
                triangulateShape: function(e, t) {
                    function n(e, t, n) {
                        return e.x != t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x : t.x <= n.x && n.x <= e.x : e.y < t.y ? e.y <= n.y && n.y <= t.y : t.y <= n.y && n.y <= e.y
                    }

                    function r(e, t, i, r, o) {
                        var a = 1e-10,
                            s = t.x - e.x,
                            l = t.y - e.y,
                            c = r.x - i.x,
                            h = r.y - i.y,
                            u = e.x - i.x,
                            f = e.y - i.y,
                            d = l * c - s * h,
                            p = l * u - s * f;
                        if (Math.abs(d) > a) {
                            var m;
                            if (d > 0) {
                                if (0 > p || p > d) return [];
                                if (m = h * u - c * f, 0 > m || m > d) return []
                            } else {
                                if (p > 0 || d > p) return [];
                                if (m = h * u - c * f, m > 0 || d > m) return []
                            } if (0 == m) return !o || 0 != p && p != d ? [e] : [];
                            if (m == d) return !o || 0 != p && p != d ? [t] : [];
                            if (0 == p) return [i];
                            if (p == d) return [r];
                            var v = m / d;
                            return [{
                                x: e.x + v * s,
                                y: e.y + v * l
                            }]
                        }
                        if (0 != p || h * u != c * f) return [];
                        var g = 0 == s && 0 == l,
                            y = 0 == c && 0 == h;
                        if (g && y) return e.x != i.x || e.y != i.y ? [] : [e];
                        if (g) return n(i, r, e) ? [e] : [];
                        if (y) return n(e, t, i) ? [i] : [];
                        var x, w, _, b, E, M, S, T;
                        return 0 != s ? (e.x < t.x ? (x = e, _ = e.x, w = t, b = t.x) : (x = t, _ = t.x, w = e, b = e.x), i.x < r.x ? (E = i, S = i.x, M = r, T = r.x) : (E = r, S = r.x, M = i, T = i.x)) : (e.y < t.y ? (x = e, _ = e.y, w = t, b = t.y) : (x = t, _ = t.y, w = e, b = e.y), i.y < r.y ? (E = i, S = i.y, M = r, T = r.y) : (E = r, S = r.y, M = i, T = i.y)), S >= _ ? S > b ? [] : b == S ? o ? [] : [E] : T >= b ? [E, w] : [E, M] : _ > T ? [] : _ == T ? o ? [] : [x] : T >= b ? [x, w] : [x, M]
                    }

                    function o(e, t, n, i) {
                        var r = 1e-10,
                            o = t.x - e.x,
                            a = t.y - e.y,
                            s = n.x - e.x,
                            l = n.y - e.y,
                            c = i.x - e.x,
                            h = i.y - e.y,
                            u = o * l - a * s,
                            f = o * h - a * c;
                        if (Math.abs(u) > r) {
                            var d = c * l - h * s;
                            return u > 0 ? f >= 0 && d >= 0 : f >= 0 || d >= 0
                        }
                        return f > 0
                    }

                    function a(e, t) {
                        function n(e, t) {
                            var n = y.length - 1,
                                i = e - 1;
                            0 > i && (i = n);
                            var r = e + 1;
                            r > n && (r = 0);
                            var a = o(y[e], y[i], y[r], s[t]);
                            if (!a) return !1;
                            var l = s.length - 1,
                                c = t - 1;
                            0 > c && (c = l);
                            var h = t + 1;
                            return h > l && (h = 0), a = o(s[t], s[c], s[h], y[e]), !!a
                        }

                        function i(e, t) {
                            var n, i, o;
                            for (n = 0; n < y.length; n++)
                                if (i = n + 1, i %= y.length, o = r(e, t, y[n], y[i], !0), o.length > 0) return !0;
                            return !1
                        }

                        function a(e, n) {
                            var i, o, a, s, l;
                            for (i = 0; i < x.length; i++)
                                for (o = t[x[i]], a = 0; a < o.length; a++)
                                    if (s = a + 1, s %= o.length, l = r(e, n, o[a], o[s], !0), l.length > 0) return !0;
                            return !1
                        }
                        for (var s, l, c, h, u, f, d, p, m, v, g, y = e.concat(), x = [], w = [], _ = 0, b = t.length; b > _; _++) x.push(_);
                        for (var E = 0, M = 2 * x.length; x.length > 0;) {
                            if (M--, 0 > M) {
                                console.log("Infinite Loop! Holes left:" + x.length + ", Probably Hole outside Shape!");
                                break
                            }
                            for (c = E; c < y.length; c++) {
                                h = y[c], l = -1;
                                for (var _ = 0; _ < x.length; _++)
                                    if (f = x[_], d = h.x + ":" + h.y + ":" + f, void 0 === w[d]) {
                                        s = t[f];
                                        for (var S = 0; S < s.length; S++)
                                            if (u = s[S], n(c, S) && !i(h, u) && !a(h, u)) {
                                                l = S, x.splice(_, 1), p = y.slice(0, c + 1), m = y.slice(c), v = s.slice(l), g = s.slice(0, l + 1), y = p.concat(v).concat(g).concat(m), E = c;
                                                break
                                            }
                                        if (l >= 0) break;
                                        w[d] = !0
                                    }
                                if (l >= 0) break
                            }
                        }
                        return y
                    }
                    for (var s, l, c, h, u, f, d = {}, p = e.concat(), m = 0, v = t.length; v > m; m++) Array.prototype.push.apply(p, t[m]);
                    for (s = 0, l = p.length; l > s; s++) u = p[s].x + ":" + p[s].y, void 0 !== d[u] && i.warn("THREE.Shape: Duplicate point", u), d[u] = s;
                    var g = a(e, t),
                        y = i.FontUtils.Triangulate(g, !1);
                    for (s = 0, l = y.length; l > s; s++)
                        for (h = y[s], c = 0; 3 > c; c++) u = h[c].x + ":" + h[c].y, f = d[u], void 0 !== f && (h[c] = f);
                    return y.concat()
                },
                isClockWise: function(e) {
                    return i.FontUtils.Triangulate.area(e) < 0
                },
                b2p0: function(e, t) {
                    var n = 1 - e;
                    return n * n * t
                },
                b2p1: function(e, t) {
                    return 2 * (1 - e) * e * t
                },
                b2p2: function(e, t) {
                    return e * e * t
                },
                b2: function(e, t, n, i) {
                    return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, i)
                },
                b3p0: function(e, t) {
                    var n = 1 - e;
                    return n * n * n * t
                },
                b3p1: function(e, t) {
                    var n = 1 - e;
                    return 3 * n * n * e * t
                },
                b3p2: function(e, t) {
                    var n = 1 - e;
                    return 3 * n * e * e * t
                },
                b3p3: function(e, t) {
                    return e * e * e * t
                },
                b3: function(e, t, n, i, r) {
                    return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, i) + this.b3p3(e, r)
                }
            }, i.LineCurve = function(e, t) {
                this.v1 = e, this.v2 = t
            }, i.LineCurve.prototype = Object.create(i.Curve.prototype), i.LineCurve.prototype.constructor = i.LineCurve, i.LineCurve.prototype.getPoint = function(e) {
                var t = this.v2.clone().sub(this.v1);
                return t.multiplyScalar(e).add(this.v1), t
            }, i.LineCurve.prototype.getPointAt = function(e) {
                return this.getPoint(e)
            }, i.LineCurve.prototype.getTangent = function(e) {
                var t = this.v2.clone().sub(this.v1);
                return t.normalize()
            }, i.QuadraticBezierCurve = function(e, t, n) {
                this.v0 = e, this.v1 = t, this.v2 = n
            }, i.QuadraticBezierCurve.prototype = Object.create(i.Curve.prototype), i.QuadraticBezierCurve.prototype.constructor = i.QuadraticBezierCurve, i.QuadraticBezierCurve.prototype.getPoint = function(e) {
                var t = new i.Vector2;
                return t.x = i.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), t.y = i.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), t
            }, i.QuadraticBezierCurve.prototype.getTangent = function(e) {
                var t = new i.Vector2;
                return t.x = i.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), t.y = i.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), t.normalize()
            }, i.CubicBezierCurve = function(e, t, n, i) {
                this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }, i.CubicBezierCurve.prototype = Object.create(i.Curve.prototype), i.CubicBezierCurve.prototype.constructor = i.CubicBezierCurve, i.CubicBezierCurve.prototype.getPoint = function(e) {
                var t, n;
                return t = i.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), n = i.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new i.Vector2(t, n)
            }, i.CubicBezierCurve.prototype.getTangent = function(e) {
                var t, n;
                t = i.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), n = i.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
                var r = new i.Vector2(t, n);
                return r.normalize(), r
            }, i.SplineCurve = function(e) {
                this.points = void 0 == e ? [] : e
            }, i.SplineCurve.prototype = Object.create(i.Curve.prototype), i.SplineCurve.prototype.constructor = i.SplineCurve, i.SplineCurve.prototype.getPoint = function(e) {
                var t = this.points,
                    n = (t.length - 1) * e,
                    r = Math.floor(n),
                    o = n - r,
                    a = t[0 == r ? r : r - 1],
                    s = t[r],
                    l = t[r > t.length - 2 ? t.length - 1 : r + 1],
                    c = t[r > t.length - 3 ? t.length - 1 : r + 2],
                    h = new i.Vector2;
                return h.x = i.Curve.Utils.interpolate(a.x, s.x, l.x, c.x, o), h.y = i.Curve.Utils.interpolate(a.y, s.y, l.y, c.y, o), h
            }, i.EllipseCurve = function(e, t, n, i, r, o, a) {
                this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a
            }, i.EllipseCurve.prototype = Object.create(i.Curve.prototype), i.EllipseCurve.prototype.constructor = i.EllipseCurve, i.EllipseCurve.prototype.getPoint = function(e) {
                var t = this.aEndAngle - this.aStartAngle;
                0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI);
                var n;
                n = this.aClockwise === !0 ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t;
                var r = new i.Vector2;
                return r.x = this.aX + this.xRadius * Math.cos(n), r.y = this.aY + this.yRadius * Math.sin(n), r
            }, i.ArcCurve = function(e, t, n, r, o, a) {
                i.EllipseCurve.call(this, e, t, n, n, r, o, a)
            }, i.ArcCurve.prototype = Object.create(i.EllipseCurve.prototype), i.ArcCurve.prototype.constructor = i.ArcCurve, i.LineCurve3 = i.Curve.create(function(e, t) {
                this.v1 = e, this.v2 = t
            }, function(e) {
                var t = new i.Vector3;
                return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
            }), i.QuadraticBezierCurve3 = i.Curve.create(function(e, t, n) {
                this.v0 = e, this.v1 = t, this.v2 = n
            }, function(e) {
                var t = new i.Vector3;
                return t.x = i.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), t.y = i.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), t.z = i.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), t
            }), i.CubicBezierCurve3 = i.Curve.create(function(e, t, n, i) {
                this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
            }, function(e) {
                var t = new i.Vector3;
                return t.x = i.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t.y = i.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t.z = i.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), t
            }), i.SplineCurve3 = i.Curve.create(function(e) {
                this.points = void 0 == e ? [] : e
            }, function(e) {
                var t = this.points,
                    n = (t.length - 1) * e,
                    r = Math.floor(n),
                    o = n - r,
                    a = t[0 == r ? r : r - 1],
                    s = t[r],
                    l = t[r > t.length - 2 ? t.length - 1 : r + 1],
                    c = t[r > t.length - 3 ? t.length - 1 : r + 2],
                    h = new i.Vector3;
                return h.x = i.Curve.Utils.interpolate(a.x, s.x, l.x, c.x, o), h.y = i.Curve.Utils.interpolate(a.y, s.y, l.y, c.y, o), h.z = i.Curve.Utils.interpolate(a.z, s.z, l.z, c.z, o), h
            }), i.ClosedSplineCurve3 = i.Curve.create(function(e) {
                this.points = void 0 == e ? [] : e
            }, function(e) {
                var t = this.points,
                    n = (t.length - 0) * e,
                    r = Math.floor(n),
                    o = n - r;
                r += r > 0 ? 0 : (Math.floor(Math.abs(r) / t.length) + 1) * t.length;
                var a = t[(r - 1) % t.length],
                    s = t[r % t.length],
                    l = t[(r + 1) % t.length],
                    c = t[(r + 2) % t.length],
                    h = new i.Vector3;
                return h.x = i.Curve.Utils.interpolate(a.x, s.x, l.x, c.x, o), h.y = i.Curve.Utils.interpolate(a.y, s.y, l.y, c.y, o), h.z = i.Curve.Utils.interpolate(a.z, s.z, l.z, c.z, o), h
            }), i.AnimationHandler = {
                LINEAR: 0,
                CATMULLROM: 1,
                CATMULLROM_FORWARD: 2,
                add: function() {
                    i.warn("THREE.AnimationHandler.add() has been deprecated.")
                },
                get: function() {
                    i.warn("THREE.AnimationHandler.get() has been deprecated.")
                },
                remove: function() {
                    i.warn("THREE.AnimationHandler.remove() has been deprecated.")
                },
                animations: [],
                init: function(e) {
                    if (e.initialized === !0) return e;
                    for (var t = 0; t < e.hierarchy.length; t++) {
                        for (var n = 0; n < e.hierarchy[t].keys.length; n++)
                            if (e.hierarchy[t].keys[n].time < 0 && (e.hierarchy[t].keys[n].time = 0), void 0 !== e.hierarchy[t].keys[n].rot && !(e.hierarchy[t].keys[n].rot instanceof i.Quaternion)) {
                                var r = e.hierarchy[t].keys[n].rot;
                                e.hierarchy[t].keys[n].rot = (new i.Quaternion).fromArray(r)
                            }
                        if (e.hierarchy[t].keys.length && void 0 !== e.hierarchy[t].keys[0].morphTargets) {
                            for (var o = {}, n = 0; n < e.hierarchy[t].keys.length; n++)
                                for (var a = 0; a < e.hierarchy[t].keys[n].morphTargets.length; a++) {
                                    var s = e.hierarchy[t].keys[n].morphTargets[a];
                                    o[s] = -1
                                }
                            e.hierarchy[t].usedMorphTargets = o;
                            for (var n = 0; n < e.hierarchy[t].keys.length; n++) {
                                var l = {};
                                for (var s in o) {
                                    for (var a = 0; a < e.hierarchy[t].keys[n].morphTargets.length; a++)
                                        if (e.hierarchy[t].keys[n].morphTargets[a] === s) {
                                            l[s] = e.hierarchy[t].keys[n].morphTargetsInfluences[a];
                                            break
                                        }
                                    a === e.hierarchy[t].keys[n].morphTargets.length && (l[s] = 0)
                                }
                                e.hierarchy[t].keys[n].morphTargetsInfluences = l
                            }
                        }
                        for (var n = 1; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].time === e.hierarchy[t].keys[n - 1].time && (e.hierarchy[t].keys.splice(n, 1), n--);
                        for (var n = 0; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].index = n
                    }
                    return e.initialized = !0, e
                },
                parse: function(e) {
                    var t = function(e, n) {
                            n.push(e);
                            for (var i = 0; i < e.children.length; i++) t(e.children[i], n)
                        },
                        n = [];
                    if (e instanceof i.SkinnedMesh)
                        for (var r = 0; r < e.skeleton.bones.length; r++) n.push(e.skeleton.bones[r]);
                    else t(e, n);
                    return n
                },
                play: function(e) {
                    -1 === this.animations.indexOf(e) && this.animations.push(e)
                },
                stop: function(e) {
                    var t = this.animations.indexOf(e); - 1 !== t && this.animations.splice(t, 1)
                },
                update: function(e) {
                    for (var t = 0; t < this.animations.length; t++) this.animations[t].resetBlendWeights();
                    for (var t = 0; t < this.animations.length; t++) this.animations[t].update(e)
                }
            }, i.Animation = function(e, t) {
                this.root = e, this.data = i.AnimationHandler.init(t), this.hierarchy = i.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = i.AnimationHandler.LINEAR
            }, i.Animation.prototype = {
                constructor: i.Animation,
                keyTypes: ["pos", "rot", "scl"],
                play: function(e, t) {
                    this.currentTime = void 0 !== e ? e : 0, this.weight = void 0 !== t ? t : 1, this.isPlaying = !0, this.reset(), i.AnimationHandler.play(this)
                },
                stop: function() {
                    this.isPlaying = !1, i.AnimationHandler.stop(this)
                },
                reset: function() {
                    for (var e = 0, t = this.hierarchy.length; t > e; e++) {
                        var n = this.hierarchy[e];
                        void 0 === n.animationCache && (n.animationCache = {
                            animations: {},
                            blending: {
                                positionWeight: 0,
                                quaternionWeight: 0,
                                scaleWeight: 0
                            }
                        });
                        var i = this.data.name,
                            r = n.animationCache.animations,
                            o = r[i];
                        void 0 === o && (o = {
                            prevKey: {
                                pos: 0,
                                rot: 0,
                                scl: 0
                            },
                            nextKey: {
                                pos: 0,
                                rot: 0,
                                scl: 0
                            },
                            originalMatrix: n.matrix
                        }, r[i] = o);
                        for (var a = 0; 3 > a; a++) {
                            for (var s = this.keyTypes[a], l = this.data.hierarchy[e].keys[0], c = this.getNextKeyWith(s, e, 1); c.time < this.currentTime && c.index > l.index;) l = c, c = this.getNextKeyWith(s, e, c.index + 1);
                            o.prevKey[s] = l, o.nextKey[s] = c
                        }
                    }
                },
                resetBlendWeights: function() {
                    for (var e = 0, t = this.hierarchy.length; t > e; e++) {
                        var n = this.hierarchy[e],
                            i = n.animationCache;
                        if (void 0 !== i) {
                            var r = i.blending;
                            r.positionWeight = 0, r.quaternionWeight = 0, r.scaleWeight = 0
                        }
                    }
                },
                update: function() {
                    var e = [],
                        t = new i.Vector3,
                        n = new i.Vector3,
                        r = new i.Quaternion,
                        o = function(e, t) {
                            var n, i, r, o, s, l, c, h, u, f = [],
                                d = [];
                            return n = (e.length - 1) * t, i = Math.floor(n), r = n - i, f[0] = 0 === i ? i : i - 1, f[1] = i, f[2] = i > e.length - 2 ? i : i + 1, f[3] = i > e.length - 3 ? i : i + 2, l = e[f[0]], c = e[f[1]], h = e[f[2]], u = e[f[3]], o = r * r, s = r * o, d[0] = a(l[0], c[0], h[0], u[0], r, o, s), d[1] = a(l[1], c[1], h[1], u[1], r, o, s), d[2] = a(l[2], c[2], h[2], u[2], r, o, s), d
                        },
                        a = function(e, t, n, i, r, o, a) {
                            var s = .5 * (n - e),
                                l = .5 * (i - t);
                            return (2 * (t - n) + s + l) * a + (-3 * (t - n) - 2 * s - l) * o + s * r + t
                        };
                    return function(a) {
                        if (this.isPlaying !== !1 && (this.resetBlendWeights(), this.currentTime += a * this.timeScale, 0 !== this.weight)) {
                            var s = this.data.length;
                            (this.currentTime > s || this.currentTime < 0) && (this.loop ? (this.currentTime %= s, this.currentTime < 0 && (this.currentTime += s), this.reset()) : this.stop());
                            for (var l = 0, c = this.hierarchy.length; c > l; l++)
                                for (var h = this.hierarchy[l], u = h.animationCache.animations[this.data.name], f = h.animationCache.blending, d = 0; 3 > d; d++) {
                                    var p = this.keyTypes[d],
                                        m = u.prevKey[p],
                                        v = u.nextKey[p];
                                    if (this.timeScale > 0 && v.time <= this.currentTime || this.timeScale < 0 && m.time >= this.currentTime) {
                                        for (m = this.data.hierarchy[l].keys[0], v = this.getNextKeyWith(p, l, 1); v.time < this.currentTime && v.index > m.index;) m = v, v = this.getNextKeyWith(p, l, v.index + 1);
                                        u.prevKey[p] = m, u.nextKey[p] = v
                                    }
                                    var g = (this.currentTime - m.time) / (v.time - m.time),
                                        y = m[p],
                                        x = v[p];
                                    if (0 > g && (g = 0), g > 1 && (g = 1), "pos" === p) {
                                        if (this.interpolationType === i.AnimationHandler.LINEAR) {
                                            n.x = y[0] + (x[0] - y[0]) * g, n.y = y[1] + (x[1] - y[1]) * g, n.z = y[2] + (x[2] - y[2]) * g;
                                            var w = this.weight / (this.weight + f.positionWeight);
                                            h.position.lerp(n, w), f.positionWeight += this.weight
                                        } else if (this.interpolationType === i.AnimationHandler.CATMULLROM || this.interpolationType === i.AnimationHandler.CATMULLROM_FORWARD) {
                                            e[0] = this.getPrevKeyWith("pos", l, m.index - 1).pos, e[1] = y, e[2] = x, e[3] = this.getNextKeyWith("pos", l, v.index + 1).pos, g = .33 * g + .33;
                                            var _ = o(e, g),
                                                w = this.weight / (this.weight + f.positionWeight);
                                            f.positionWeight += this.weight;
                                            var b = h.position;
                                            if (b.x = b.x + (_[0] - b.x) * w, b.y = b.y + (_[1] - b.y) * w, b.z = b.z + (_[2] - b.z) * w, this.interpolationType === i.AnimationHandler.CATMULLROM_FORWARD) {
                                                var E = o(e, 1.01 * g);
                                                t.set(E[0], E[1], E[2]), t.sub(b), t.y = 0, t.normalize();
                                                var M = Math.atan2(t.x, t.z);
                                                h.rotation.set(0, M, 0)
                                            }
                                        }
                                    } else if ("rot" === p)
                                        if (i.Quaternion.slerp(y, x, r, g), 0 === f.quaternionWeight) h.quaternion.copy(r), f.quaternionWeight = this.weight;
                                        else {
                                            var w = this.weight / (this.weight + f.quaternionWeight);
                                            i.Quaternion.slerp(h.quaternion, r, h.quaternion, w), f.quaternionWeight += this.weight
                                        } else if ("scl" === p) {
                                        n.x = y[0] + (x[0] - y[0]) * g, n.y = y[1] + (x[1] - y[1]) * g, n.z = y[2] + (x[2] - y[2]) * g;
                                        var w = this.weight / (this.weight + f.scaleWeight);
                                        h.scale.lerp(n, w), f.scaleWeight += this.weight
                                    }
                                }
                            return !0
                        }
                    }
                }(),
                getNextKeyWith: function(e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    for (this.interpolationType === i.AnimationHandler.CATMULLROM || this.interpolationType === i.AnimationHandler.CATMULLROM_FORWARD ? n = n < r.length - 1 ? n : r.length - 1 : n %= r.length; n < r.length; n++)
                        if (void 0 !== r[n][e]) return r[n];
                    return this.data.hierarchy[t].keys[0]
                },
                getPrevKeyWith: function(e, t, n) {
                    var r = this.data.hierarchy[t].keys;
                    for (n = this.interpolationType === i.AnimationHandler.CATMULLROM || this.interpolationType === i.AnimationHandler.CATMULLROM_FORWARD ? n > 0 ? n : 0 : n >= 0 ? n : n + r.length; n >= 0; n--)
                        if (void 0 !== r[n][e]) return r[n];
                    return this.data.hierarchy[t].keys[r.length - 1]
                }
            }, i.KeyFrameAnimation = function(e, t) {
                this.root = e, this.data = i.AnimationHandler.init(t), this.hierarchy = i.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.isPaused = !0, this.loop = !0;
                for (var n = 0, r = this.hierarchy.length; r > n; n++) {
                    var o = this.data.hierarchy[n].keys,
                        a = this.data.hierarchy[n].sids,
                        s = this.hierarchy[n];
                    if (o.length && a) {
                        for (var l = 0; l < a.length; l++) {
                            var c = a[l],
                                h = this.getNextKeyWith(c, n, 0);
                            h && h.apply(c)
                        }
                        s.matrixAutoUpdate = !1, this.data.hierarchy[n].node.updateMatrix(), s.matrixWorldNeedsUpdate = !0
                    }
                }
            }, i.KeyFrameAnimation.prototype = {
                constructor: i.KeyFrameAnimation,
                play: function(e) {
                    if (this.currentTime = void 0 !== e ? e : 0, this.isPlaying === !1) {
                        this.isPlaying = !0;
                        var t, n, r, o = this.hierarchy.length;
                        for (t = 0; o > t; t++) {
                            n = this.hierarchy[t], r = this.data.hierarchy[t], void 0 === r.animationCache && (r.animationCache = {}, r.animationCache.prevKey = null, r.animationCache.nextKey = null, r.animationCache.originalMatrix = n.matrix);
                            var a = this.data.hierarchy[t].keys;
                            a.length && (r.animationCache.prevKey = a[0], r.animationCache.nextKey = a[1], this.startTime = Math.min(a[0].time, this.startTime), this.endTime = Math.max(a[a.length - 1].time, this.endTime))
                        }
                        this.update(0)
                    }
                    this.isPaused = !1, i.AnimationHandler.play(this)
                },
                stop: function() {
                    this.isPlaying = !1, this.isPaused = !1, i.AnimationHandler.stop(this);
                    for (var e = 0; e < this.data.hierarchy.length; e++) {
                        var t = this.hierarchy[e],
                            n = this.data.hierarchy[e];
                        if (void 0 !== n.animationCache) {
                            var r = n.animationCache.originalMatrix;
                            r.copy(t.matrix), t.matrix = r, delete n.animationCache
                        }
                    }
                },
                update: function(e) {
                    if (this.isPlaying !== !1) {
                        this.currentTime += e * this.timeScale;
                        var t = this.data.length;
                        this.loop === !0 && this.currentTime > t && (this.currentTime %= t), this.currentTime = Math.min(this.currentTime, t);
                        for (var n = 0, i = this.hierarchy.length; i > n; n++) {
                            var r = this.hierarchy[n],
                                o = this.data.hierarchy[n],
                                a = o.keys,
                                s = o.animationCache;
                            if (a.length) {
                                var l = s.prevKey,
                                    c = s.nextKey;
                                if (c.time <= this.currentTime) {
                                    for (; c.time < this.currentTime && c.index > l.index;) l = c, c = a[l.index + 1];
                                    s.prevKey = l, s.nextKey = c
                                }
                                c.time >= this.currentTime ? l.interpolate(c, this.currentTime) : l.interpolate(c, c.time), this.data.hierarchy[n].node.updateMatrix(), r.matrixWorldNeedsUpdate = !0
                            }
                        }
                    }
                },
                getNextKeyWith: function(e, t, n) {
                    var i = this.data.hierarchy[t].keys;
                    for (n %= i.length; n < i.length; n++)
                        if (i[n].hasTarget(e)) return i[n];
                    return i[0]
                },
                getPrevKeyWith: function(e, t, n) {
                    var i = this.data.hierarchy[t].keys;
                    for (n = n >= 0 ? n : n + i.length; n >= 0; n--)
                        if (i[n].hasTarget(e)) return i[n];
                    return i[i.length - 1]
                }
            }, i.MorphAnimation = function(e) {
                this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.lastFrame = 0, this.currentFrame = 0, this.isPlaying = !1
            }, i.MorphAnimation.prototype = {
                constructor: i.MorphAnimation,
                play: function() {
                    this.isPlaying = !0
                },
                pause: function() {
                    this.isPlaying = !1
                },
                update: function(e) {
                    if (this.isPlaying !== !1) {
                        this.currentTime += e, this.loop === !0 && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration);
                        var t = this.duration / this.frames,
                            n = Math.floor(this.currentTime / t),
                            i = this.mesh.morphTargetInfluences;
                        n != this.currentFrame && (i[this.lastFrame] = 0, i[this.currentFrame] = 1, i[n] = 0, this.lastFrame = this.currentFrame, this.currentFrame = n), i[n] = this.currentTime % t / t, i[this.lastFrame] = 1 - i[n]
                    }
                }
            }, i.BoxGeometry = function(e, t, n, r, o, a) {
                function s(e, t, n, r, o, a, s, c) {
                    var h, u, f, d = l.widthSegments,
                        p = l.heightSegments,
                        m = o / 2,
                        v = a / 2,
                        g = l.vertices.length;
                    "x" === e && "y" === t || "y" === e && "x" === t ? h = "z" : "x" === e && "z" === t || "z" === e && "x" === t ? (h = "y", p = l.depthSegments) : ("z" === e && "y" === t || "y" === e && "z" === t) && (h = "x", d = l.depthSegments);
                    var y = d + 1,
                        x = p + 1,
                        w = o / d,
                        _ = a / p,
                        b = new i.Vector3;
                    for (b[h] = s > 0 ? 1 : -1, f = 0; x > f; f++)
                        for (u = 0; y > u; u++) {
                            var E = new i.Vector3;
                            E[e] = (u * w - m) * n, E[t] = (f * _ - v) * r, E[h] = s, l.vertices.push(E)
                        }
                    for (f = 0; p > f; f++)
                        for (u = 0; d > u; u++) {
                            var M = u + y * f,
                                S = u + y * (f + 1),
                                T = u + 1 + y * (f + 1),
                                C = u + 1 + y * f,
                                A = new i.Vector2(u / d, 1 - f / p),
                                P = new i.Vector2(u / d, 1 - (f + 1) / p),
                                D = new i.Vector2((u + 1) / d, 1 - (f + 1) / p),
                                L = new i.Vector2((u + 1) / d, 1 - f / p),
                                R = new i.Face3(M + g, S + g, C + g);
                            R.normal.copy(b), R.vertexNormals.push(b.clone(), b.clone(), b.clone()), R.materialIndex = c, l.faces.push(R), l.faceVertexUvs[0].push([A, P, L]), R = new i.Face3(S + g, T + g, C + g), R.normal.copy(b), R.vertexNormals.push(b.clone(), b.clone(), b.clone()), R.materialIndex = c, l.faces.push(R), l.faceVertexUvs[0].push([P.clone(), D, L.clone()])
                        }
                }
                i.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: o,
                    depthSegments: a
                }, this.widthSegments = r || 1, this.heightSegments = o || 1, this.depthSegments = a || 1;
                var l = this,
                    c = e / 2,
                    h = t / 2,
                    u = n / 2;
                s("z", "y", -1, -1, n, t, c, 0), s("z", "y", 1, -1, n, t, -c, 1), s("x", "z", 1, 1, e, n, h, 2), s("x", "z", 1, -1, e, n, -h, 3), s("x", "y", 1, -1, e, t, u, 4), s("x", "y", -1, -1, e, t, -u, 5), this.mergeVertices()
            }, i.BoxGeometry.prototype = Object.create(i.Geometry.prototype), i.BoxGeometry.prototype.constructor = i.BoxGeometry, i.CircleGeometry = function(e, t, n, r) {
                i.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var o, a = [],
                    s = new i.Vector3,
                    l = new i.Vector2(.5, .5);
                for (this.vertices.push(s), a.push(l), o = 0; t >= o; o++) {
                    var c = new i.Vector3,
                        h = n + o / t * r;
                    c.x = e * Math.cos(h), c.y = e * Math.sin(h), this.vertices.push(c), a.push(new i.Vector2((c.x / e + 1) / 2, (c.y / e + 1) / 2))
                }
                var u = new i.Vector3(0, 0, 1);
                for (o = 1; t >= o; o++) this.faces.push(new i.Face3(o, o + 1, 0, [u.clone(), u.clone(), u.clone()])), this.faceVertexUvs[0].push([a[o].clone(), a[o + 1].clone(), l.clone()]);
                this.computeFaceNormals(), this.boundingSphere = new i.Sphere(new i.Vector3, e)
            }, i.CircleGeometry.prototype = Object.create(i.Geometry.prototype), i.CircleGeometry.prototype.constructor = i.CircleGeometry, i.CubeGeometry = function(e, t, n, r, o, a) {
                return i.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry."), new i.BoxGeometry(e, t, n, r, o, a)
            }, i.CylinderGeometry = function(e, t, n, r, o, a, s, l) {
                i.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: o,
                    openEnded: a,
                    thetaStart: s,
                    thetaLength: l
                }, e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, n = void 0 !== n ? n : 100, r = r || 8, o = o || 1, a = void 0 !== a ? a : !1, s = void 0 !== s ? s : 0, l = void 0 !== l ? l : 2 * Math.PI;
                var c, h, u = n / 2,
                    f = [],
                    d = [];
                for (h = 0; o >= h; h++) {
                    var p = [],
                        m = [],
                        v = h / o,
                        g = v * (t - e) + e;
                    for (c = 0; r >= c; c++) {
                        var y = c / r,
                            x = new i.Vector3;
                        x.x = g * Math.sin(y * l + s), x.y = -v * n + u, x.z = g * Math.cos(y * l + s), this.vertices.push(x), p.push(this.vertices.length - 1), m.push(new i.Vector2(y, 1 - v))
                    }
                    f.push(p), d.push(m)
                }
                var w, _, b = (t - e) / n;
                for (c = 0; r > c; c++)
                    for (0 !== e ? (w = this.vertices[f[0][c]].clone(), _ = this.vertices[f[0][c + 1]].clone()) : (w = this.vertices[f[1][c]].clone(), _ = this.vertices[f[1][c + 1]].clone()), w.setY(Math.sqrt(w.x * w.x + w.z * w.z) * b).normalize(), _.setY(Math.sqrt(_.x * _.x + _.z * _.z) * b).normalize(), h = 0; o > h; h++) {
                        var E = f[h][c],
                            M = f[h + 1][c],
                            S = f[h + 1][c + 1],
                            T = f[h][c + 1],
                            C = w.clone(),
                            A = w.clone(),
                            P = _.clone(),
                            D = _.clone(),
                            L = d[h][c].clone(),
                            R = d[h + 1][c].clone(),
                            O = d[h + 1][c + 1].clone(),
                            N = d[h][c + 1].clone();
                        this.faces.push(new i.Face3(E, M, T, [C, A, D])), this.faceVertexUvs[0].push([L, R, N]), this.faces.push(new i.Face3(M, S, T, [A.clone(), P, D.clone()])), this.faceVertexUvs[0].push([R.clone(), O, N.clone()])
                    }
                if (a === !1 && e > 0)
                    for (this.vertices.push(new i.Vector3(0, u, 0)), c = 0; r > c; c++) {
                        var E = f[0][c],
                            M = f[0][c + 1],
                            S = this.vertices.length - 1,
                            C = new i.Vector3(0, 1, 0),
                            A = new i.Vector3(0, 1, 0),
                            P = new i.Vector3(0, 1, 0),
                            L = d[0][c].clone(),
                            R = d[0][c + 1].clone(),
                            O = new i.Vector2(R.x, 0);
                        this.faces.push(new i.Face3(E, M, S, [C, A, P])), this.faceVertexUvs[0].push([L, R, O])
                    }
                if (a === !1 && t > 0)
                    for (this.vertices.push(new i.Vector3(0, -u, 0)), c = 0; r > c; c++) {
                        var E = f[o][c + 1],
                            M = f[o][c],
                            S = this.vertices.length - 1,
                            C = new i.Vector3(0, -1, 0),
                            A = new i.Vector3(0, -1, 0),
                            P = new i.Vector3(0, -1, 0),
                            L = d[o][c + 1].clone(),
                            R = d[o][c].clone(),
                            O = new i.Vector2(R.x, 1);
                        this.faces.push(new i.Face3(E, M, S, [C, A, P])), this.faceVertexUvs[0].push([L, R, O])
                    }
                this.computeFaceNormals()
            }, i.CylinderGeometry.prototype = Object.create(i.Geometry.prototype), i.CylinderGeometry.prototype.constructor = i.CylinderGeometry, i.ExtrudeGeometry = function(e, t) {
                return "undefined" == typeof e ? void(e = []) : (i.Geometry.call(this), this.type = "ExtrudeGeometry", e = e instanceof Array ? e : [e], this.addShapeList(e, t), void this.computeFaceNormals())
            }, i.ExtrudeGeometry.prototype = Object.create(i.Geometry.prototype), i.ExtrudeGeometry.prototype.constructor = i.ExtrudeGeometry, i.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
                for (var n = e.length, i = 0; n > i; i++) {
                    var r = e[i];
                    this.addShape(r, t)
                }
            }, i.ExtrudeGeometry.prototype.addShape = function(e, t) {
                function n(e, t, n) {
                    return t || i.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                }

                function r(e, t, n) {
                    var r, o, a = 1e-10,
                        s = 1,
                        l = e.x - t.x,
                        c = e.y - t.y,
                        h = n.x - e.x,
                        u = n.y - e.y,
                        f = l * l + c * c,
                        d = l * u - c * h;
                    if (Math.abs(d) > a) {
                        var p = Math.sqrt(f),
                            m = Math.sqrt(h * h + u * u),
                            v = t.x - c / p,
                            g = t.y + l / p,
                            y = n.x - u / m,
                            x = n.y + h / m,
                            w = ((y - v) * u - (x - g) * h) / (l * u - c * h);
                        r = v + l * w - e.x, o = g + c * w - e.y;
                        var _ = r * r + o * o;
                        if (2 >= _) return new i.Vector2(r, o);
                        s = Math.sqrt(_ / 2)
                    } else {
                        var b = !1;
                        l > a ? h > a && (b = !0) : -a > l ? -a > h && (b = !0) : Math.sign(c) == Math.sign(u) && (b = !0), b ? (r = -c, o = l, s = Math.sqrt(f)) : (r = l, o = c, s = Math.sqrt(f / 2))
                    }
                    return new i.Vector2(r / s, o / s)
                }

                function o() {
                    if (w) {
                        var e = 0,
                            t = W * e;
                        for (K = 0; X > K; K++) G = k[K], c(G[2] + t, G[1] + t, G[0] + t);
                        for (e = b + 2 * x, t = W * e, K = 0; X > K; K++) G = k[K], c(G[0] + t, G[1] + t, G[2] + t)
                    } else {
                        for (K = 0; X > K; K++) G = k[K], c(G[2], G[1], G[0]);
                        for (K = 0; X > K; K++) G = k[K], c(G[0] + W * b, G[1] + W * b, G[2] + W * b)
                    }
                }

                function a() {
                    var e = 0;
                    for (s(H, e), e += H.length, P = 0, D = U.length; D > P; P++) A = U[P], s(A, e), e += A.length
                }

                function s(e, t) {
                    var n, i;
                    for (K = e.length; --K >= 0;) {
                        n = K, i = K - 1, 0 > i && (i = e.length - 1);
                        var r = 0,
                            o = b + 2 * x;
                        for (r = 0; o > r; r++) {
                            var a = W * r,
                                s = W * (r + 1),
                                l = t + n + a,
                                c = t + i + a,
                                u = t + i + s,
                                f = t + n + s;
                            h(l, c, u, f, e, r, o, n, i)
                        }
                    }
                }

                function l(e, t, n) {
                    L.vertices.push(new i.Vector3(e, t, n))
                }

                function c(e, t, n) {
                    e += R, t += R, n += R, L.faces.push(new i.Face3(e, t, n, null, null, S));
                    var r = C.generateTopUV(L, e, t, n);
                    L.faceVertexUvs[0].push(r)
                }

                function h(e, t, n, r, o, a, s, l, c) {
                    e += R, t += R, n += R, r += R, L.faces.push(new i.Face3(e, t, r, null, null, T)), L.faces.push(new i.Face3(t, n, r, null, null, T));
                    var h = C.generateSideWallUV(L, e, t, n, r);
                    L.faceVertexUvs[0].push([h[0], h[1], h[3]]), L.faceVertexUvs[0].push([h[1], h[2], h[3]])
                }
                var u, f, d, p, m, v = void 0 !== t.amount ? t.amount : 100,
                    g = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                    y = void 0 !== t.bevelSize ? t.bevelSize : g - 2,
                    x = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                    w = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
                    _ = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    b = void 0 !== t.steps ? t.steps : 1,
                    E = t.extrudePath,
                    M = !1,
                    S = t.material,
                    T = t.extrudeMaterial,
                    C = void 0 !== t.UVGenerator ? t.UVGenerator : i.ExtrudeGeometry.WorldUVGenerator;
                E && (u = E.getSpacedPoints(b), M = !0, w = !1, f = void 0 !== t.frames ? t.frames : new i.TubeGeometry.FrenetFrames(E, b, !1), d = new i.Vector3, p = new i.Vector3, m = new i.Vector3), w || (x = 0, g = 0, y = 0);
                var A, P, D, L = this,
                    R = this.vertices.length,
                    O = e.extractPoints(_),
                    N = O.shape,
                    U = O.holes,
                    F = !i.Shape.Utils.isClockWise(N);
                if (F) {
                    for (N = N.reverse(), P = 0, D = U.length; D > P; P++) A = U[P], i.Shape.Utils.isClockWise(A) && (U[P] = A.reverse());
                    F = !1
                }
                var k = i.Shape.Utils.triangulateShape(N, U),
                    H = N;
                for (P = 0, D = U.length; D > P; P++) A = U[P], N = N.concat(A);
                for (var I, V, z, B, j, G, W = N.length, X = k.length, q = [], K = 0, Y = H.length, $ = Y - 1, J = K + 1; Y > K; K++, $++, J++) $ === Y && ($ = 0), J === Y && (J = 0), q[K] = r(H[K], H[$], H[J]);
                var Z, Q = [],
                    ee = q.concat();
                for (P = 0, D = U.length; D > P; P++) {
                    for (A = U[P], Z = [], K = 0, Y = A.length, $ = Y - 1, J = K + 1; Y > K; K++, $++, J++) $ === Y && ($ = 0), J === Y && (J = 0), Z[K] = r(A[K], A[$], A[J]);
                    Q.push(Z), ee = ee.concat(Z)
                }
                for (I = 0; x > I; I++) {
                    for (z = I / x, B = g * (1 - z), V = y * Math.sin(z * Math.PI / 2), K = 0, Y = H.length; Y > K; K++) j = n(H[K], q[K], V), l(j.x, j.y, -B);
                    for (P = 0, D = U.length; D > P; P++)
                        for (A = U[P], Z = Q[P], K = 0, Y = A.length; Y > K; K++) j = n(A[K], Z[K], V), l(j.x, j.y, -B)
                }
                for (V = y, K = 0; W > K; K++) j = w ? n(N[K], ee[K], V) : N[K], M ? (p.copy(f.normals[0]).multiplyScalar(j.x), d.copy(f.binormals[0]).multiplyScalar(j.y), m.copy(u[0]).add(p).add(d), l(m.x, m.y, m.z)) : l(j.x, j.y, 0);
                var te;
                for (te = 1; b >= te; te++)
                    for (K = 0; W > K; K++) j = w ? n(N[K], ee[K], V) : N[K], M ? (p.copy(f.normals[te]).multiplyScalar(j.x), d.copy(f.binormals[te]).multiplyScalar(j.y), m.copy(u[te]).add(p).add(d), l(m.x, m.y, m.z)) : l(j.x, j.y, v / b * te);
                for (I = x - 1; I >= 0; I--) {
                    for (z = I / x, B = g * (1 - z), V = y * Math.sin(z * Math.PI / 2), K = 0, Y = H.length; Y > K; K++) j = n(H[K], q[K], V), l(j.x, j.y, v + B);
                    for (P = 0, D = U.length; D > P; P++)
                        for (A = U[P], Z = Q[P], K = 0, Y = A.length; Y > K; K++) j = n(A[K], Z[K], V), M ? l(j.x, j.y + u[b - 1].y, u[b - 1].x + B) : l(j.x, j.y, v + B)
                }
                o(), a()
            }, i.ExtrudeGeometry.WorldUVGenerator = {
                generateTopUV: function(e, t, n, r) {
                    var o = e.vertices,
                        a = o[t],
                        s = o[n],
                        l = o[r];
                    return [new i.Vector2(a.x, a.y), new i.Vector2(s.x, s.y), new i.Vector2(l.x, l.y)]
                },
                generateSideWallUV: function(e, t, n, r, o) {
                    var a = e.vertices,
                        s = a[t],
                        l = a[n],
                        c = a[r],
                        h = a[o];
                    return Math.abs(s.y - l.y) < .01 ? [new i.Vector2(s.x, 1 - s.z), new i.Vector2(l.x, 1 - l.z), new i.Vector2(c.x, 1 - c.z), new i.Vector2(h.x, 1 - h.z)] : [new i.Vector2(s.y, 1 - s.z), new i.Vector2(l.y, 1 - l.z), new i.Vector2(c.y, 1 - c.z), new i.Vector2(h.y, 1 - h.z)]
                }
            }, i.ShapeGeometry = function(e, t) {
                i.Geometry.call(this), this.type = "ShapeGeometry", e instanceof Array == !1 && (e = [e]), this.addShapeList(e, t), this.computeFaceNormals()
            }, i.ShapeGeometry.prototype = Object.create(i.Geometry.prototype), i.ShapeGeometry.prototype.constructor = i.ShapeGeometry, i.ShapeGeometry.prototype.addShapeList = function(e, t) {
                for (var n = 0, i = e.length; i > n; n++) this.addShape(e[n], t);
                return this
            }, i.ShapeGeometry.prototype.addShape = function(e, t) {
                void 0 === t && (t = {});
                var n, r, o, a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    s = t.material,
                    l = void 0 === t.UVGenerator ? i.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
                    c = this.vertices.length,
                    h = e.extractPoints(a),
                    u = h.shape,
                    f = h.holes,
                    d = !i.Shape.Utils.isClockWise(u);
                if (d) {
                    for (u = u.reverse(), n = 0, r = f.length; r > n; n++) o = f[n], i.Shape.Utils.isClockWise(o) && (f[n] = o.reverse());
                    d = !1
                }
                var p = i.Shape.Utils.triangulateShape(u, f);
                for (n = 0, r = f.length; r > n; n++) o = f[n], u = u.concat(o);
                var m, v, g = u.length,
                    y = p.length;
                for (n = 0; g > n; n++) m = u[n], this.vertices.push(new i.Vector3(m.x, m.y, 0));
                for (n = 0; y > n; n++) {
                    v = p[n];
                    var x = v[0] + c,
                        w = v[1] + c,
                        _ = v[2] + c;
                    this.faces.push(new i.Face3(x, w, _, null, null, s)), this.faceVertexUvs[0].push(l.generateTopUV(this, x, w, _))
                }
            }, i.LatheGeometry = function(e, t, n, r) {
                i.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, t = t || 12, n = n || 0, r = r || 2 * Math.PI;
                for (var o = 1 / (e.length - 1), a = 1 / t, s = 0, l = t; l >= s; s++)
                    for (var c = n + s * a * r, h = Math.cos(c), u = Math.sin(c), f = 0, d = e.length; d > f; f++) {
                        var p = e[f],
                            m = new i.Vector3;
                        m.x = h * p.x - u * p.y, m.y = u * p.x + h * p.y, m.z = p.z, this.vertices.push(m)
                    }
                for (var v = e.length, s = 0, l = t; l > s; s++)
                    for (var f = 0, d = e.length - 1; d > f; f++) {
                        var g = f + v * s,
                            y = g,
                            x = g + v,
                            h = g + 1 + v,
                            w = g + 1,
                            _ = s * a,
                            b = f * o,
                            E = _ + a,
                            M = b + o;
                        this.faces.push(new i.Face3(y, x, w)), this.faceVertexUvs[0].push([new i.Vector2(_, b), new i.Vector2(E, b), new i.Vector2(_, M)]), this.faces.push(new i.Face3(x, h, w)), this.faceVertexUvs[0].push([new i.Vector2(E, b), new i.Vector2(E, M), new i.Vector2(_, M)])
                    }
                this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
            }, i.LatheGeometry.prototype = Object.create(i.Geometry.prototype), i.LatheGeometry.prototype.constructor = i.LatheGeometry, i.PlaneGeometry = function(e, t, n, r) {
                console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint."), i.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                }, this.fromBufferGeometry(new i.PlaneBufferGeometry(e, t, n, r))
            }, i.PlaneGeometry.prototype = Object.create(i.Geometry.prototype), i.PlaneGeometry.prototype.constructor = i.PlaneGeometry, i.PlaneBufferGeometry = function(e, t, n, r) {
                i.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                };
                for (var o = e / 2, a = t / 2, s = n || 1, l = r || 1, c = s + 1, h = l + 1, u = e / s, f = t / l, d = new Float32Array(c * h * 3), p = new Float32Array(c * h * 3), m = new Float32Array(c * h * 2), v = 0, g = 0, y = 0; h > y; y++)
                    for (var x = y * f - a, w = 0; c > w; w++) {
                        var _ = w * u - o;
                        d[v] = _, d[v + 1] = -x, p[v + 2] = 1, m[g] = w / s, m[g + 1] = 1 - y / l, v += 3, g += 2
                    }
                v = 0;
                for (var b = new(d.length / 3 > 65535 ? Uint32Array : Uint16Array)(s * l * 6), y = 0; l > y; y++)
                    for (var w = 0; s > w; w++) {
                        var E = w + c * y,
                            M = w + c * (y + 1),
                            S = w + 1 + c * (y + 1),
                            T = w + 1 + c * y;
                        b[v] = E, b[v + 1] = M, b[v + 2] = T, b[v + 3] = M, b[v + 4] = S, b[v + 5] = T, v += 6
                    }
                this.addAttribute("index", new i.BufferAttribute(b, 1)), this.addAttribute("position", new i.BufferAttribute(d, 3)), this.addAttribute("normal", new i.BufferAttribute(p, 3)), this.addAttribute("uv", new i.BufferAttribute(m, 2))
            }, i.PlaneBufferGeometry.prototype = Object.create(i.BufferGeometry.prototype), i.PlaneBufferGeometry.prototype.constructor = i.PlaneBufferGeometry, i.RingGeometry = function(e, t, n, r, o, a) {
                i.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: o,
                    thetaLength: a
                }, e = e || 0, t = t || 50, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 8;
                var s, l, c = [],
                    h = e,
                    u = (t - e) / r;
                for (s = 0; r + 1 > s; s++) {
                    for (l = 0; n + 1 > l; l++) {
                        var f = new i.Vector3,
                            d = o + l / n * a;
                        f.x = h * Math.cos(d), f.y = h * Math.sin(d), this.vertices.push(f), c.push(new i.Vector2((f.x / t + 1) / 2, (f.y / t + 1) / 2))
                    }
                    h += u
                }
                var p = new i.Vector3(0, 0, 1);
                for (s = 0; r > s; s++) {
                    var m = s * (n + 1);
                    for (l = 0; n > l; l++) {
                        var d = l + m,
                            v = d,
                            g = d + n + 1,
                            y = d + n + 2;
                        this.faces.push(new i.Face3(v, g, y, [p.clone(), p.clone(), p.clone()])), this.faceVertexUvs[0].push([c[v].clone(), c[g].clone(), c[y].clone()]), v = d, g = d + n + 2, y = d + 1, this.faces.push(new i.Face3(v, g, y, [p.clone(), p.clone(), p.clone()])), this.faceVertexUvs[0].push([c[v].clone(), c[g].clone(), c[y].clone()])
                    }
                }
                this.computeFaceNormals(), this.boundingSphere = new i.Sphere(new i.Vector3, h)
            }, i.RingGeometry.prototype = Object.create(i.Geometry.prototype), i.RingGeometry.prototype.constructor = i.RingGeometry, i.SphereGeometry = function(e, t, n, r, o, a, s) {
                i.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: o,
                    thetaStart: a,
                    thetaLength: s
                }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
                var l, c, h = [],
                    u = [];
                for (c = 0; n >= c; c++) {
                    var f = [],
                        d = [];
                    for (l = 0; t >= l; l++) {
                        var p = l / t,
                            m = c / n,
                            v = new i.Vector3;
                        v.x = -e * Math.cos(r + p * o) * Math.sin(a + m * s), v.y = e * Math.cos(a + m * s), v.z = e * Math.sin(r + p * o) * Math.sin(a + m * s), this.vertices.push(v), f.push(this.vertices.length - 1), d.push(new i.Vector2(p, 1 - m))
                    }
                    h.push(f), u.push(d)
                }
                for (c = 0; n > c; c++)
                    for (l = 0; t > l; l++) {
                        var g = h[c][l + 1],
                            y = h[c][l],
                            x = h[c + 1][l],
                            w = h[c + 1][l + 1],
                            _ = this.vertices[g].clone().normalize(),
                            b = this.vertices[y].clone().normalize(),
                            E = this.vertices[x].clone().normalize(),
                            M = this.vertices[w].clone().normalize(),
                            S = u[c][l + 1].clone(),
                            T = u[c][l].clone(),
                            C = u[c + 1][l].clone(),
                            A = u[c + 1][l + 1].clone();
                        Math.abs(this.vertices[g].y) === e ? (S.x = (S.x + T.x) / 2, this.faces.push(new i.Face3(g, x, w, [_, E, M])), this.faceVertexUvs[0].push([S, C, A])) : Math.abs(this.vertices[x].y) === e ? (C.x = (C.x + A.x) / 2, this.faces.push(new i.Face3(g, y, x, [_, b, E])), this.faceVertexUvs[0].push([S, T, C])) : (this.faces.push(new i.Face3(g, y, w, [_, b, M])), this.faceVertexUvs[0].push([S, T, A]), this.faces.push(new i.Face3(y, x, w, [b.clone(), E, M.clone()])), this.faceVertexUvs[0].push([T.clone(), C, A.clone()]))
                    }
                this.computeFaceNormals(), this.boundingSphere = new i.Sphere(new i.Vector3, e)
            }, i.SphereGeometry.prototype = Object.create(i.Geometry.prototype), i.SphereGeometry.prototype.constructor = i.SphereGeometry, i.TextGeometry = function(e, t) {
                t = t || {};
                var n = i.FontUtils.generateShapes(e, t);
                t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), i.ExtrudeGeometry.call(this, n, t), this.type = "TextGeometry"
            }, i.TextGeometry.prototype = Object.create(i.ExtrudeGeometry.prototype), i.TextGeometry.prototype.constructor = i.TextGeometry, i.TorusGeometry = function(e, t, n, r, o) {
                i.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: o
                }, e = e || 100, t = t || 40, n = n || 8, r = r || 6, o = o || 2 * Math.PI;
                for (var a = new i.Vector3, s = [], l = [], c = 0; n >= c; c++)
                    for (var h = 0; r >= h; h++) {
                        var u = h / r * o,
                            f = c / n * Math.PI * 2;
                        a.x = e * Math.cos(u), a.y = e * Math.sin(u);
                        var d = new i.Vector3;
                        d.x = (e + t * Math.cos(f)) * Math.cos(u), d.y = (e + t * Math.cos(f)) * Math.sin(u), d.z = t * Math.sin(f), this.vertices.push(d), s.push(new i.Vector2(h / r, c / n)), l.push(d.clone().sub(a).normalize())
                    }
                for (var c = 1; n >= c; c++)
                    for (var h = 1; r >= h; h++) {
                        var p = (r + 1) * c + h - 1,
                            m = (r + 1) * (c - 1) + h - 1,
                            v = (r + 1) * (c - 1) + h,
                            g = (r + 1) * c + h,
                            y = new i.Face3(p, m, g, [l[p].clone(), l[m].clone(), l[g].clone()]);
                        this.faces.push(y), this.faceVertexUvs[0].push([s[p].clone(), s[m].clone(), s[g].clone()]), y = new i.Face3(m, v, g, [l[m].clone(), l[v].clone(), l[g].clone()]), this.faces.push(y), this.faceVertexUvs[0].push([s[m].clone(), s[v].clone(), s[g].clone()])
                    }
                this.computeFaceNormals()
            }, i.TorusGeometry.prototype = Object.create(i.Geometry.prototype), i.TorusGeometry.prototype.constructor = i.TorusGeometry, i.TorusKnotGeometry = function(e, t, n, r, o, a, s) {
                function l(e, t, n, r, o) {
                    var a = Math.cos(e),
                        s = Math.sin(e),
                        l = t / n * e,
                        c = Math.cos(l),
                        h = r * (2 + c) * .5 * a,
                        u = r * (2 + c) * s * .5,
                        f = o * r * Math.sin(l) * .5;
                    return new i.Vector3(h, u, f)
                }
                i.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    p: o,
                    q: a,
                    heightScale: s
                }, e = e || 100, t = t || 40, n = n || 64, r = r || 8, o = o || 2, a = a || 3, s = s || 1;
                for (var c = new Array(n), h = new i.Vector3, u = new i.Vector3, f = new i.Vector3, d = 0; n > d; ++d) {
                    c[d] = new Array(r);
                    var p = d / n * 2 * o * Math.PI,
                        m = l(p, a, o, e, s),
                        v = l(p + .01, a, o, e, s);
                    h.subVectors(v, m), u.addVectors(v, m), f.crossVectors(h, u), u.crossVectors(f, h), f.normalize(), u.normalize();
                    for (var g = 0; r > g; ++g) {
                        var y = g / r * 2 * Math.PI,
                            x = -t * Math.cos(y),
                            w = t * Math.sin(y),
                            _ = new i.Vector3;
                        _.x = m.x + x * u.x + w * f.x, _.y = m.y + x * u.y + w * f.y, _.z = m.z + x * u.z + w * f.z, c[d][g] = this.vertices.push(_) - 1
                    }
                }
                for (var d = 0; n > d; ++d)
                    for (var g = 0; r > g; ++g) {
                        var b = (d + 1) % n,
                            E = (g + 1) % r,
                            M = c[d][g],
                            S = c[b][g],
                            T = c[b][E],
                            C = c[d][E],
                            A = new i.Vector2(d / n, g / r),
                            P = new i.Vector2((d + 1) / n, g / r),
                            D = new i.Vector2((d + 1) / n, (g + 1) / r),
                            L = new i.Vector2(d / n, (g + 1) / r);
                        this.faces.push(new i.Face3(M, S, C)), this.faceVertexUvs[0].push([A, P, L]), this.faces.push(new i.Face3(S, T, C)), this.faceVertexUvs[0].push([P.clone(), D, L.clone()])
                    }
                this.computeFaceNormals(), this.computeVertexNormals()
            }, i.TorusKnotGeometry.prototype = Object.create(i.Geometry.prototype), i.TorusKnotGeometry.prototype.constructor = i.TorusKnotGeometry, i.TubeGeometry = function(e, t, n, r, o, a) {
                function s(e, t, n) {
                    return D.vertices.push(new i.Vector3(e, t, n)) - 1
                }
                i.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    segments: t,
                    radius: n,
                    radialSegments: r,
                    closed: o
                }, t = t || 64, n = n || 1, r = r || 8, o = o || !1, a = a || i.TubeGeometry.NoTaper;
                var l, c, h, u, f, d, p, m, v, g, y, x, w, _, b, E, M, S, T, C, A, P = [],
                    D = this,
                    L = t + 1,
                    R = new i.Vector3,
                    O = new i.TubeGeometry.FrenetFrames(e, t, o),
                    N = O.tangents,
                    U = O.normals,
                    F = O.binormals;
                for (this.tangents = N, this.normals = U, this.binormals = F, g = 0; L > g; g++)
                    for (P[g] = [], u = g / (L - 1), v = e.getPointAt(u), l = N[g], c = U[g], h = F[g], d = n * a(u), y = 0; r > y; y++) f = y / r * 2 * Math.PI, p = -d * Math.cos(f), m = d * Math.sin(f), R.copy(v), R.x += p * c.x + m * h.x, R.y += p * c.y + m * h.y, R.z += p * c.z + m * h.z, P[g][y] = s(R.x, R.y, R.z);
                for (g = 0; t > g; g++)
                    for (y = 0; r > y; y++) x = o ? (g + 1) % t : g + 1, w = (y + 1) % r, _ = P[g][y], b = P[x][y], E = P[x][w], M = P[g][w], S = new i.Vector2(g / t, y / r), T = new i.Vector2((g + 1) / t, y / r), C = new i.Vector2((g + 1) / t, (y + 1) / r), A = new i.Vector2(g / t, (y + 1) / r), this.faces.push(new i.Face3(_, b, M)), this.faceVertexUvs[0].push([S, T, A]), this.faces.push(new i.Face3(b, E, M)), this.faceVertexUvs[0].push([T.clone(), C, A.clone()]);
                this.computeFaceNormals(), this.computeVertexNormals()
            }, i.TubeGeometry.prototype = Object.create(i.Geometry.prototype), i.TubeGeometry.prototype.constructor = i.TubeGeometry, i.TubeGeometry.NoTaper = function(e) {
                return 1
            }, i.TubeGeometry.SinusoidalTaper = function(e) {
                return Math.sin(Math.PI * e)
            }, i.TubeGeometry.FrenetFrames = function(e, t, n) {
                function r() {
                    p[0] = new i.Vector3, m[0] = new i.Vector3, a = Number.MAX_VALUE, s = Math.abs(d[0].x), l = Math.abs(d[0].y), c = Math.abs(d[0].z), a >= s && (a = s, f.set(1, 0, 0)), a >= l && (a = l, f.set(0, 1, 0)), a >= c && f.set(0, 0, 1), v.crossVectors(d[0], f).normalize(), p[0].crossVectors(d[0], v), m[0].crossVectors(d[0], p[0])
                }
                var o, a, s, l, c, h, u, f = new i.Vector3,
                    d = [],
                    p = [],
                    m = [],
                    v = new i.Vector3,
                    g = new i.Matrix4,
                    y = t + 1,
                    x = 1e-4;
                for (this.tangents = d, this.normals = p, this.binormals = m, h = 0; y > h; h++) u = h / (y - 1), d[h] = e.getTangentAt(u), d[h].normalize();
                for (r(), h = 1; y > h; h++) p[h] = p[h - 1].clone(), m[h] = m[h - 1].clone(), v.crossVectors(d[h - 1], d[h]), v.length() > x && (v.normalize(), o = Math.acos(i.Math.clamp(d[h - 1].dot(d[h]), -1, 1)), p[h].applyMatrix4(g.makeRotationAxis(v, o))), m[h].crossVectors(d[h], p[h]);
                if (n)
                    for (o = Math.acos(i.Math.clamp(p[0].dot(p[y - 1]), -1, 1)), o /= y - 1, d[0].dot(v.crossVectors(p[0], p[y - 1])) > 0 && (o = -o), h = 1; y > h; h++) p[h].applyMatrix4(g.makeRotationAxis(d[h], o * h)), m[h].crossVectors(d[h], p[h])
            }, i.PolyhedronGeometry = function(e, t, n, r) {
                function o(e) {
                    var t = e.normalize().clone();
                    t.index = u.vertices.push(t) - 1;
                    var n = l(e) / 2 / Math.PI + .5,
                        r = c(e) / Math.PI + .5;
                    return t.uv = new i.Vector2(n, 1 - r), t
                }

                function a(e, t, n) {
                    var r = new i.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
                    u.faces.push(r), w.copy(e).add(t).add(n).divideScalar(3);
                    var o = l(w);
                    u.faceVertexUvs[0].push([h(e.uv, e, o), h(t.uv, t, o), h(n.uv, n, o)])
                }

                function s(e, t) {
                    for (var n = Math.pow(2, t), i = o(u.vertices[e.a]), r = o(u.vertices[e.b]), s = o(u.vertices[e.c]), l = [], c = 0; n >= c; c++) {
                        l[c] = [];
                        for (var h = o(i.clone().lerp(s, c / n)), f = o(r.clone().lerp(s, c / n)), d = n - c, p = 0; d >= p; p++) 0 == p && c == n ? l[c][p] = h : l[c][p] = o(h.clone().lerp(f, p / d))
                    }
                    for (var c = 0; n > c; c++)
                        for (var p = 0; 2 * (n - c) - 1 > p; p++) {
                            var m = Math.floor(p / 2);
                            p % 2 == 0 ? a(l[c][m + 1], l[c + 1][m], l[c][m]) : a(l[c][m + 1], l[c + 1][m + 1], l[c + 1][m])
                        }
                }

                function l(e) {
                    return Math.atan2(e.z, -e.x)
                }

                function c(e) {
                    return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
                }

                function h(e, t, n) {
                    return 0 > n && 1 === e.x && (e = new i.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new i.Vector2(n / 2 / Math.PI + .5, e.y)), e.clone()
                }
                i.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                }, n = n || 1, r = r || 0;
                for (var u = this, f = 0, d = e.length; d > f; f += 3) o(new i.Vector3(e[f], e[f + 1], e[f + 2]));
                for (var p = this.vertices, m = [], f = 0, v = 0, d = t.length; d > f; f += 3, v++) {
                    var g = p[t[f]],
                        y = p[t[f + 1]],
                        x = p[t[f + 2]];
                    m[v] = new i.Face3(g.index, y.index, x.index, [g.clone(), y.clone(), x.clone()])
                }
                for (var w = new i.Vector3, f = 0, d = m.length; d > f; f++) s(m[f], r);
                for (var f = 0, d = this.faceVertexUvs[0].length; d > f; f++) {
                    var _ = this.faceVertexUvs[0][f],
                        b = _[0].x,
                        E = _[1].x,
                        M = _[2].x,
                        S = Math.max(b, Math.max(E, M)),
                        T = Math.min(b, Math.min(E, M));
                    S > .9 && .1 > T && (.2 > b && (_[0].x += 1), .2 > E && (_[1].x += 1), .2 > M && (_[2].x += 1))
                }
                for (var f = 0, d = this.vertices.length; d > f; f++) this.vertices[f].multiplyScalar(n);
                this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new i.Sphere(new i.Vector3, n)
            }, i.PolyhedronGeometry.prototype = Object.create(i.Geometry.prototype), i.PolyhedronGeometry.prototype.constructor = i.PolyhedronGeometry, i.DodecahedronGeometry = function(e, t) {
                this.parameters = {
                    radius: e,
                    detail: t
                };
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r],
                    a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                i.PolyhedronGeometry.call(this, o, a, e, t)
            }, i.DodecahedronGeometry.prototype = Object.create(i.Geometry.prototype), i.DodecahedronGeometry.prototype.constructor = i.DodecahedronGeometry, i.IcosahedronGeometry = function(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
                    o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                i.PolyhedronGeometry.call(this, r, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, i.IcosahedronGeometry.prototype = Object.create(i.Geometry.prototype), i.IcosahedronGeometry.prototype.constructor = i.IcosahedronGeometry, i.OctahedronGeometry = function(e, t) {
                this.parameters = {
                    radius: e,
                    detail: t
                };
                var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                    r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                i.PolyhedronGeometry.call(this, n, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, i.OctahedronGeometry.prototype = Object.create(i.Geometry.prototype), i.OctahedronGeometry.prototype.constructor = i.OctahedronGeometry, i.TetrahedronGeometry = function(e, t) {
                var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                    r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                i.PolyhedronGeometry.call(this, n, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, i.TetrahedronGeometry.prototype = Object.create(i.Geometry.prototype), i.TetrahedronGeometry.prototype.constructor = i.TetrahedronGeometry, i.ParametricGeometry = function(e, t, n) {
                i.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                var r, o, a, s, l, c = this.vertices,
                    h = this.faces,
                    u = this.faceVertexUvs[0],
                    f = t + 1;
                for (r = 0; n >= r; r++)
                    for (l = r / n, o = 0; t >= o; o++) s = o / t, a = e(s, l), c.push(a);
                var d, p, m, v, g, y, x, w;
                for (r = 0; n > r; r++)
                    for (o = 0; t > o; o++) d = r * f + o, p = r * f + o + 1, m = (r + 1) * f + o + 1, v = (r + 1) * f + o, g = new i.Vector2(o / t, r / n), y = new i.Vector2((o + 1) / t, r / n), x = new i.Vector2((o + 1) / t, (r + 1) / n), w = new i.Vector2(o / t, (r + 1) / n), h.push(new i.Face3(d, p, v)), u.push([g, y, w]), h.push(new i.Face3(p, m, v)), u.push([y.clone(), x, w.clone()]);
                this.computeFaceNormals(), this.computeVertexNormals()
            }, i.ParametricGeometry.prototype = Object.create(i.Geometry.prototype), i.ParametricGeometry.prototype.constructor = i.ParametricGeometry, i.AxisHelper = function(e) {
                e = e || 1;
                var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]),
                    n = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]),
                    r = new i.BufferGeometry;
                r.addAttribute("position", new i.BufferAttribute(t, 3)), r.addAttribute("color", new i.BufferAttribute(n, 3));
                var o = new i.LineBasicMaterial({
                    vertexColors: i.VertexColors
                });
                i.Line.call(this, r, o, i.LinePieces)
            }, i.AxisHelper.prototype = Object.create(i.Line.prototype), i.AxisHelper.prototype.constructor = i.AxisHelper, i.ArrowHelper = function() {
                var e = new i.Geometry;
                e.vertices.push(new i.Vector3(0, 0, 0), new i.Vector3(0, 1, 0));
                var t = new i.CylinderGeometry(0, .5, 1, 5, 1);
                return t.applyMatrix((new i.Matrix4).makeTranslation(0, -.5, 0)),
                    function(n, r, o, a, s, l) {
                        i.Object3D.call(this), void 0 === a && (a = 16776960), void 0 === o && (o = 1), void 0 === s && (s = .2 * o), void 0 === l && (l = .2 * s), this.position.copy(r), this.line = new i.Line(e, new i.LineBasicMaterial({
                            color: a
                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new i.Mesh(t, new i.MeshBasicMaterial({
                            color: a
                        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(n), this.setLength(o, s, l)
                    }
            }(), i.ArrowHelper.prototype = Object.create(i.Object3D.prototype), i.ArrowHelper.prototype.constructor = i.ArrowHelper, i.ArrowHelper.prototype.setDirection = function() {
                var e, t = new i.Vector3;
                return function(n) {
                    n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
                }
            }(), i.ArrowHelper.prototype.setLength = function(e, t, n) {
                void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, e - t, 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }, i.ArrowHelper.prototype.setColor = function(e) {
                this.line.material.color.set(e), this.cone.material.color.set(e)
            }, i.BoxHelper = function(e) {
                var t = new i.BufferGeometry;
                t.addAttribute("position", new i.BufferAttribute(new Float32Array(72), 3)), i.Line.call(this, t, new i.LineBasicMaterial({
                    color: 16776960
                }), i.LinePieces), void 0 !== e && this.update(e)
            }, i.BoxHelper.prototype = Object.create(i.Line.prototype), i.BoxHelper.prototype.constructor = i.BoxHelper, i.BoxHelper.prototype.update = function(e) {
                var t = e.geometry;
                null === t.boundingBox && t.computeBoundingBox();
                var n = t.boundingBox.min,
                    i = t.boundingBox.max,
                    r = this.geometry.attributes.position.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = n.x, r[4] = i.y, r[5] = i.z, r[6] = n.x, r[7] = i.y, r[8] = i.z, r[9] = n.x, r[10] = n.y, r[11] = i.z, r[12] = n.x, r[13] = n.y, r[14] = i.z, r[15] = i.x, r[16] = n.y, r[17] = i.z, r[18] = i.x, r[19] = n.y, r[20] = i.z, r[21] = i.x, r[22] = i.y, r[23] = i.z, r[24] = i.x, r[25] = i.y, r[26] = n.z, r[27] = n.x, r[28] = i.y, r[29] = n.z, r[30] = n.x, r[31] = i.y, r[32] = n.z, r[33] = n.x, r[34] = n.y, r[35] = n.z, r[36] = n.x, r[37] = n.y, r[38] = n.z, r[39] = i.x, r[40] = n.y, r[41] = n.z, r[42] = i.x, r[43] = n.y, r[44] = n.z, r[45] = i.x, r[46] = i.y, r[47] = n.z, r[48] = i.x, r[49] = i.y, r[50] = i.z, r[51] = i.x, r[52] = i.y, r[53] = n.z, r[54] = n.x, r[55] = i.y, r[56] = i.z, r[57] = n.x, r[58] = i.y, r[59] = n.z, r[60] = n.x, r[61] = n.y, r[62] = i.z, r[63] = n.x, r[64] = n.y, r[65] = n.z, r[66] = i.x, r[67] = n.y, r[68] = i.z, r[69] = i.x, r[70] = n.y, r[71] = n.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }, i.BoundingBoxHelper = function(e, t) {
                var n = void 0 !== t ? t : 8947848;
                this.object = e, this.box = new i.Box3, i.Mesh.call(this, new i.BoxGeometry(1, 1, 1), new i.MeshBasicMaterial({
                    color: n,
                    wireframe: !0
                }))
            }, i.BoundingBoxHelper.prototype = Object.create(i.Mesh.prototype), i.BoundingBoxHelper.prototype.constructor = i.BoundingBoxHelper, i.BoundingBoxHelper.prototype.update = function() {
                this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
            }, i.CameraHelper = function(e) {
                function t(e, t, i) {
                    n(e, i), n(t, i)
                }

                function n(e, t) {
                    r.vertices.push(new i.Vector3), r.colors.push(new i.Color(t)), void 0 === a[e] && (a[e] = []), a[e].push(r.vertices.length - 1)
                }
                var r = new i.Geometry,
                    o = new i.LineBasicMaterial({
                        color: 16777215,
                        vertexColors: i.FaceColors
                    }),
                    a = {},
                    s = 16755200,
                    l = 16711680,
                    c = 43775,
                    h = 16777215,
                    u = 3355443;
                t("n1", "n2", s), t("n2", "n4", s), t("n4", "n3", s), t("n3", "n1", s), t("f1", "f2", s), t("f2", "f4", s), t("f4", "f3", s), t("f3", "f1", s), t("n1", "f1", s), t("n2", "f2", s), t("n3", "f3", s), t("n4", "f4", s), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), t("p", "n4", l), t("u1", "u2", c), t("u2", "u3", c), t("u3", "u1", c), t("c", "t", h), t("p", "c", u), t("cn1", "cn2", u), t("cn3", "cn4", u), t("cf1", "cf2", u), t("cf3", "cf4", u), i.Line.call(this, r, o, i.LinePieces), this.camera = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
            }, i.CameraHelper.prototype = Object.create(i.Line.prototype), i.CameraHelper.prototype.constructor = i.CameraHelper, i.CameraHelper.prototype.update = function() {
                var e, t, n = new i.Vector3,
                    r = new i.Camera,
                    o = function(i, o, a, s) {
                        n.set(o, a, s).unproject(r);
                        var l = t[i];
                        if (void 0 !== l)
                            for (var c = 0, h = l.length; h > c; c++) e.vertices[l[c]].copy(n)
                    };
                return function() {
                    e = this.geometry, t = this.pointMap;
                    var n = 1,
                        i = 1;
                    r.projectionMatrix.copy(this.camera.projectionMatrix), o("c", 0, 0, -1), o("t", 0, 0, 1), o("n1", -n, -i, -1), o("n2", n, -i, -1), o("n3", -n, i, -1), o("n4", n, i, -1), o("f1", -n, -i, 1), o("f2", n, -i, 1), o("f3", -n, i, 1), o("f4", n, i, 1), o("u1", .7 * n, 1.1 * i, -1), o("u2", .7 * -n, 1.1 * i, -1), o("u3", 0, 2 * i, -1), o("cf1", -n, 0, 1), o("cf2", n, 0, 1), o("cf3", 0, -i, 1), o("cf4", 0, i, 1), o("cn1", -n, 0, -1), o("cn2", n, 0, -1), o("cn3", 0, -i, -1), o("cn4", 0, i, -1), e.verticesNeedUpdate = !0
                }
            }(), i.DirectionalLightHelper = function(e, t) {
                i.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
                var n = new i.Geometry;
                n.vertices.push(new i.Vector3(-t, t, 0), new i.Vector3(t, t, 0), new i.Vector3(t, -t, 0), new i.Vector3(-t, -t, 0), new i.Vector3(-t, t, 0));
                var r = new i.LineBasicMaterial({
                    fog: !1
                });
                r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new i.Line(n, r), this.add(this.lightPlane), n = new i.Geometry, n.vertices.push(new i.Vector3, new i.Vector3), r = new i.LineBasicMaterial({
                    fog: !1
                }), r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new i.Line(n, r), this.add(this.targetLine), this.update()
            }, i.DirectionalLightHelper.prototype = Object.create(i.Object3D.prototype), i.DirectionalLightHelper.prototype.constructor = i.DirectionalLightHelper, i.DirectionalLightHelper.prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, i.DirectionalLightHelper.prototype.update = function() {
                var e = new i.Vector3,
                    t = new i.Vector3,
                    n = new i.Vector3;
                return function() {
                    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(n), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
                }
            }(), i.EdgesHelper = function(e, t, n) {
                var r = void 0 !== t ? t : 16777215;
                n = void 0 !== n ? n : 1;
                var o, a = Math.cos(i.Math.degToRad(n)),
                    s = [0, 0],
                    l = {},
                    c = function(e, t) {
                        return e - t
                    },
                    h = ["a", "b", "c"],
                    u = new i.BufferGeometry;
                e.geometry instanceof i.BufferGeometry ? (o = new i.Geometry, o.fromBufferGeometry(e.geometry)) : o = e.geometry.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var f = o.vertices, d = o.faces, p = 0, m = 0, v = d.length; v > m; m++)
                    for (var g = d[m], y = 0; 3 > y; y++) {
                        s[0] = g[h[y]], s[1] = g[h[(y + 1) % 3]], s.sort(c);
                        var x = s.toString();
                        void 0 === l[x] ? (l[x] = {
                            vert1: s[0],
                            vert2: s[1],
                            face1: m,
                            face2: void 0
                        }, p++) : l[x].face2 = m
                    }
                var w = new Float32Array(2 * p * 3),
                    _ = 0;
                for (var x in l) {
                    var b = l[x];
                    if (void 0 === b.face2 || d[b.face1].normal.dot(d[b.face2].normal) <= a) {
                        var E = f[b.vert1];
                        w[_++] = E.x, w[_++] = E.y, w[_++] = E.z, E = f[b.vert2], w[_++] = E.x, w[_++] = E.y, w[_++] = E.z
                    }
                }
                u.addAttribute("position", new i.BufferAttribute(w, 3)), i.Line.call(this, u, new i.LineBasicMaterial({
                    color: r
                }), i.LinePieces), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }, i.EdgesHelper.prototype = Object.create(i.Line.prototype), i.EdgesHelper.prototype.constructor = i.EdgesHelper, i.FaceNormalsHelper = function(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                for (var o = void 0 !== n ? n : 16776960, a = void 0 !== r ? r : 1, s = new i.Geometry, l = this.object.geometry.faces, c = 0, h = l.length; h > c; c++) s.vertices.push(new i.Vector3, new i.Vector3);
                i.Line.call(this, s, new i.LineBasicMaterial({
                    color: o,
                    linewidth: a
                }), i.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new i.Matrix3, this.update()
            }, i.FaceNormalsHelper.prototype = Object.create(i.Line.prototype), i.FaceNormalsHelper.prototype.constructor = i.FaceNormalsHelper, i.FaceNormalsHelper.prototype.update = function() {
                var e = this.geometry.vertices,
                    t = this.object,
                    n = t.geometry.vertices,
                    i = t.geometry.faces,
                    r = t.matrixWorld;
                t.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(r);
                for (var o = 0, a = 0, s = i.length; s > o; o++, a += 2) {
                    var l = i[o];
                    e[a].copy(n[l.a]).add(n[l.b]).add(n[l.c]).divideScalar(3).applyMatrix4(r), e[a + 1].copy(l.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(e[a])
                }
                return this.geometry.verticesNeedUpdate = !0, this
            }, i.GridHelper = function(e, t) {
                var n = new i.Geometry,
                    r = new i.LineBasicMaterial({
                        vertexColors: i.VertexColors
                    });
                this.color1 = new i.Color(4473924), this.color2 = new i.Color(8947848);
                for (var o = -e; e >= o; o += t) {
                    n.vertices.push(new i.Vector3(-e, 0, o), new i.Vector3(e, 0, o), new i.Vector3(o, 0, -e), new i.Vector3(o, 0, e));
                    var a = 0 === o ? this.color1 : this.color2;
                    n.colors.push(a, a, a, a)
                }
                i.Line.call(this, n, r, i.LinePieces)
            }, i.GridHelper.prototype = Object.create(i.Line.prototype), i.GridHelper.prototype.constructor = i.GridHelper, i.GridHelper.prototype.setColors = function(e, t) {
                this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
            }, i.HemisphereLightHelper = function(e, t) {
                i.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new i.Color, new i.Color];
                var n = new i.SphereGeometry(t, 4, 2);
                n.applyMatrix((new i.Matrix4).makeRotationX(-Math.PI / 2));
                for (var r = 0, o = 8; o > r; r++) n.faces[r].color = this.colors[4 > r ? 0 : 1];
                var a = new i.MeshBasicMaterial({
                    vertexColors: i.FaceColors,
                    wireframe: !0
                });
                this.lightSphere = new i.Mesh(n, a), this.add(this.lightSphere), this.update()
            }, i.HemisphereLightHelper.prototype = Object.create(i.Object3D.prototype), i.HemisphereLightHelper.prototype.constructor = i.HemisphereLightHelper, i.HemisphereLightHelper.prototype.dispose = function() {
                this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
            }, i.HemisphereLightHelper.prototype.update = function() {
                var e = new i.Vector3;
                return function() {
                    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
                }
            }(), i.PointLightHelper = function(e, t) {
                this.light = e, this.light.updateMatrixWorld();
                var n = new i.SphereGeometry(t, 4, 2),
                    r = new i.MeshBasicMaterial({
                        wireframe: !0,
                        fog: !1
                    });
                r.color.copy(this.light.color).multiplyScalar(this.light.intensity), i.Mesh.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
            }, i.PointLightHelper.prototype = Object.create(i.Mesh.prototype), i.PointLightHelper.prototype.constructor = i.PointLightHelper, i.PointLightHelper.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, i.PointLightHelper.prototype.update = function() {
                this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }, i.SkeletonHelper = function(e) {
                this.bones = this.getBoneList(e);
                for (var t = new i.Geometry, n = 0; n < this.bones.length; n++) {
                    var r = this.bones[n];
                    r.parent instanceof i.Bone && (t.vertices.push(new i.Vector3), t.vertices.push(new i.Vector3), t.colors.push(new i.Color(0, 0, 1)), t.colors.push(new i.Color(0, 1, 0)))
                }
                var o = new i.LineBasicMaterial({
                    vertexColors: i.VertexColors,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                i.Line.call(this, t, o, i.LinePieces), this.root = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }, i.SkeletonHelper.prototype = Object.create(i.Line.prototype), i.SkeletonHelper.prototype.constructor = i.SkeletonHelper, i.SkeletonHelper.prototype.getBoneList = function(e) {
                var t = [];
                e instanceof i.Bone && t.push(e);
                for (var n = 0; n < e.children.length; n++) t.push.apply(t, this.getBoneList(e.children[n]));
                return t
            }, i.SkeletonHelper.prototype.update = function() {
                for (var e = this.geometry, t = (new i.Matrix4).getInverse(this.root.matrixWorld), n = new i.Matrix4, r = 0, o = 0; o < this.bones.length; o++) {
                    var a = this.bones[o];
                    a.parent instanceof i.Bone && (n.multiplyMatrices(t, a.matrixWorld), e.vertices[r].setFromMatrixPosition(n), n.multiplyMatrices(t, a.parent.matrixWorld), e.vertices[r + 1].setFromMatrixPosition(n), r += 2)
                }
                e.verticesNeedUpdate = !0, e.computeBoundingSphere()
            }, i.SpotLightHelper = function(e) {
                i.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
                var t = new i.CylinderGeometry(0, 1, 1, 8, 1, !0);
                t.applyMatrix((new i.Matrix4).makeTranslation(0, -.5, 0)), t.applyMatrix((new i.Matrix4).makeRotationX(-Math.PI / 2));
                var n = new i.MeshBasicMaterial({
                    wireframe: !0,
                    fog: !1
                });
                this.cone = new i.Mesh(t, n), this.add(this.cone), this.update()
            }, i.SpotLightHelper.prototype = Object.create(i.Object3D.prototype), i.SpotLightHelper.prototype.constructor = i.SpotLightHelper, i.SpotLightHelper.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, i.SpotLightHelper.prototype.update = function() {
                var e = new i.Vector3,
                    t = new i.Vector3;
                return function() {
                    var n = this.light.distance ? this.light.distance : 1e4,
                        i = n * Math.tan(this.light.angle);
                    this.cone.scale.set(i, i, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
                }
            }(), i.VertexNormalsHelper = function(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                for (var o = void 0 !== n ? n : 16711680, a = void 0 !== r ? r : 1, s = new i.Geometry, l = e.geometry.faces, c = 0, h = l.length; h > c; c++)
                    for (var u = l[c], f = 0, d = u.vertexNormals.length; d > f; f++) s.vertices.push(new i.Vector3, new i.Vector3);
                i.Line.call(this, s, new i.LineBasicMaterial({
                    color: o,
                    linewidth: a
                }), i.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new i.Matrix3, this.update()
            }, i.VertexNormalsHelper.prototype = Object.create(i.Line.prototype), i.VertexNormalsHelper.prototype.constructor = i.VertexNormalsHelper, i.VertexNormalsHelper.prototype.update = function(e) {
                var t = new i.Vector3;
                return function(e) {
                    var n = ["a", "b", "c", "d"];
                    this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
                    for (var i = this.geometry.vertices, r = this.object.geometry.vertices, o = this.object.geometry.faces, a = this.object.matrixWorld, s = 0, l = 0, c = o.length; c > l; l++)
                        for (var h = o[l], u = 0, f = h.vertexNormals.length; f > u; u++) {
                            var d = h[n[u]],
                                p = r[d],
                                m = h.vertexNormals[u];
                            i[s].copy(p).applyMatrix4(a), t.copy(m).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(i[s]), s += 1, i[s].copy(t), s += 1
                        }
                    return this.geometry.verticesNeedUpdate = !0, this
                }
            }(), i.VertexTangentsHelper = function(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                for (var o = void 0 !== n ? n : 255, a = void 0 !== r ? r : 1, s = new i.Geometry, l = e.geometry.faces, c = 0, h = l.length; h > c; c++)
                    for (var u = l[c], f = 0, d = u.vertexTangents.length; d > f; f++) s.vertices.push(new i.Vector3), s.vertices.push(new i.Vector3);
                i.Line.call(this, s, new i.LineBasicMaterial({
                    color: o,
                    linewidth: a
                }), i.LinePieces), this.matrixAutoUpdate = !1, this.update()
            }, i.VertexTangentsHelper.prototype = Object.create(i.Line.prototype), i.VertexTangentsHelper.prototype.constructor = i.VertexTangentsHelper, i.VertexTangentsHelper.prototype.update = function(e) {
                var t = new i.Vector3;
                return function(e) {
                    var n = ["a", "b", "c", "d"];
                    this.object.updateMatrixWorld(!0);
                    for (var i = this.geometry.vertices, r = this.object.geometry.vertices, o = this.object.geometry.faces, a = this.object.matrixWorld, s = 0, l = 0, c = o.length; c > l; l++)
                        for (var h = o[l], u = 0, f = h.vertexTangents.length; f > u; u++) {
                            var d = h[n[u]],
                                p = r[d],
                                m = h.vertexTangents[u];
                            i[s].copy(p).applyMatrix4(a), t.copy(m).transformDirection(a).multiplyScalar(this.size), t.add(i[s]), s += 1, i[s].copy(t), s += 1
                        }
                    return this.geometry.verticesNeedUpdate = !0, this
                }
            }(), i.WireframeHelper = function(e, t) {
                var n = void 0 !== t ? t : 16777215,
                    r = [0, 0],
                    o = {},
                    a = function(e, t) {
                        return e - t
                    },
                    s = ["a", "b", "c"],
                    l = new i.BufferGeometry;
                if (e.geometry instanceof i.Geometry) {
                    for (var c = e.geometry.vertices, h = e.geometry.faces, u = 0, f = new Uint32Array(6 * h.length), d = 0, p = h.length; p > d; d++)
                        for (var m = h[d], v = 0; 3 > v; v++) {
                            r[0] = m[s[v]], r[1] = m[s[(v + 1) % 3]], r.sort(a);
                            var g = r.toString();
                            void 0 === o[g] && (f[2 * u] = r[0], f[2 * u + 1] = r[1], o[g] = !0, u++)
                        }
                    for (var y = new Float32Array(2 * u * 3), d = 0, p = u; p > d; d++)
                        for (var v = 0; 2 > v; v++) {
                            var x = c[f[2 * d + v]],
                                w = 6 * d + 3 * v;
                            y[w + 0] = x.x, y[w + 1] = x.y, y[w + 2] = x.z
                        }
                    l.addAttribute("position", new i.BufferAttribute(y, 3))
                } else if (e.geometry instanceof i.BufferGeometry)
                    if (void 0 !== e.geometry.attributes.index) {
                        var c = e.geometry.attributes.position.array,
                            _ = e.geometry.attributes.index.array,
                            b = e.geometry.drawcalls,
                            u = 0;
                        0 === b.length && (b = [{
                            count: _.length,
                            index: 0,
                            start: 0
                        }]);
                        for (var f = new Uint32Array(2 * _.length), E = 0, M = b.length; M > E; ++E)
                            for (var S = b[E].start, T = b[E].count, w = b[E].index, d = S, C = S + T; C > d; d += 3)
                                for (var v = 0; 3 > v; v++) {
                                    r[0] = w + _[d + v], r[1] = w + _[d + (v + 1) % 3], r.sort(a);
                                    var g = r.toString();
                                    void 0 === o[g] && (f[2 * u] = r[0], f[2 * u + 1] = r[1], o[g] = !0, u++)
                                }
                        for (var y = new Float32Array(2 * u * 3), d = 0, p = u; p > d; d++)
                            for (var v = 0; 2 > v; v++) {
                                var w = 6 * d + 3 * v,
                                    A = 3 * f[2 * d + v];
                                y[w + 0] = c[A], y[w + 1] = c[A + 1], y[w + 2] = c[A + 2]
                            }
                        l.addAttribute("position", new i.BufferAttribute(y, 3))
                    } else {
                        for (var c = e.geometry.attributes.position.array, u = c.length / 3, P = u / 3, y = new Float32Array(2 * u * 3), d = 0, p = P; p > d; d++)
                            for (var v = 0; 3 > v; v++) {
                                var w = 18 * d + 6 * v,
                                    D = 9 * d + 3 * v;
                                y[w + 0] = c[D], y[w + 1] = c[D + 1], y[w + 2] = c[D + 2];
                                var A = 9 * d + 3 * ((v + 1) % 3);
                                y[w + 3] = c[A], y[w + 4] = c[A + 1], y[w + 5] = c[A + 2]
                            }
                        l.addAttribute("position", new i.BufferAttribute(y, 3))
                    }
                i.Line.call(this, l, new i.LineBasicMaterial({
                    color: n
                }), i.LinePieces), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }, i.WireframeHelper.prototype = Object.create(i.Line.prototype), i.WireframeHelper.prototype.constructor = i.WireframeHelper, i.ImmediateRenderObject = function() {
                i.Object3D.call(this), this.render = function(e) {}
            }, i.ImmediateRenderObject.prototype = Object.create(i.Object3D.prototype), i.ImmediateRenderObject.prototype.constructor = i.ImmediateRenderObject, i.MorphBlendMesh = function(e, t) {
                i.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
                var n = this.geometry.morphTargets.length,
                    r = "__default",
                    o = 0,
                    a = n - 1,
                    s = n / 1;
                this.createAnimation(r, o, a, s), this.setAnimationWeight(r, 1)
            }, i.MorphBlendMesh.prototype = Object.create(i.Mesh.prototype), i.MorphBlendMesh.prototype.constructor = i.MorphBlendMesh, i.MorphBlendMesh.prototype.createAnimation = function(e, t, n, i) {
                var r = {
                    startFrame: t,
                    endFrame: n,
                    length: n - t + 1,
                    fps: i,
                    duration: (n - t) / i,
                    lastFrame: 0,
                    currentFrame: 0,
                    active: !1,
                    time: 0,
                    direction: 1,
                    weight: 1,
                    directionBackwards: !1,
                    mirroredLoop: !1
                };
                this.animationsMap[e] = r, this.animationsList.push(r)
            }, i.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
                for (var t, n = /([a-z]+)_?(\d+)/, i = {}, r = this.geometry, o = 0, a = r.morphTargets.length; a > o; o++) {
                    var s = r.morphTargets[o],
                        l = s.name.match(n);
                    if (l && l.length > 1) {
                        var c = l[1];
                        i[c] || (i[c] = {
                            start: 1 / 0,
                            end: -(1 / 0)
                        });
                        var h = i[c];
                        o < h.start && (h.start = o), o > h.end && (h.end = o), t || (t = c)
                    }
                }
                for (var c in i) {
                    var h = i[c];
                    this.createAnimation(c, h.start, h.end, e)
                }
                this.firstAnimation = t
            }, i.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
                var t = this.animationsMap[e];
                t && (t.direction = 1, t.directionBackwards = !1)
            }, i.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
                var t = this.animationsMap[e];
                t && (t.direction = -1, t.directionBackwards = !0)
            }, i.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
                var n = this.animationsMap[e];
                n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
            }, i.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
                var n = this.animationsMap[e];
                n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
            }, i.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
                var n = this.animationsMap[e];
                n && (n.weight = t)
            }, i.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
                var n = this.animationsMap[e];
                n && (n.time = t)
            }, i.MorphBlendMesh.prototype.getAnimationTime = function(e) {
                var t = 0,
                    n = this.animationsMap[e];
                return n && (t = n.time), t
            }, i.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
                var t = -1,
                    n = this.animationsMap[e];
                return n && (t = n.duration), t
            }, i.MorphBlendMesh.prototype.playAnimation = function(e) {
                var t = this.animationsMap[e];
                t ? (t.time = 0, t.active = !0) : i.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
            }, i.MorphBlendMesh.prototype.stopAnimation = function(e) {
                var t = this.animationsMap[e];
                t && (t.active = !1)
            }, i.MorphBlendMesh.prototype.update = function(e) {
                for (var t = 0, n = this.animationsList.length; n > t; t++) {
                    var r = this.animationsList[t];
                    if (r.active) {
                        var o = r.duration / r.length;
                        r.time += r.direction * e, r.mirroredLoop ? (r.time > r.duration || r.time < 0) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), r.time < 0 && (r.time = 0, r.directionBackwards = !1)) : (r.time = r.time % r.duration, r.time < 0 && (r.time += r.duration));
                        var a = r.startFrame + i.Math.clamp(Math.floor(r.time / o), 0, r.length - 1),
                            s = r.weight;
                        a !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * s, this.morphTargetInfluences[a] = 0, r.lastFrame = r.currentFrame, r.currentFrame = a);
                        var l = r.time % o / o;
                        r.directionBackwards && (l = 1 - l), this.morphTargetInfluences[r.currentFrame] = l * s, this.morphTargetInfluences[r.lastFrame] = (1 - l) * s
                    }
                }
            }
        }, {}
    ],
    26: [
        function(e, t, n) {
            void 0 === Date.now && (Date.now = function() {
                return (new Date).valueOf()
            }), window.TWEEN = function() {
                var e = [],
                    t = [],
                    n = [];
                return {
                    REVISION: "14",
                    getAll: function() {
                        return e
                    },
                    removeAll: function() {
                        e = []
                    },
                    add: function(e) {
                        t.push(e)
                    },
                    remove: function(e) {
                        n.push(e)
                    },
                    update: function(i) {
                        var r = 0;
                        for (i = void 0 !== i ? i : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); r < e.length;) e[r].update(i) ? r++ : e.splice(r, 1);
                        return n.length > 0 && (n.forEach(function(t) {
                            var n = e.indexOf(t); - 1 !== n && e.splice(n, 1)
                        }), n = []), t.length > 0 && (t.forEach(function(t) {
                            e.push(t)
                        }), t = []), !0
                    }
                }
            }(), TWEEN.Tween = function(e) {
                var t, n, i, r, o, a, s, l, c, h, u, f, d, p, m, v, g, y, x, w;
                this.reset = function(e) {
                    return t = e, n = 0, i = {}, r = {}, o = {}, a = 1e3, s = 0, l = !1, c = !1, h = !1, u = 0, f = null, d = TWEEN.Easing.Linear.None, p = TWEEN.Interpolation.Linear, m = [], v = null, g = !1, y = null, x = null, w = null, this
                }, this.to = function(e, t) {
                    return void 0 !== t && (a = t), r = e, this
                }, this.start = function(e) {
                    TWEEN.add(this), c = !0, g = !1, f = void 0 !== e ? e : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(), f += u;
                    for (var n in r) i[n] = t[n], o[n] = i[n] || 0;
                    return this
                }, this.stop = function() {
                    return c ? (TWEEN.remove(this), c = !1, null !== w && w.call(t), this.stopChainedTweens(), this) : this
                }, this.stopChainedTweens = function() {
                    for (var e = 0, t = m.length; t > e; e++) m[e].stop()
                }, this.delay = function(e) {
                    return u = e, this
                }, this.repeat = function(e) {
                    return s = e, this
                }, this.yoyo = function(e) {
                    return l = e, this
                }, this.easing = function(e) {
                    return d = e, this
                }, this.interpolation = function(e) {
                    return p = e, this
                }, this.chain = function() {
                    return m = arguments, this
                }, this.onStart = function(e) {
                    return v = e, this
                }, this.onUpdate = function(e) {
                    return y = e, this
                }, this.onComplete = function(e) {
                    return x = e, this
                }, this.onStop = function(e) {
                    return w = e, this
                }, this.update = function(e) {
                    var o;
                    if (f > e) return !0;
                    if (!c) return !1;
                    g === !1 && (null !== v && v.call(t), g = !0);
                    var s = (e - f) / a;
                    s = s > 1 ? 1 : s, n = s;
                    var l = d(s);
                    for (o in r) {
                        var h = i[o] || 0,
                            u = r[o];
                        t[o] = h + (u - h) * l
                    }
                    if (null !== y && y.call(t, l), 1 == s) {
                        null !== x && x.call(t);
                        for (var p = 0, w = m.length; w > p; p++) m[p].start(e);
                        return !1
                    }
                    return !0
                }, this.getProgress = function() {
                    return n
                }, void 0 !== e && this.reset(e)
            }, TWEEN.Easing = {
                Linear: {
                    None: function(e) {
                        return e
                    }
                },
                Quadratic: {
                    In: function(e) {
                        return e * e
                    },
                    Out: function(e) {
                        return e * (2 - e)
                    },
                    InOut: function(e) {
                        return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                    }
                },
                Cubic: {
                    In: function(e) {
                        return e * e * e
                    },
                    Out: function(e) {
                        return --e * e * e + 1
                    },
                    InOut: function(e) {
                        return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                    }
                },
                Quartic: {
                    In: function(e) {
                        return e * e * e * e
                    },
                    Out: function(e) {
                        return 1 - --e * e * e * e
                    },
                    InOut: function(e) {
                        return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                    }
                },
                Quintic: {
                    In: function(e) {
                        return e * e * e * e * e
                    },
                    Out: function(e) {
                        return --e * e * e * e * e + 1
                    },
                    InOut: function(e) {
                        return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                    }
                },
                Sinusoidal: {
                    In: function(e) {
                        return 1 - Math.cos(e * Math.PI / 2)
                    },
                    Out: function(e) {
                        return Math.sin(e * Math.PI / 2)
                    },
                    InOut: function(e) {
                        return .5 * (1 - Math.cos(Math.PI * e))
                    }
                },
                Exponential: {
                    In: function(e) {
                        return 0 === e ? 0 : Math.pow(1024, e - 1)
                    },
                    Out: function(e) {
                        return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                    },
                    InOut: function(e) {
                        return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
                    }
                },
                Circular: {
                    In: function(e) {
                        return 1 - Math.sqrt(1 - e * e)
                    },
                    Out: function(e) {
                        return Math.sqrt(1 - --e * e)
                    },
                    InOut: function(e) {
                        return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                    }
                },
                Elastic: {
                    In: function(e) {
                        var t, n = .1,
                            i = .4;
                        return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i)))
                    },
                    Out: function(e) {
                        var t, n = .1,
                            i = .4;
                        return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / i) + 1)
                    },
                    InOut: function(e) {
                        var t, n = .1,
                            i = .4;
                        return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * (n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i)) : n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i) * .5 + 1);
                    }
                },
                Back: {
                    In: function(e) {
                        var t = 1.70158;
                        return e * e * ((t + 1) * e - t)
                    },
                    Out: function(e) {
                        var t = 1.70158;
                        return --e * e * ((t + 1) * e + t) + 1
                    },
                    InOut: function(e) {
                        var t = 2.5949095;
                        return (e *= 2) < 1 ? .5 * (e * e * ((t + 1) * e - t)) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                    }
                },
                Bounce: {
                    In: function(e) {
                        return 1 - TWEEN.Easing.Bounce.Out(1 - e)
                    },
                    Out: function(e) {
                        return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                    },
                    InOut: function(e) {
                        return .5 > e ? .5 * TWEEN.Easing.Bounce.In(2 * e) : .5 * TWEEN.Easing.Bounce.Out(2 * e - 1) + .5
                    }
                }
            }, TWEEN.Interpolation = {
                Linear: function(e, t) {
                    var n = e.length - 1,
                        i = n * t,
                        r = Math.floor(i),
                        o = TWEEN.Interpolation.Utils.Linear;
                    return 0 > t ? o(e[0], e[1], i) : t > 1 ? o(e[n], e[n - 1], n - i) : o(e[r], e[r + 1 > n ? n : r + 1], i - r)
                },
                Bezier: function(e, t) {
                    var n, i = 0,
                        r = e.length - 1,
                        o = Math.pow,
                        a = TWEEN.Interpolation.Utils.Bernstein;
                    for (n = 0; r >= n; n++) i += o(1 - t, r - n) * o(t, n) * e[n] * a(r, n);
                    return i
                },
                CatmullRom: function(e, t) {
                    var n = e.length - 1,
                        i = n * t,
                        r = Math.floor(i),
                        o = TWEEN.Interpolation.Utils.CatmullRom;
                    return e[0] === e[n] ? (0 > t && (r = Math.floor(i = n * (1 + t))), o(e[(r - 1 + n) % n], e[r], e[(r + 1) % n], e[(r + 2) % n], i - r)) : 0 > t ? e[0] - (o(e[0], e[0], e[1], e[1], -i) - e[0]) : t > 1 ? e[n] - (o(e[n], e[n], e[n - 1], e[n - 1], i - n) - e[n]) : o(e[r ? r - 1 : 0], e[r], e[r + 1 > n ? n : r + 1], e[r + 2 > n ? n : r + 2], i - r)
                },
                Utils: {
                    Linear: function(e, t, n) {
                        return (t - e) * n + e
                    },
                    Bernstein: function(e, t) {
                        var n = TWEEN.Interpolation.Utils.Factorial;
                        return n(e) / n(t) / n(e - t)
                    },
                    Factorial: function() {
                        var e = [1];
                        return function(t) {
                            var n, i = 1;
                            if (e[t]) return e[t];
                            for (n = t; n > 1; n--) i *= n;
                            return e[t] = i
                        }
                    }(),
                    CatmullRom: function(e, t, n, i, r) {
                        var o = .5 * (n - e),
                            a = .5 * (i - t),
                            s = r * r,
                            l = r * s;
                        return (2 * t - 2 * n + o + a) * l + (-3 * t + 3 * n - 2 * o - a) * s + o * r + t
                    }
                }
            }, "undefined" != typeof t && t.exports && (t.exports = TWEEN)
        }, {}
    ],
    27: [
        function(e, t, n) {
            var i = e("2");
            window.$ = e("4"), window._ = e("5"), window.THREE = e("25"), window.isMobile = "ontouchstart" in window, e("26"), i.$ = $, window.WIDTH = window.innerWidth, window.HEIGHT = window.innerHeight, window.mouseX = 0, window.mouseY = 0, THREE.customMaterials = [], Number.prototype.lerp = function(e, t) {
                return this + (e - this) * t
            }, Function.prototype.inherit = function(e, t) {
                if (!e || !_.isFunction(e)) throw "parent argument must be a function";
                this.prototype = _.extend(Object.create(e.prototype), t)
            }, String.prototype.endsWith = function(e) {
                return -1 !== this.indexOf(e, this.length - e.length)
            }
        }, {
            2: 2,
            25: 25,
            26: 26,
            4: 4,
            5: 5
        }
    ],
    28: [
        function(e, t, n) {
            function i(e, t) {
                var n = $("#loading .js-fill");
                a.onLoadingProgress(function(e) {
                    n.css("width", Math.round(100 * e) + "%")
                });
                var i = _.flatten([a.load(t), s.preloadAll()]);
                $.when.apply(null, i).done(function() {
                    Detector.webgl ? _.defer(function() {
                        r(e())
                    }) : $("body").append(Detector.getWebGLErrorMessage())
                }), $(window).on("mousemove", function(e) {
                    window.mouseX = e.pageX / WIDTH * 2 - 1, window.mouseY = 1 - e.pageY / HEIGHT * 2
                }), $(window).on("resize", function() {
                    window.WIDTH = window.innerWidth, window.HEIGHT = window.innerHeight
                })
            }

            function r(e) {
                o.setup(e), e.start($("#container")), e.hideStatusBar(), $("#hud").removeClass("hidden"), $("#loading").addClass("hidden")
            }
            e("27"), e("22");
            var o = e("29"),
                a = e("21"),
                s = e("16");
            t.exports = i
        }, {
            16: 16,
            21: 21,
            22: 22,
            27: 27,
            29: 29
        }
    ],
    29: [
        function(e, t, n) {
            var i, r;
            "undefined" != typeof document.hidden ? (i = "hidden", r = "visibilitychange") : "undefined" != typeof document.mozHidden ? (i = "mozHidden", r = "mozvisibilitychange") : "undefined" != typeof document.msHidden ? (i = "msHidden", r = "msvisibilitychange") : "undefined" != typeof document.webkitHidden && (i = "webkitHidden", r = "webkitvisibilitychange"), t.exports = {
                setup: function(e) {
                    "undefined" != typeof document.addEventListener && document.addEventListener(r, function() {
                        document[i] ? e.onLeaveTab() : setTimeout(e.onFocusTab.bind(e), 50)
                    }, !1)
                }
            }
        }, {}
    ],
    30: [
        function(e, t, n) {
            var i = "#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 offsetRepeat;\n#endif\n\nvoid main() {\n  #ifdef USE_MAP\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n  #endif\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                r = "#ifdef USE_MAP\n  varying vec2 vUv;\n\n  uniform sampler2D map;\n#endif\n\nuniform vec3 fogColor;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main() {\n  gl_FragColor = vec4(diffuse, opacity);\n\n  #ifdef USE_MAP\n    gl_FragColor = gl_FragColor * texture2D(map, vUv);\n  #endif\n\n  #ifdef ALPHATEST\n    if ( gl_FragColor.a < ALPHATEST ) discard;\n  #endif\n\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);\n\n  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);\n}",
                o = e("35"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms)
                    }, e), o.call(this, e), this.onPropertyChange("color", function(e) {
                        this.uniforms.diffuse.value = e
                    }), this.onPropertyChange("map", function(e) {
                        this.uniforms.map.value = e, e && this.uniforms.offsetRepeat.value.set(e.offset.x, e.offset.y, e.repeat.x, e.repeat.y)
                    }), this.onPropertyChange("opacity", function(e) {
                        this.uniforms.opacity.value = e
                    }), this.onPropertyChange("combine", function(e) {
                        this.uniforms.combine.value = e
                    }), this.onPropertyChange("envMap", function(e) {
                        e && (this.uniforms.envMap.value = e)
                    }), this.fog = e.fog || !0, this.opacity = e.opacity || 1, this.color = new THREE.Color(void 0 !== e.color ? e.color : 16777215), this.map = e.map || null, this.envMap = e.envMap || null, this.combine = e.combine || null
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                envMap: {
                    type: "t",
                    value: null
                },
                combine: {
                    type: "f",
                    value: 0
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return o.prototype.clone.call(this, e), t.map = this.map, t.transparent = this.transparent, t
                }
            }), t.exports = a
        }, {
            35: 35
        }
    ],
    31: [
        function(e, t, n) {
            var i = "varying vec3 vWorldPos;\nvarying float vOpacity;\nvarying float vDistance;\n#ifdef USE_COLOR\n    attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n        attribute vec3 morphNormal0;\n        attribute vec3 morphNormal1;\n        attribute vec3 morphNormal2;\n        attribute vec3 morphNormal3;\n    #else\n        attribute vec3 morphTarget4;\n        attribute vec3 morphTarget5;\n        attribute vec3 morphTarget6;\n        attribute vec3 morphTarget7;\n    #endif\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n    varying vec3 vNormal;\n#endif\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n    uniform vec4 offsetRepeat;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n\n#endif\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    varying vec3 vReflect;\n\n    uniform float refractionRatio;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif\n#ifdef USE_SKINNING\n\n    uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n        uniform int boneTextureHeight;\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n            float dx = 1.0 / float( boneTextureWidth );\n            float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n            return bone;\n\n        }\n\n    #else\n\n        uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n#ifdef TRANSPARENT_MODE\n    vOpacity = 1.0 - smoothstep(0.5, 1.75, vWorldPos.y);\n#else\n    vOpacity = 1.0;\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n#ifdef USE_MORPHNORMALS\n\n    vec3 morphedNormal = vec3( 0.0 );\n\n    morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n    #ifdef USE_MORPHNORMALS\n\n    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n    #else\n\n    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n    vec3 objectNormal = morphedNormal;\n\n#else\n\n    vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n    objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifndef FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n#endif\n#ifdef USE_MORPHTARGETS\n\n    vec3 morphed = vec3( 0.0 );\n    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n    morphed += position;\n\n#endif\n#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n    vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n    #endif\n\n    vec4 skinned = vec4( 0.0 );\n    skinned += boneMatX * skinVertex * skinWeight.x;\n    skinned += boneMatY * skinVertex * skinWeight.y;\n    skinned += boneMatZ * skinVertex * skinWeight.z;\n    skinned += boneMatW * skinVertex * skinWeight.w;\n    skinned  = bindMatrixInverse * skinned;\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n    vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\nvDistance = length(mvPosition.xyz);\n\ngl_Position = projectionMatrix * mvPosition;\n\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n    vViewPosition = -mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n    #ifdef ENVMAP_MODE_REFLECTION\n\n        vReflect = reflect( cameraToVertex, worldNormal );\n\n    #else\n\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    vWorldPosition = worldPosition.xyz;\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "varying vec3 vWorldPos;\nvarying float vOpacity;\nvarying float vDistance;\nuniform float envMapOffset;\nuniform float flipN;\n\n#ifdef USE_REFLECTIONMASK\n    uniform sampler2D reflectionMask;\n#endif\n\nuniform sampler2D paintMask;\n\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 diffuse2;\nuniform float colorTransition;\nuniform float carLength;\nvarying vec3 vPosition;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform sampler2D map;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    uniform sampler2D alphaMap;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n    uniform sampler2D emissiveMap;\n    uniform float emissiveIntensity;\n\n    #ifdef USE_EMISSIVECOLOR\n        uniform vec3 emissiveColor;\n    #endif\n\n#endif\n#ifdef USE_ENVMAP\n\n    uniform float reflectivity;\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    uniform float flipEnvMap;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        uniform float refractionRatio;\n\n    #else\n\n        varying vec3 vReflect;\n\n    #endif\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n    uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n    uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n    varying vec3 vNormal;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_BUMPMAP\n\n    uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n    // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n    vec2 dHdxy_fwd() {\n\n        vec2 dSTdx = dFdx( vUv );\n        vec2 dSTdy = dFdy( vUv );\n\n        float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n        float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n        return vec2( dBx, dBy );\n\n    }\n\n    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n        vec3 vSigmaX = dFdx( surf_pos );\n        vec3 vSigmaY = dFdy( surf_pos );\n        vec3 vN = surf_norm;        // normalized\n\n        vec3 R1 = cross( vSigmaY, vN );\n        vec3 R2 = cross( vN, vSigmaX );\n\n        float fDet = dot( vSigmaX, R1 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n        return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n    uniform sampler2D normalMap;\n    uniform vec2 normalScale;\n\n    // Per-Pixel Tangent Space Normal Mapping\n    // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n        vec3 q0 = dFdx( eye_pos.xyz );\n        vec3 q1 = dFdy( eye_pos.xyz );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n\n        vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n        vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n        vec3 N = normalize( surf_norm );\n\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n        mapN.xy = normalScale * mapN.xy;\n        mat3 tsn = mat3( S, T, N );\n        return normalize( tsn * mapN );\n\n    }\n\n#endif\n\n#ifdef USE_SPECULARMAP\n\n    uniform sampler2D specularMap;\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n    // Transition between two diffuse colors\n    float smoothingLength = 0.5;\n    float l = carLength + smoothingLength;\n    float edge1 = ((l / 2.0) - (colorTransition * l)) + (smoothingLength / 2.0);\n    float edge2 = ((l / 2.0) - (colorTransition * l)) - (smoothingLength / 2.0);\n\n\n    if (vWorldPos.z > edge1) {\n        diffuseColor = vec4(diffuse2, opacity);\n    }\n\n    if (vWorldPos.z < edge1 && vWorldPos.z > edge2) {\n        diffuseColor = vec4(mix(diffuse, diffuse2, smoothstep(edge2, edge1, vWorldPos.z)), opacity);\n    }\n\n    #ifdef USE_PAINTMASK\n\n        // Apply paint mask, which determines the areas where diffuse color is applied\n        vec4 texelPaintMask = texture2D(paintMask, vUv);\n        diffuseColor.rgb = mix(vec3(1.0), diffuseColor.rgb, texelPaintMask.r);\n\n    #endif\n\n\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n    diffuseColor *= texelColor;\n\n#endif\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif\n#ifndef FLAT_SHADED\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n        normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n    #endif\n\n#else\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n    normal = perturbNormal2Arb( -vViewPosition, flipN * normal );\n\n#elif defined( USE_BUMPMAP )\n\n    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        // diffuse\n\n        float dotProduct = dot( normal, lVector );\n\n        #ifdef WRAP_AROUND\n\n            float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n            float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n                // specular\n\n        vec3 pointHalfVector = normalize( lVector + viewPosition );\n        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n    }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n            // diffuse\n\n            float dotProduct = dot( flipN * normal, lVector );\n\n            #ifdef WRAP_AROUND\n\n                float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n                float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n                vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n            #else\n\n                float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n            #endif\n\n            totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n            // specular\n\n            vec3 spotHalfVector = normalize( lVector + viewPosition );\n            float spotDotNormalHalf = max( dot( flipN * normal, spotHalfVector ), 0.0 );\n            float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n            float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n            vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n            totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n        }\n\n    }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n        vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( normal, dirVector );\n\n        #ifdef WRAP_AROUND\n\n            float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n            float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n        // specular\n\n        vec3 dirHalfVector = normalize( dirVector + viewPosition );\n        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n        /*\n        // fresnel term from skin shader\n        const float F0 = 0.128;\n\n        float base = 1.0 - dot( viewPosition, dirHalfVector );\n        float exponential = pow( base, 5.0 );\n\n        float fresnel = exponential + F0 * ( 1.0 - exponential );\n        */\n\n        /*\n        // fresnel term from fresnel shader\n        const float mFresnelBias = 0.08;\n        const float mFresnelScale = 0.3;\n        const float mFresnelPower = 5.0;\n\n        float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n        */\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        //      dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n    }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n        vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( flipN * normal, lVector );\n        float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n        vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n        totalDiffuseLight += hemiColor;\n\n        // specular (sky light)\n\n        vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n        float hemiDotNormalHalfSky = 0.5 * dot( flipN * normal, hemiHalfVectorSky ) + 0.5;\n        float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n        // specular (ground light)\n\n        vec3 lVectorGround = -lVector;\n\n        vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n        float hemiDotNormalHalfGround = 0.5 * dot( flipN * normal, hemiHalfVectorGround ) + 0.5;\n        float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n        float dotProductGround = dot( flipN * normal, lVectorGround );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n        vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n        totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n    }\n\n#endif\n\n#ifdef METAL\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif\n#ifdef USE_ENVMAP\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n        // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( flipN * normal, viewMatrix );\n\n        #ifdef ENVMAP_MODE_REFLECTION\n\n            vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n        #else\n\n            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n        #endif\n\n    #else\n\n        vec3 reflectVec = vReflect;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    #else\n        float flipNormal = 1.0;\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n        reflectVec.z += envMapOffset;\n        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n        vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n    #endif\n\n    envColor.xyz = inputToLinear( envColor.xyz );\n\n    #ifdef USE_REFLECTIONMASK\n\n        vec4 maskTexel = texture2D(reflectionMask, vUv);\n        float chromeReflectivity = 0.75;\n        float plasticReflectivity = 0.1;\n\n        // Mix when area is chrome (red component in mask)\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * maskTexel.r * chromeReflectivity);\n\n        // Add when area is shiny plastic / glass (blue component in mask)\n        outgoingLight += (envColor.xyz * specularStrength * maskTexel.b * plasticReflectivity);\n\n\n        #ifdef USE_PAINTMASK\n            // Mix when area is carpaint\n            outgoingLight = mix ( outgoingLight, envColor.xyz, specularStrength * reflectivity * texelPaintMask.r);\n        #endif\n\n    #else\n\n        #ifdef ENVMAP_BLENDING_MULTIPLY\n\n            outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_MIX )\n\n            outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_ADD )\n\n            outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n        #endif\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n\n    outgoingLight = linearToOutput( outgoingLight );\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n    float o = smoothstep(0.15, 0.35, vDistance);\n\n#ifdef USE_EMISSIVEMAP\n        float emissiveness = texture2D(emissiveMap, vUv).r;\n        vec3 ec = vec3(1.0);\n\n        #ifdef USE_EMISSIVECOLOR\n            ec = emissiveColor;\n        #endif\n\n        gl_FragColor = vec4( mix(outgoingLight.rgb, (texelColor.rgb + (vec3(1.0) * emissiveIntensity)) * ec, emissiveness * emissiveIntensity), diffuseColor.a * vOpacity * o );\n#else\n\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a * vOpacity * o);\n#endif\n}",
                o = e("38"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        defines: {
                            USE_AOMAP: !1,
                            LIGHTMAP_ENABLED: !1,
                            SKINNED: !1,
                            USE_EMISSIVEMAP: void 0 !== e.emissiveMap,
                            USE_REFLECTIONMASK: void 0 !== e.reflectionMask,
                            USE_PAINTMASK: void 0 !== e.paintMask,
                            USE_EMISSIVECOLOR: void 0 !== e.emissiveColor,
                            TRANSPARENT_MODE: !1
                        }
                    }, e), o.call(this, e), this.onPropertyChange("color2", function(e) {
                        this.uniforms.diffuse2.value = e
                    }), this.onPropertyChange("colorTransition", function(e) {
                        this.uniforms.colorTransition.value = e
                    }), this.onPropertyChange("carLength", function(e) {
                        this.uniforms.carLength.value = e
                    }), this.onPropertyChange("paintMask", function(e) {
                        e && (this.uniforms.paintMask.value = e)
                    }), this.onPropertyChange("envMapOffset", function(e) {
                        this.uniforms.envMapOffset.value = e
                    }), this.onPropertyChange("transparentMode", function(e) {
                        this.defines.TRANSPARENT_MODE = e, this.needsUpdate = !0
                    }), this.color2 = new THREE.Color(e.color2 || 16777215), this.carLength = e.carLength || 5, this.paintMask = e.paintMask || null, this.envMapOffset = e.envMapOffset || 0, this.uniforms.flipN.value = e.flipN ? -1 : 1
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                diffuse2: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                colorTransition: {
                    type: "f",
                    value: 0
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                lightMap: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                pointLightColor: {
                    type: "fv",
                    value: []
                },
                pointLightPosition: {
                    type: "fv",
                    value: []
                },
                pointLightDistance: {
                    type: "fv1",
                    value: []
                },
                directionalLightDirection: {
                    type: "fv",
                    value: []
                },
                directionalLightColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightDirection: {
                    type: "fv",
                    value: []
                },
                hemisphereLightSkyColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightGroundColor: {
                    type: "fv",
                    value: []
                },
                spotLightColor: {
                    type: "fv",
                    value: []
                },
                spotLightPosition: {
                    type: "fv",
                    value: []
                },
                spotLightDirection: {
                    type: "fv",
                    value: []
                },
                spotLightDistance: {
                    type: "fv1",
                    value: []
                },
                spotLightAngleCos: {
                    type: "fv1",
                    value: []
                },
                spotLightExponent: {
                    type: "fv1",
                    value: []
                },
                spotLightDecay: {
                    type: "fv1",
                    value: []
                },
                lightVariance: {
                    type: "f",
                    value: 0
                },
                envMap: {
                    type: "t",
                    value: null
                },
                flipEnvMap: {
                    type: "f",
                    value: -1
                },
                reflectivity: {
                    type: "f",
                    value: .15
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                },
                normalMap: {
                    type: "t",
                    value: null
                },
                normalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                emissiveMap: {
                    type: "t",
                    value: null
                },
                emissiveColor: {
                    type: "c",
                    value: null
                },
                emissiveIntensity: {
                    type: "f",
                    value: 1
                },
                carLength: {
                    type: "f",
                    value: 5
                },
                reflectionMask: {
                    type: "t",
                    value: null
                },
                paintMask: {
                    type: "t",
                    value: null
                },
                envMapOffset: {
                    type: "f",
                    value: 0
                },
                flipN: {
                    type: "f",
                    value: 1
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.map = this.map, t.envMap = this.envMap, t.transparent = this.transparent, t.emissive = this.emissive, t.fog = this.fog, t.color = this.color, t.specular = this.specular, t.shininess = this.shininess, t.reflectivity = this.reflectivity, t
                }
            }), t.exports = a
        }, {
            38: 38
        }
    ],
    32: [
        function(e, t, n) {
            var i = "varying float vOpacity;\n\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n    uniform vec4 offsetRepeat;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n\n#endif\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    varying vec3 vReflect;\n\n    uniform float refractionRatio;\n\n#endif\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif\n#ifdef USE_SKINNING\n\n    uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n        uniform int boneTextureHeight;\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n            float dx = 1.0 / float( boneTextureWidth );\n            float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n            return bone;\n\n        }\n\n    #else\n\n        uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n    vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n#ifdef TRANSPARENT_MODE\n    vOpacity = 1.0 - smoothstep(0.5, 1.75, worldPos.y);\n#else\n    vOpacity = 1.0;\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n    #ifdef USE_ENVMAP\n#ifdef USE_MORPHNORMALS\n\n    vec3 morphedNormal = vec3( 0.0 );\n\n    morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n    #ifdef USE_MORPHNORMALS\n\n    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n    #else\n\n    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n    vec3 objectNormal = morphedNormal;\n\n#else\n\n    vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n    objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n    #endif\n#ifdef USE_MORPHTARGETS\n\n    vec3 morphed = vec3( 0.0 );\n    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n    morphed += position;\n\n#endif\n#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n    vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n    #endif\n\n    vec4 skinned = vec4( 0.0 );\n    skinned += boneMatX * skinVertex * skinWeight.x;\n    skinned += boneMatY * skinVertex * skinWeight.y;\n    skinned += boneMatZ * skinVertex * skinWeight.z;\n    skinned += boneMatW * skinVertex * skinWeight.w;\n    skinned  = bindMatrixInverse * skinned;\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n    vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n    #ifdef ENVMAP_MODE_REFLECTION\n\n        vReflect = reflect( cameraToVertex, worldNormal );\n\n    #else\n\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "varying float vOpacity;\nuniform vec3 diffuse;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform sampler2D map;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    uniform sampler2D alphaMap;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif\n#ifdef USE_ENVMAP\n\n    uniform float reflectivity;\n    uniform float envMapOffset;\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    uniform float flipEnvMap;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        uniform float refractionRatio;\n\n    #else\n\n        varying vec3 vReflect;\n\n    #endif\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_SPECULARMAP\n\n    uniform sampler2D specularMap;\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n    diffuseColor *= texelColor;\n\n#endif\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif\n    outgoingLight = diffuseColor.rgb;\n#ifdef USE_LIGHTMAP\n\n    outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif\n#ifdef USE_ENVMAP\n\n    vec3 reflectVec = vReflect;\n\n    #ifdef DOUBLE_SIDED\n        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    #else\n        float flipNormal = 1.0;\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n        reflectVec.z += envMapOffset;\n        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n        vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n    #endif\n\n    envColor.xyz = inputToLinear( envColor.xyz );\n\n    float r = reflectivity;\n\n    #ifdef DOUBLE_SIDED\n        if (gl_FrontFacing == false) {\n            r = 0.0;\n        }\n    #endif\n\n    #ifdef ENVMAP_BLENDING_MULTIPLY\n\n        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * r );\n\n    #elif defined( ENVMAP_BLENDING_MIX )\n\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * r );\n\n    #elif defined( ENVMAP_BLENDING_ADD )\n\n        outgoingLight += envColor.xyz * specularStrength * r;\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n\n    outgoingLight = linearToOutput( outgoingLight );\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a * vOpacity);\n}",
                o = e("30"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        defines: {
                            TRANSPARENT_MODE: !1
                        }
                    }, e), o.call(this, e), this.onPropertyChange("envMapOffset", function(e) {
                        this.uniforms.envMapOffset.value = e
                    }), this.onPropertyChange("reflectivity", function(e) {
                        this.uniforms.reflectivity.value = e
                    }), this.onPropertyChange("flipEnvMap", function(e) {
                        this.uniforms.flipEnvMap.value = e
                    }), this.onPropertyChange("transparentMode", function(e) {
                        this.defines.TRANSPARENT_MODE = e, this.needsUpdate = !0
                    }), this.envMap = e.envMap || null, this.envMapOffset = e.envMapOffset || 0, this.reflectivity = e.reflectivity || .15
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                envMap: {
                    type: "t",
                    value: null
                },
                combine: {
                    type: "f",
                    value: 0
                },
                reflectivity: {
                    type: "f",
                    value: .15
                },
                flipEnvMap: {
                    type: "f",
                    value: 1
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                envMapOffset: {
                    type: "f",
                    value: 0
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.map = this.map, t.transparent = this.transparent, t
                }
            }), t.exports = a
        }, {
            30: 30
        }
    ],
    33: [
        function(e, t, n) {
            var i = "#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 offsetRepeat;\n#endif\n\n#ifdef LIGHTMAP_ENABLED\n  varying vec2 vUv2;\n#endif\n\nvarying vec3 vWorldPos;\nvarying float vDistance;\n\nvoid main() {\n  vDistance = length(position);\n  vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n  #ifdef USE_MAP\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n  #endif\n\n  #ifdef LIGHTMAP_ENABLED\n    vUv2 = uv;\n  #endif\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                r = "#ifdef USE_MAP\n  varying vec2 vUv;\n\n  uniform sampler2D map;\n#endif\n\n#ifdef LIGHTMAP_ENABLED\n  varying vec2 vUv2;\n  uniform sampler2D lightMap;\n  uniform float lightMapOpacity;\n#endif\n\nuniform vec3 fogColor;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float fogNear;\nuniform float fogFar;\n\nvarying vec3 vWorldPos;\nvarying float vDistance;\nuniform vec3 colorStep1;\nuniform vec3 colorStep2;\nuniform vec3 colorStep3;\n\nvoid main() {\n  gl_FragColor = vec4(diffuse, opacity);\n\n  #ifdef USE_MAP\n    gl_FragColor = gl_FragColor * texture2D(map, vUv);\n  #endif\n\n  #ifdef LIGHTMAP_ENABLED\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * texture2D(lightMap, vUv2).rgb, lightMapOpacity);\n  #endif\n\n  #ifdef ALPHATEST\n    if ( gl_FragColor.a < ALPHATEST ) discard;\n  #endif\n\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);\n\n  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);\n\n  // float dist = gl_FragCoord.z / gl_FragCoord.w;\n\n  // if (dist < 10.0) {\n  //     m = 0.0;\n  // }\n\n  float m = smoothstep(4.0, 9.0, vDistance);\n\n  vec3 color = mix(gl_FragColor.rgb, colorStep1, m);\n\n  gl_FragColor = vec4(color, 1.0);\n\n  m = smoothstep(15.0, 25.0, vDistance);\n\n  color = mix(gl_FragColor.rgb, colorStep2, m);\n\n  gl_FragColor = vec4(color, 1.0);\n\n  m = smoothstep(22.0, 25.0, max(vWorldPos.z - (vWorldPos.x * 0.45), abs(vWorldPos.x * 0.75)));\n\n  color = mix(gl_FragColor.rgb, colorStep3, m);\n\n  gl_FragColor = vec4(color, 1.0);\n\n}",
                o = e("30"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        defines: {
                            USE_AOMAP: !1,
                            LIGHTMAP_ENABLED: void 0 !== e.lightMap
                        }
                    }, e), o.call(this, e), this.onPropertyChange("colorStep1", function(e) {
                        this.uniforms.colorStep1.value = e
                    }), this.onPropertyChange("colorStep2", function(e) {
                        this.uniforms.colorStep2.value = e
                    }), this.onPropertyChange("colorStep3", function(e) {
                        this.uniforms.colorStep3.value = e
                    }), this.onPropertyChange("lightIntensity", function(e) {
                        this.uniforms.lightIntensity.value = e
                    }), this.onPropertyChange("lightMap", function(e) {
                        e && (this.uniforms.lightMap.value = e)
                    }), this.onPropertyChange("lightMapOpacity", function(e) {
                        this.uniforms.lightMapOpacity.value = e
                    }), this.lightIntensity = e.lightIntensity || 1, this.lightMap = e.lightMap || null, this.lightMapOpacity = e.lightMapOpacity || 1, this.colorStep1 = e.colorStep1 || new THREE.Color(16777215), this.colorStep2 = e.colorStep2 || new THREE.Color(16777215), this.colorStep3 = e.colorStep3 || new THREE.Color(16777215)
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                lightMap: {
                    type: "t",
                    value: null
                },
                lightMapOpacity: {
                    type: "f",
                    value: 0
                },
                envMap: {
                    type: "t",
                    value: null
                },
                combine: {
                    type: "t",
                    value: 0
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                colorStep1: {
                    type: "c",
                    value: new THREE.Color(16711680)
                },
                colorStep2: {
                    type: "c",
                    value: new THREE.Color(16711935)
                },
                colorStep3: {
                    type: "c",
                    value: new THREE.Color(255)
                },
                lightIntensity: {
                    type: "f",
                    value: 1
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.map = this.map, t.transparent = this.transparent, t
                },
                update: function(e, t, n) {
                    this.uniforms.offsetRepeat.value.set(t.x, t.y, n.x, n.y)
                }
            }), t.exports = a
        }, {
            30: 30
        }
    ],
    34: [
        function(e, t, n) {
            var i = "#ifdef USE_COLOR\n    attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n        attribute vec3 morphNormal0;\n        attribute vec3 morphNormal1;\n        attribute vec3 morphNormal2;\n        attribute vec3 morphNormal3;\n    #else\n        attribute vec3 morphTarget4;\n        attribute vec3 morphTarget5;\n        attribute vec3 morphTarget6;\n        attribute vec3 morphTarget7;\n    #endif\n#endif\n#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n    varying vec3 vLightBack;\n#endif\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n    uniform vec4 offsetRepeat;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n\n#endif\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    varying vec3 vReflect;\n    varying float vDot;\n\n    uniform float refractionRatio;\n\n#endif\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n    uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n    uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif\n#ifdef USE_SKINNING\n\n    uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n        uniform int boneTextureHeight;\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n            float dx = 1.0 / float( boneTextureWidth );\n            float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n            return bone;\n\n        }\n\n    #else\n\n        uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n#ifdef USE_MORPHNORMALS\n\n    vec3 morphedNormal = vec3( 0.0 );\n\n    morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n    #ifdef USE_MORPHNORMALS\n\n    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n    #else\n\n    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n    vec3 objectNormal = morphedNormal;\n\n#else\n\n    vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n    objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef USE_MORPHTARGETS\n\n    vec3 morphed = vec3( 0.0 );\n    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n    morphed += position;\n\n#endif\n#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n    vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n    #endif\n\n    vec4 skinned = vec4( 0.0 );\n    skinned += boneMatX * skinVertex * skinWeight.x;\n    skinned += boneMatY * skinVertex * skinWeight.y;\n    skinned += boneMatZ * skinVertex * skinWeight.z;\n    skinned += boneMatW * skinVertex * skinWeight.w;\n    skinned  = bindMatrixInverse * skinned;\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n    vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n    #ifdef ENVMAP_MODE_REFLECTION\n\n        vReflect = reflect( cameraToVertex, worldNormal );\n        vDot = abs(dot(cameraToVertex, normal));\n\n    #else\n\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n#endif\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n    vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n    float dotProduct = dot( transformedNormal, dirVector );\n    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n    #ifdef DOUBLE_SIDED\n\n        vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n        #ifdef WRAP_AROUND\n\n            vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n        #endif\n\n    #endif\n\n    #ifdef WRAP_AROUND\n\n        vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n        directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n        #ifdef DOUBLE_SIDED\n\n            directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n        #endif\n\n    #endif\n\n    vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n    #ifdef DOUBLE_SIDED\n\n        vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n    #endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n        float dotProduct = dot( transformedNormal, lVector );\n\n        vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n        #ifdef DOUBLE_SIDED\n\n            vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n            #ifdef WRAP_AROUND\n\n                vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n            #endif\n\n        #endif\n\n        #ifdef WRAP_AROUND\n\n            vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n            pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n            #ifdef DOUBLE_SIDED\n\n                pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n            #endif\n\n        #endif\n\n        vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n        #ifdef DOUBLE_SIDED\n\n            vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n        #endif\n\n    }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n            float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n            lVector = normalize( lVector );\n\n            float dotProduct = dot( transformedNormal, lVector );\n            vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n            #ifdef DOUBLE_SIDED\n\n                vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n                #ifdef WRAP_AROUND\n\n                    vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n                #endif\n\n            #endif\n\n            #ifdef WRAP_AROUND\n\n                vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n                spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n                #ifdef DOUBLE_SIDED\n\n                    spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n                #endif\n\n            #endif\n\n            vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n            #ifdef DOUBLE_SIDED\n\n                vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n            #endif\n\n        }\n\n    }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n        vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n        float dotProduct = dot( transformedNormal, lVector );\n\n        float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n        float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n        vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n        #ifdef DOUBLE_SIDED\n\n            vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n        #endif\n\n    }\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n    vLightBack += ambientLightColor;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n    varying vec3 vLightBack;\n#endif\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat quarticOut( in float k ) { return 1.0 - ( --k * k * k * k ); }\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform sampler2D map;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    uniform sampler2D alphaMap;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif\n#ifdef USE_ENVMAP\n\n    uniform float reflectivity;\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    uniform float flipEnvMap;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        uniform float refractionRatio;\n\n    #else\n\n        varying vec3 vReflect;\n        varying float vDot;\n\n    #endif\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_SPECULARMAP\n\n    uniform sampler2D specularMap;\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n    diffuseColor *= texelColor;\n\n#endif\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif\n    #ifdef DOUBLE_SIDED\n        if ( gl_FrontFacing )\n            outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n        else\n            outgoingLight += diffuseColor.rgb * vLightBack + emissive;\n    #else\n        outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n    #endif\n#ifdef USE_LIGHTMAP\n\n    outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif\n#ifdef USE_ENVMAP\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n        // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n        #ifdef ENVMAP_MODE_REFLECTION\n\n            vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n        #else\n\n            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n        #endif\n\n    #else\n\n        vec3 reflectVec = vReflect;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    #else\n        float flipNormal = 1.0;\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n        vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n    #endif\n\n    envColor.xyz = inputToLinear( envColor.xyz );\n\n    #ifdef ENVMAP_BLENDING_MULTIPLY\n        outgoingLight = mix(outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity);\n\n        // Pseudo Fresnel effect\n        outgoingLight = mix(mix(envColor.xyz, outgoingLight, 0.75), outgoingLight, vDot);\n    #elif defined( ENVMAP_BLENDING_MIX )\n\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n    #elif defined( ENVMAP_BLENDING_ADD )\n\n        outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n\n    outgoingLight = linearToOutput( outgoingLight );\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
                o = e("35"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        defines: {
                            USE_AOMAP: !1,
                            LIGHTMAP_ENABLED: !1,
                            SKINNED: !1
                        }
                    }, e), o.call(this, e), this.onPropertyChange("color", function(e) {
                        this.uniforms.diffuse.value = e
                    }), this.onPropertyChange("map", function(e) {
                        this.uniforms.map.value = e, e && this.uniforms.offsetRepeat.value.set(e.offset.x, e.offset.y, e.repeat.x, e.repeat.y)
                    }), this.onPropertyChange("opacity", function(e) {
                        this.uniforms.opacity.value = e
                    }), this.onPropertyChange("emissive", function(e) {
                        this.uniforms.emissive.value = e
                    }), this.onPropertyChange("lightMap", function(e) {
                        this.uniforms.lightMap.value = e, this.defines.LIGHTMAP_ENABLED = !!e
                    }), this.onPropertyChange("skinning", function(e) {
                        this.useVertexTexture = !!e, this.defines.SKINNED = !!e
                    }), this.onPropertyChange("envMap", function(e) {
                        this.uniforms.envMap.value = e
                    }), this.onPropertyChange("reflectivity", function(e) {
                        this.uniforms.reflectivity.value = e
                    }), this.fog = e.fog || !0, this.opacity = 1, this.color = new THREE.Color(e.color || 16777215), this.map = e.map || null, this.emissive = new THREE.Color(e.emissive || 0), this.lightMap = e.lightMap || null, this.lightVariance = 0, this.skinning = e.skinning || !1, this.envMap = e.envMap || null, this.reflectivity = e.reflectivity || .15
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                lightMap: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                pointLightColor: {
                    type: "fv",
                    value: []
                },
                pointLightPosition: {
                    type: "fv",
                    value: []
                },
                pointLightDistance: {
                    type: "fv1",
                    value: []
                },
                lightVariance: {
                    type: "f",
                    value: 0
                },
                envMap: {
                    type: "t",
                    value: null
                },
                flipEnvMap: {
                    type: "f",
                    value: -1
                },
                reflectivity: {
                    type: "f",
                    value: .15
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return o.prototype.clone.call(this, e), t.map = this.map, t.envMap = this.envMap, t.transparent = this.transparent, t.emissive = this.emissive, t.fog = this.fog, t.color = this.color, t.reflectivity = this.reflectivity, t
                },
                refreshLightUniforms: function() {
                    var e = new THREE.Vector3;
                    return function(t) {
                        var n = this.uniforms.pointLightColor.value,
                            i = this.uniforms.pointLightPosition.value,
                            r = this.uniforms.pointLightDistance.value,
                            o = 0;
                        t.forEach(function(t, a) {
                            t.visible && (o = 3 * a, n[o] = t.color.r * t.intensity, n[o + 1] = t.color.g * t.intensity, n[o + 2] = t.color.b * t.intensity, e.setFromMatrixPosition(t.matrixWorld), i[o] = e.x, i[o + 1] = e.y, i[o + 2] = e.z, r[a] = t.distance)
                        }, this)
                    }
                }()
            }), t.exports = a
        }, {
            35: 35
        }
    ],
    35: [
        function(e, t, n) {
            var i = ["side", "alphaTest", "transparent", "depthWrite", "shading", "wireframe"],
                r = function(e) {
                    e = e || {}, THREE.ShaderMaterial.call(this, e), _.each(i, function(t) {
                        var n = e[t];
                        void 0 !== n && (this[t] = n)
                    }), THREE.customMaterials.push(this)
                };
            r.inherit(THREE.ShaderMaterial, {
                onPropertyChange: function(e, t) {
                    Object.defineProperty(this, e, {
                        get: function() {
                            return this["_" + e]
                        },
                        set: function(n) {
                            this["_" + e] = n, t.call(this, n)
                        }
                    })
                },
                refreshLightUniforms: function(e) {},
                clone: function(e) {
                    var t = e || new r;
                    return THREE.Material.prototype.clone.call(this, t), t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.fog = this.fog, t.lights = this.lights, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t
                }
            }), t.exports = r
        }, {}
    ],
    36: [
        function(e, t, n) {
            var i = "varying float vOpacity;\nattribute vec3 destination;\nattribute float pScale;\nuniform float worldZ;\nuniform float size;\nuniform float scale;\nuniform float range;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n\n    float t = smoothstep(worldZ - (range / 2.0), worldZ + (range / 2.0), position.z);\n    vec3 pos = mix(position, destination, t);\n    // vec3 pos = mix(position, vec3(destination.x, destination.y, mix(destination.z, worldZ, 0.7)), t);\n\n    if (t == 1.0) {\n        vOpacity = 0.0;\n    } else {\n        vOpacity = t;\n    }\n\n    // vOpacity = smoothstep(worldZ - (range / 2.0), worldZ + (range / 2.0), position.z);\n\n    // if (vOpacity == 1.0) {\n    //     vOpacity = 0.0;\n    // }\n\n    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n    #ifdef USE_SIZEATTENUATION\n        gl_PointSize = size * pScale * ( scale / length( mvPosition.xyz ) );\n    #else\n        gl_PointSize = size * pScale;\n    #endif\n    gl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( pos, 1.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "varying float vOpacity;\nuniform vec3 psColor;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform vec4 offsetRepeat;\n    uniform sampler2D map;\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( psColor, vOpacity );\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\n    outgoingLight = diffuseColor.rgb;\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
                o = e("37"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        attributes: THREE.UniformsUtils.clone(a.attributes)
                    }, e), o.call(this, e), this.onPropertyChange("worldZ", function(e) {
                        this.uniforms.worldZ.value = e
                    }), this.onPropertyChange("range", function(e) {
                        this.uniforms.range.value = e
                    }), this.range = void 0 !== e.range ? e.range : 0, this.worldZ = void 0 !== e.worldZ ? e.worldZ : 0
                };
            a.attributes = {
                destination: {
                    type: "v3",
                    value: 1
                },
                pScale: {
                    type: "f",
                    value: 1
                }
            }, a.uniforms = {
                psColor: {
                    type: "c",
                    value: new THREE.Color(16711935)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                scale: {
                    type: "f",
                    value: 1
                },
                size: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                worldZ: {
                    type: "f",
                    value: 0
                },
                range: {
                    type: "f",
                    value: 1
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.color = this.color, t.map = this.map, t.scale = this.scale, t.size = this.size, t
                }
            }), t.exports = a
        }, {
            37: 37
        }
    ],
    37: [
        function(e, t, n) {
            var i = "uniform float size;\nuniform float scale;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    #ifdef USE_SIZEATTENUATION\n        gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n    #else\n        gl_PointSize = size;\n    #endif\n    gl_Position = projectionMatrix * mvPosition;\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "uniform vec3 psColor;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform vec4 offsetRepeat;\n    uniform sampler2D map;\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( psColor, opacity );\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\n    outgoingLight = diffuseColor.rgb;\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}",
                o = e("35"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms),
                        attributes: THREE.UniformsUtils.clone(a.attributes)
                    }, e), o.call(this, e), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e), this.side = THREE.DoubleSide, this.onPropertyChange("color", function(e) {
                        this.uniforms.psColor.value = e
                    }), this.onPropertyChange("map", function(e) {
                        this.uniforms.map.value = e
                    }), this.onPropertyChange("scale", function(e) {
                        this.uniforms.scale.value = e
                    }), this.onPropertyChange("opacity", function(e) {
                        this.uniforms.opacity.value = e
                    }), this.onPropertyChange("size", function(e) {
                        this.uniforms.size.value = e
                    }), this.fog = e.fog || !1, this.opacity = e.opacity || 1, this.color = new THREE.Color(e.color || 16777215), this.map = e.map || null, this.size = e.size || 1, this.scale = window.HEIGHT / 2
                };
            a.attributes = {
                size: {
                    type: "f",
                    value: 1
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            }, a.uniforms = {
                psColor: {
                    type: "c",
                    value: new THREE.Color(16711935)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                scale: {
                    type: "f",
                    value: 1
                },
                size: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return o.prototype.clone.call(this, e), t.color = this.color, t.map = this.map, t.scale = this.scale, t.size = this.size, t
                }
            }), t.exports = a
        }, {
            35: 35
        }
    ],
    38: [
        function(e, t, n) {
            function i(e, t, n, i) {
                e[t] = n.r * i, e[t + 1] = n.g * i, e[t + 2] = n.b * i
            }
            var r = "#ifdef USE_COLOR\n    attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n        attribute vec3 morphNormal0;\n        attribute vec3 morphNormal1;\n        attribute vec3 morphNormal2;\n        attribute vec3 morphNormal3;\n    #else\n        attribute vec3 morphTarget4;\n        attribute vec3 morphTarget5;\n        attribute vec3 morphTarget6;\n        attribute vec3 morphTarget7;\n    #endif\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n    varying vec3 vNormal;\n#endif\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n    uniform vec4 offsetRepeat;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n\n#endif\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    varying vec3 vReflect;\n\n    uniform float refractionRatio;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif\n#ifdef USE_SKINNING\n\n    uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n        uniform int boneTextureHeight;\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n            float dx = 1.0 / float( boneTextureWidth );\n            float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n            return bone;\n\n        }\n\n    #else\n\n        uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n#ifdef USE_MORPHNORMALS\n\n    vec3 morphedNormal = vec3( 0.0 );\n\n    morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n    #ifdef USE_MORPHNORMALS\n\n    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n    #else\n\n    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n    vec3 objectNormal = morphedNormal;\n\n#else\n\n    vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n    objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifndef FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n#endif\n#ifdef USE_MORPHTARGETS\n\n    vec3 morphed = vec3( 0.0 );\n    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n    morphed += position;\n\n#endif\n#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n    vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n    #endif\n\n    vec4 skinned = vec4( 0.0 );\n    skinned += boneMatX * skinVertex * skinWeight.x;\n    skinned += boneMatY * skinVertex * skinWeight.y;\n    skinned += boneMatZ * skinVertex * skinWeight.z;\n    skinned += boneMatW * skinVertex * skinWeight.w;\n    skinned  = bindMatrixInverse * skinned;\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n    vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n    vViewPosition = -mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n    #ifdef ENVMAP_MODE_REFLECTION\n\n        vReflect = reflect( cameraToVertex, worldNormal );\n\n    #else\n\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    vWorldPosition = worldPosition.xyz;\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                o = "\n#ifdef USE_REFLECTIONMASK\n    uniform sampler2D reflectionMask;\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\n#ifdef USE_EMISSIVECOLOR\n    uniform vec3 emissiveColor;\n#endif\n\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform sampler2D map;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    uniform sampler2D alphaMap;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n    uniform sampler2D emissiveMap;\n    uniform float emissiveIntensity;\n\n#endif\n#ifdef USE_ENVMAP\n\n    uniform float reflectivity;\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    uniform float flipEnvMap;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        uniform float refractionRatio;\n\n    #else\n\n        varying vec3 vReflect;\n\n    #endif\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n    uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n    uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n    varying vec3 vNormal;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_BUMPMAP\n\n    uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n    // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n    vec2 dHdxy_fwd() {\n\n        vec2 dSTdx = dFdx( vUv );\n        vec2 dSTdy = dFdy( vUv );\n\n        float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n        float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n        return vec2( dBx, dBy );\n\n    }\n\n    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n        vec3 vSigmaX = dFdx( surf_pos );\n        vec3 vSigmaY = dFdy( surf_pos );\n        vec3 vN = surf_norm;        // normalized\n\n        vec3 R1 = cross( vSigmaY, vN );\n        vec3 R2 = cross( vN, vSigmaX );\n\n        float fDet = dot( vSigmaX, R1 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n        return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n    uniform sampler2D normalMap;\n    uniform vec2 normalScale;\n\n    // Per-Pixel Tangent Space Normal Mapping\n    // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n        vec3 q0 = dFdx( eye_pos.xyz );\n        vec3 q1 = dFdy( eye_pos.xyz );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n\n        vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n        vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n        vec3 N = normalize( surf_norm );\n\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n        mapN.xy = normalScale * mapN.xy;\n        mat3 tsn = mat3( S, T, N );\n        return normalize( tsn * mapN );\n\n    }\n\n#endif\n\n#ifdef USE_SPECULARMAP\n\n    uniform sampler2D specularMap;\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n    diffuseColor *= texelColor;\n\n#endif\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif\n#ifndef FLAT_SHADED\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n        normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n    #endif\n\n#else\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n    normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        // diffuse\n\n        float dotProduct = dot( normal, lVector );\n\n        #ifdef WRAP_AROUND\n\n            float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n            float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n                // specular\n\n        vec3 pointHalfVector = normalize( lVector + viewPosition );\n        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n    }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n            // diffuse\n\n            float dotProduct = dot( normal, lVector );\n\n            #ifdef WRAP_AROUND\n\n                float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n                float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n                vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n            #else\n\n                float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n            #endif\n\n            totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n            // specular\n\n            vec3 spotHalfVector = normalize( lVector + viewPosition );\n            float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n            float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n            float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n            vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n            totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n        }\n\n    }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n        vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( normal, dirVector );\n\n        #ifdef WRAP_AROUND\n\n            float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n            float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n        // specular\n\n        vec3 dirHalfVector = normalize( dirVector + viewPosition );\n        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n        /*\n        // fresnel term from skin shader\n        const float F0 = 0.128;\n\n        float base = 1.0 - dot( viewPosition, dirHalfVector );\n        float exponential = pow( base, 5.0 );\n\n        float fresnel = exponential + F0 * ( 1.0 - exponential );\n        */\n\n        /*\n        // fresnel term from fresnel shader\n        const float mFresnelBias = 0.08;\n        const float mFresnelScale = 0.3;\n        const float mFresnelPower = 5.0;\n\n        float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n        */\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        //      dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n    }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n        vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( normal, lVector );\n        float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n        vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n        totalDiffuseLight += hemiColor;\n\n        // specular (sky light)\n\n        vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n        float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n        float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n        // specular (ground light)\n\n        vec3 lVectorGround = -lVector;\n\n        vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n        float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n        float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n        float dotProductGround = dot( normal, lVectorGround );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n        vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n        totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n    }\n\n#endif\n\n#ifdef METAL\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif\n#ifdef USE_ENVMAP\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n        // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n        #ifdef ENVMAP_MODE_REFLECTION\n\n            vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n        #else\n\n            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n        #endif\n\n    #else\n\n        vec3 reflectVec = vReflect;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    #else\n        float flipNormal = 1.0;\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n        vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n    #endif\n\n    envColor.xyz = inputToLinear( envColor.xyz );\n\n    #ifdef USE_REFLECTIONMASK\n\n        vec4 maskTexel = texture2D(reflectionMask, vUv);\n        float chromeReflectivity = 0.8;\n        float plasticReflectivity = 0.25;\n\n        // Mix when area is chrome (red component in mask)\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * maskTexel.r * chromeReflectivity);\n\n        // Add when area is shiny plastic / glass (blue component in mask)\n        outgoingLight += (envColor.xyz * specularStrength * maskTexel.b * plasticReflectivity);\n\n    #else\n\n        #ifdef ENVMAP_BLENDING_MULTIPLY\n\n            outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_MIX )\n\n            outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_ADD )\n\n            outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n        #endif\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n\n    outgoingLight = linearToOutput( outgoingLight );\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n\n#ifdef USE_EMISSIVEMAP\n        float emissiveness = texture2D(emissiveMap, vUv).r;\n        vec3 ec = vec3(1.0);\n\n        #ifdef USE_EMISSIVECOLOR\n            ec = emissiveColor;\n        #endif\n\n        gl_FragColor = vec4( mix(outgoingLight.rgb, (texelColor.rgb + (vec3(1.0) * emissiveIntensity)) * ec, emissiveness * emissiveIntensity), diffuseColor.a );\n#else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#endif\n\n}",
                a = e("35"),
                s = function(e) {
                    e = _.extend({
                        vertexShader: r,
                        fragmentShader: o,
                        uniforms: THREE.UniformsUtils.clone(s.uniforms),
                        defines: {
                            USE_AOMAP: !1,
                            LIGHTMAP_ENABLED: !1,
                            SKINNED: !1,
                            USE_EMISSIVEMAP: void 0 !== e.emissiveMap,
                            USE_REFLECTIONMASK: void 0 !== e.reflectionMask,
                            USE_EMISSIVECOLOR: void 0 !== e.emissiveColor
                        }
                    }, e), a.call(this, e), this.onPropertyChange("color", function(e) {
                        this.uniforms.diffuse.value = e
                    }), this.onPropertyChange("map", function(e) {
                        this.uniforms.map.value = e, e && this.uniforms.offsetRepeat.value.set(e.offset.x, e.offset.y, e.repeat.x, e.repeat.y)
                    }), this.onPropertyChange("opacity", function(e) {
                        this.uniforms.opacity.value = e
                    }), this.onPropertyChange("emissive", function(e) {
                        this.uniforms.emissive.value = e
                    }), this.onPropertyChange("lightMap", function(e) {
                        this.uniforms.lightMap.value = e, this.defines.LIGHTMAP_ENABLED = !!e
                    }), this.onPropertyChange("skinning", function(e) {
                        this.useVertexTexture = !!e, this.defines.SKINNED = !!e
                    }), this.onPropertyChange("envMap", function(e) {
                        this.uniforms.envMap.value = e
                    }), this.onPropertyChange("reflectivity", function(e) {
                        this.uniforms.reflectivity.value = e
                    }), this.onPropertyChange("shininess", function(e) {
                        this.uniforms.shininess.value = e
                    }), this.onPropertyChange("specular", function(e) {
                        this.uniforms.specular.value = e
                    }), this.onPropertyChange("emissiveMap", function(e) {
                        this.uniforms.emissiveMap.value = e
                    }), this.onPropertyChange("emissiveColor", function(e) {
                        this.uniforms.emissiveColor.value = new THREE.Color(e)
                    }), this.onPropertyChange("emissiveIntensity", function(e) {
                        this.uniforms.emissiveIntensity.value = e
                    }), this.onPropertyChange("normalMap", function(e) {
                        this.uniforms.normalMap.value = e
                    }), this.onPropertyChange("specularMap", function(e) {
                        e && (this.uniforms.specularMap.value = e)
                    }), this.onPropertyChange("reflectionMask", function(e) {
                        e && (this.uniforms.reflectionMask.value = e)
                    }), this.fog = e.fog || !0, this.opacity = 1, this.color = new THREE.Color(e.color || 16777215), this.map = e.map || null, this.emissive = new THREE.Color(e.emissive || 0), this.lightMap = e.lightMap || null, this.skinning = e.skinning || !1, this.envMap = e.envMap || null, this.reflectivity = e.reflectivity || 1, this.shininess = e.shininess || 30, this.specular = new THREE.Color(e.specular || 1118481), this.emissiveColor = new THREE.Color(e.emissiveColor || 16777215), this.normalMap = e.normalMap || null, this.specularMap = e.specularMap || null, this.combine = e.combine || THREE.MultiplyOperation, this.reflectionMask = e.reflectionMask || null, this.emissiveMap = e.emissiveMap || null, this.emissiveIntensity = e.emissiveIntensity || 1
                };
            s.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                lightMap: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                specularMap: {
                    type: "t",
                    value: null
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                pointLightColor: {
                    type: "fv",
                    value: []
                },
                pointLightPosition: {
                    type: "fv",
                    value: []
                },
                pointLightDistance: {
                    type: "fv1",
                    value: []
                },
                directionalLightDirection: {
                    type: "fv",
                    value: []
                },
                directionalLightColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightDirection: {
                    type: "fv",
                    value: []
                },
                hemisphereLightSkyColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightGroundColor: {
                    type: "fv",
                    value: []
                },
                spotLightColor: {
                    type: "fv",
                    value: []
                },
                spotLightPosition: {
                    type: "fv",
                    value: []
                },
                spotLightDirection: {
                    type: "fv",
                    value: []
                },
                spotLightDistance: {
                    type: "fv1",
                    value: []
                },
                spotLightAngleCos: {
                    type: "fv1",
                    value: []
                },
                spotLightExponent: {
                    type: "fv1",
                    value: []
                },
                spotLightDecay: {
                    type: "fv1",
                    value: []
                },
                envMap: {
                    type: "t",
                    value: null
                },
                flipEnvMap: {
                    type: "f",
                    value: -1
                },
                reflectivity: {
                    type: "f",
                    value: .15
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                },
                normalMap: {
                    type: "t",
                    value: null
                },
                normalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                emissiveMap: {
                    type: "t",
                    value: null
                },
                emissiveColor: {
                    type: "c",
                    value: null
                },
                emissiveIntensity: {
                    type: "f",
                    value: 1
                },
                reflectionMask: {
                    type: "t",
                    value: null
                }
            }, s.inherit(a, {
                clone: function(e) {
                    var t = e || new s;
                    return a.prototype.clone.call(this, e), t.map = this.map, t.envMap = this.envMap, t.transparent = this.transparent, t.emissive = this.emissive, t.fog = this.fog, t.color = this.color, t.specular = this.specular, t.shininess = this.shininess, t.reflectivity = this.reflectivity, t
                },
                refreshLightUniforms: function() {
                    var e = new THREE.Vector3,
                        t = new THREE.Vector3;
                    return function(n) {
                        var r = this.uniforms.directionalLightColor.value,
                            o = this.uniforms.directionalLightDirection.value,
                            a = this.uniforms.hemisphereLightSkyColor.value,
                            s = this.uniforms.hemisphereLightGroundColor.value,
                            l = this.uniforms.hemisphereLightDirection.value,
                            c = this.uniforms.pointLightColor.value,
                            h = this.uniforms.pointLightPosition.value,
                            u = this.uniforms.pointLightDistance.value,
                            f = this.uniforms.spotLightColor.value,
                            d = this.uniforms.spotLightPosition.value,
                            p = this.uniforms.spotLightDistance.value,
                            m = this.uniforms.spotLightDirection.value,
                            v = this.uniforms.spotLightAngleCos.value,
                            g = this.uniforms.spotLightExponent.value,
                            y = this.uniforms.spotLightDecay.value,
                            x = 0,
                            w = 0,
                            _ = 0,
                            b = 0,
                            E = 0,
                            M = 0,
                            S = 0,
                            T = 0;
                        n.forEach(function(n, C) {
                            n.visible && (n instanceof THREE.PointLight ? (x = 3 * E, i(c, x, n.color, n.intensity), e.setFromMatrixPosition(n.matrixWorld), h[x] = e.x, h[x + 1] = e.y, h[x + 2] = e.z, u[C] = n.distance, E += 1) : n instanceof THREE.DirectionalLight ? (w = 3 * M, t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(n.target.matrixWorld), t.sub(e), t.normalize(), o[w] = t.x, o[w + 1] = t.y, o[w + 2] = t.z, i(r, w, n.color, n.intensity), M += 1) : n instanceof THREE.HemisphereLight ? (t.setFromMatrixPosition(n.matrixWorld), t.normalize(), _ = 3 * S, l[_] = t.x, l[_ + 1] = t.y, l[_ + 2] = t.z, skyColor = n.color, groundColor = n.groundColor, i(a, _, skyColor, n.intensity), i(s, _, groundColor, n.intensity), S += 1) : n instanceof THREE.SpotLight && (b = 3 * T, i(f, b, n.color, n.intensity), t.setFromMatrixPosition(n.matrixWorld), d[b] = t.x, d[b + 1] = t.y, d[b + 2] = t.z, p[T] = n.distance, e.setFromMatrixPosition(n.target.matrixWorld), t.sub(e), t.normalize(), m[b] = t.x, m[b + 1] = t.y, m[b + 2] = t.z, v[T] = Math.cos(n.angle), g[T] = n.exponent, y[T] = 0 === n.distance ? 0 : n.decay, T += 1))
                        }, this)
                    }
                }()
            }), t.exports = s
        }, {
            35: 35
        }
    ],
    39: [
        function(e, t, n) {
            var i = "varying vec3 vWorldPos;\n#ifdef USE_COLOR\n    attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n        attribute vec3 morphNormal0;\n        attribute vec3 morphNormal1;\n        attribute vec3 morphNormal2;\n        attribute vec3 morphNormal3;\n    #else\n        attribute vec3 morphTarget4;\n        attribute vec3 morphTarget5;\n        attribute vec3 morphTarget6;\n        attribute vec3 morphTarget7;\n    #endif\n#endif\n\n#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n    varying vec3 vNormal;\n#endif\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n    uniform vec4 offsetRepeat;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n\n#endif\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    varying vec3 vReflect;\n\n    uniform float refractionRatio;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n#ifdef USE_MORPHTARGETS\n\n    #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif\n#ifdef USE_SKINNING\n\n    uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n        uniform int boneTextureHeight;\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n\n            float dx = 1.0 / float( boneTextureWidth );\n            float dy = 1.0 / float( boneTextureHeight );\n\n            y = dy * ( y + 0.5 );\n\n            vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n            vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n            vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n            vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n            mat4 bone = mat4( v1, v2, v3, v4 );\n\n            return bone;\n\n        }\n\n    #else\n\n        uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneGlobalMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n    uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\nvoid main() {\n    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n    vUv2 = uv2;\n\n#endif\n#ifdef USE_COLOR\n\n    vColor.xyz = inputToLinear( color.xyz );\n\n#endif\n#ifdef USE_MORPHNORMALS\n\n    vec3 morphedNormal = vec3( 0.0 );\n\n    morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n    morphedNormal += normal;\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n#ifdef USE_SKINNING\n\n    mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n    #ifdef USE_MORPHNORMALS\n\n    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n    #else\n\n    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n    #endif\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n    vec3 objectNormal = morphedNormal;\n\n#else\n\n    vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n    objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifndef FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n#endif\n#ifdef USE_MORPHTARGETS\n\n    vec3 morphed = vec3( 0.0 );\n    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n    morphed += position;\n\n#endif\n#ifdef USE_SKINNING\n\n    #ifdef USE_MORPHTARGETS\n\n    vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n    vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n    #endif\n\n    vec4 skinned = vec4( 0.0 );\n    skinned += boneMatX * skinVertex * skinWeight.x;\n    skinned += boneMatY * skinVertex * skinWeight.y;\n    skinned += boneMatZ * skinVertex * skinWeight.z;\n    skinned += boneMatW * skinVertex * skinWeight.w;\n    skinned  = bindMatrixInverse * skinned;\n\n#endif\n\n#ifdef USE_SKINNING\n\n    vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n    vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n\n#ifdef USE_LOGDEPTHBUF\n\n    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n    #endif\n\n#endif\n    vViewPosition = -mvPosition.xyz;\n#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n    #ifdef USE_SKINNING\n\n        vec4 worldPosition = modelMatrix * skinned;\n\n    #elif defined( USE_MORPHTARGETS )\n\n        vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n    #else\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n    vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n    #ifdef ENVMAP_MODE_REFLECTION\n\n        vReflect = reflect( cameraToVertex, worldNormal );\n\n    #else\n\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    vWorldPosition = worldPosition.xyz;\n\n#endif\n#ifdef USE_SHADOWMAP\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n    }\n\n#endif\n}",
                r = "varying vec3 vWorldPos;\nuniform float envMapOffset;\nuniform float flipWorldPos;\n\n#ifdef USE_REFLECTIONMASK\n    uniform sampler2D reflectionMask;\n#endif\n\n#define PHONG\nuniform vec3 diffuse;\nvarying vec3 vPosition;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n    return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n    float distance = dot( planeNormal, point-pointOnPlane );\n    return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n    return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n    if ( decayExponent > 0.0 ) {\n      return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n    }\n    return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n    return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n    return a;\n#endif\n}\n\n#ifdef USE_COLOR\n\n    varying vec3 vColor;\n\n#endif\n\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n    varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n    uniform sampler2D map;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    uniform sampler2D alphaMap;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    varying vec2 vUv2;\n    uniform sampler2D lightMap;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n    uniform sampler2D emissiveMap;\n    uniform float emissiveIntensity;\n\n    #ifdef USE_EMISSIVECOLOR\n        uniform vec3 emissiveColor;\n    #endif\n\n#endif\n#ifdef USE_ENVMAP\n\n    uniform float reflectivity;\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    uniform float flipEnvMap;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        uniform float refractionRatio;\n\n    #else\n\n        varying vec3 vReflect;\n\n    #endif\n\n#endif\n\n#ifdef USE_FOG\n\n    uniform vec3 fogColor;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n    #endif\n\n#endif\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n    uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n    uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n    uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n    uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n    uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n    uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n    varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n    uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n    varying vec3 vNormal;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    uniform sampler2D shadowMap[ MAX_SHADOWS ];\n    uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n    uniform float shadowDarkness[ MAX_SHADOWS ];\n    uniform float shadowBias[ MAX_SHADOWS ];\n\n    varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n    float unpackDepth( const in vec4 rgba_depth ) {\n\n        const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n        float depth = dot( rgba_depth, bit_shift );\n        return depth;\n\n    }\n\n#endif\n#ifdef USE_BUMPMAP\n\n    uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n    // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n    vec2 dHdxy_fwd() {\n\n        vec2 dSTdx = dFdx( vUv );\n        vec2 dSTdy = dFdy( vUv );\n\n        float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n        float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n        return vec2( dBx, dBy );\n\n    }\n\n    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n        vec3 vSigmaX = dFdx( surf_pos );\n        vec3 vSigmaY = dFdy( surf_pos );\n        vec3 vN = surf_norm;        // normalized\n\n        vec3 R1 = cross( vSigmaY, vN );\n        vec3 R2 = cross( vN, vSigmaX );\n\n        float fDet = dot( vSigmaX, R1 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n        return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n    uniform sampler2D normalMap;\n    uniform vec2 normalScale;\n\n    // Per-Pixel Tangent Space Normal Mapping\n    // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n        vec3 q0 = dFdx( eye_pos.xyz );\n        vec3 q1 = dFdy( eye_pos.xyz );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n\n        vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n        vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n        vec3 N = normalize( surf_norm );\n\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n        mapN.xy = normalScale * mapN.xy;\n        mat3 tsn = mat3( S, T, N );\n        return normalize( tsn * mapN );\n\n    }\n\n#endif\n\n#ifdef USE_SPECULARMAP\n\n    uniform sampler2D specularMap;\n\n#endif\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\nvoid main() {\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n    gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif\n#ifdef USE_MAP\n\n    vec4 texelColor = texture2D( map, vUv );\n\n    texelColor.xyz = inputToLinear( texelColor.xyz );\n\n    diffuseColor *= texelColor;\n\n#endif\n#ifdef USE_COLOR\n\n    diffuseColor.rgb *= vColor;\n\n#endif\n#ifdef USE_ALPHAMAP\n\n    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif\n#ifndef FLAT_SHADED\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n        normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n    #endif\n\n#else\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n    normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        // diffuse\n\n        float dotProduct = dot( normal, lVector );\n\n        #ifdef WRAP_AROUND\n\n            float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n            float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n                // specular\n\n        vec3 pointHalfVector = normalize( lVector + viewPosition );\n        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n    }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n    for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n        vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n        vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n        float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n        lVector = normalize( lVector );\n\n        float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n        if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n            spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n            // diffuse\n\n            float dotProduct = dot( normal, lVector );\n\n            #ifdef WRAP_AROUND\n\n                float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n                float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n                vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n            #else\n\n                float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n            #endif\n\n            totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n            // specular\n\n            vec3 spotHalfVector = normalize( lVector + viewPosition );\n            float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n            float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n            float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n            vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n            totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n        }\n\n    }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n        vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( normal, dirVector );\n\n        #ifdef WRAP_AROUND\n\n            float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n            float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n            vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n        #else\n\n            float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n        #endif\n\n        totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n        // specular\n\n        vec3 dirHalfVector = normalize( dirVector + viewPosition );\n        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n        /*\n        // fresnel term from skin shader\n        const float F0 = 0.128;\n\n        float base = 1.0 - dot( viewPosition, dirHalfVector );\n        float exponential = pow( base, 5.0 );\n\n        float fresnel = exponential + F0 * ( 1.0 - exponential );\n        */\n\n        /*\n        // fresnel term from fresnel shader\n        const float mFresnelBias = 0.08;\n        const float mFresnelScale = 0.3;\n        const float mFresnelPower = 5.0;\n\n        float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n        */\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        //      dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n        totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n    }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n    for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n        vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n        // diffuse\n\n        float dotProduct = dot( normal, lVector );\n        float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n        vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n        totalDiffuseLight += hemiColor;\n\n        // specular (sky light)\n\n        vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n        float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n        float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n        // specular (ground light)\n\n        vec3 lVectorGround = -lVector;\n\n        vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n        float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n        float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n        float dotProductGround = dot( normal, lVectorGround );\n\n        float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n        vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n        vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n        totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n    }\n\n#endif\n\n#ifdef METAL\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n    outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n\n#ifdef USE_LIGHTMAP\n\n    outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif\n#ifdef USE_ENVMAP\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n        // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n        #ifdef ENVMAP_MODE_REFLECTION\n\n            vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n        #else\n\n            vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n        #endif\n\n    #else\n\n        vec3 reflectVec = vReflect;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    #else\n        float flipNormal = 1.0;\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n        reflectVec.z += envMapOffset;\n        vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n        vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n    #endif\n\n    envColor.xyz = inputToLinear( envColor.xyz );\n\n    #ifdef USE_REFLECTIONMASK\n\n        vec4 maskTexel = texture2D(reflectionMask, vUv);\n        float chromeReflectivity = 0.75;\n        float plasticReflectivity = 0.1;\n\n        // Mix when area is chrome (red component in mask)\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * maskTexel.r * chromeReflectivity);\n\n        // Add when area is shiny plastic / glass (blue component in mask)\n        outgoingLight += (envColor.xyz * specularStrength * maskTexel.b * plasticReflectivity);\n\n\n        #ifdef USE_PAINTMASK\n            // Mix when area is carpaint\n            outgoingLight = mix ( outgoingLight, envColor.xyz, specularStrength * reflectivity * texelPaintMask.r);\n        #endif\n\n    #else\n\n        #ifdef ENVMAP_BLENDING_MULTIPLY\n\n            outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_MIX )\n\n            outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n        #elif defined( ENVMAP_BLENDING_ADD )\n\n            outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n        #endif\n\n    #endif\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n    #ifdef SHADOWMAP_DEBUG\n\n        vec3 frustumColors[3];\n        frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n        frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n        frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n    #endif\n\n    #ifdef SHADOWMAP_CASCADE\n\n        int inFrustumCount = 0;\n\n    #endif\n\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n\n    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n                // if ( something && something ) breaks ATI OpenGL shader compiler\n                // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n                // don't shadow pixels outside of light frustum\n                // use just first frustum (for cascades)\n                // don't shadow pixels behind far plane of light frustum\n\n        #ifdef SHADOWMAP_CASCADE\n\n            inFrustumCount += int( inFrustum );\n            bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n        #else\n\n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        #endif\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n            shadowCoord.z += shadowBias[ i ];\n\n            #if defined( SHADOWMAP_TYPE_PCF )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n        /*\n                        // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n                        // must enroll loop manually\n\n                for ( float y = -1.25; y <= 1.25; y += 1.25 )\n                    for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n                        vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n                                //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n                        float fDepth = unpackDepth( rgbaDepth );\n\n                        if ( fDepth < shadowCoord.z )\n                            shadow += 1.0;\n\n                }\n\n                shadow /= 9.0;\n\n        */\n\n                const float shadowDelta = 1.0 / 9.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.25 * xPixelOffset;\n                float dy0 = -1.25 * yPixelOffset;\n                float dx1 = 1.25 * xPixelOffset;\n                float dy1 = 1.25 * yPixelOffset;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n                if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n                        // Percentage-close filtering\n                        // (9 pixel kernel)\n                        // http://fabiensanglard.net/shadowmappingPCF/\n\n                float shadow = 0.0;\n\n                float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n                float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n                float dx0 = -1.0 * xPixelOffset;\n                float dy0 = -1.0 * yPixelOffset;\n                float dx1 = 1.0 * xPixelOffset;\n                float dy1 = 1.0 * yPixelOffset;\n\n                mat3 shadowKernel;\n                mat3 depthKernel;\n\n                depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n                depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n                depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n                depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n                depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n                depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n                depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n                depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n                depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n                vec3 shadowZ = vec3( shadowCoord.z );\n                shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n                shadowKernel[0] *= vec3(0.25);\n\n                shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n                shadowKernel[1] *= vec3(0.25);\n\n                shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n                shadowKernel[2] *= vec3(0.25);\n\n                vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n                shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n                shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n                vec4 shadowValues;\n                shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n                shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n                shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n                shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n                shadow = dot( shadowValues, vec4( 1.0 ) );\n\n                shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n            #else\n\n                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n                float fDepth = unpackDepth( rgbaDepth );\n\n                if ( fDepth < shadowCoord.z )\n\n        // spot with multiple shadows is darker\n\n                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n        // spot with multiple shadows has the same color as single shadow spot\n\n        //                  shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n            #endif\n\n        }\n\n\n        #ifdef SHADOWMAP_DEBUG\n\n            #ifdef SHADOWMAP_CASCADE\n\n                if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n            #else\n\n                if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n            #endif\n\n        #endif\n\n    }\n\n    // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n    shadowColor = inputToLinear( shadowColor );\n\n    outgoingLight = outgoingLight * shadowColor;\n\n#endif\n\n\n    outgoingLight = linearToOutput( outgoingLight );\n\n#ifdef USE_FOG\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n    #else\n\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #endif\n\n    #ifdef FOG_EXP2\n\n        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n        fogFactor = whiteCompliment( fogFactor );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n    #endif\n\n    outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif\n\n#ifdef USE_EMISSIVEMAP\n        float emissiveness = texture2D(emissiveMap, vUv).r;\n        vec3 ec = vec3(1.0);\n\n        #ifdef USE_EMISSIVECOLOR\n            ec = emissiveColor;\n        #endif\n\n        gl_FragColor = vec4( mix(outgoingLight.rgb, (texelColor.rgb + (vec3(1.0) * emissiveIntensity)) * ec, emissiveness * emissiveIntensity), diffuseColor.a );\n#else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#endif\n\n    float blackness = 1.0 - (smoothstep(0.7, 1.1, vWorldPos.x * flipWorldPos));\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), blackness);\n}",
                o = e("35"),
                a = e("38"),
                s = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(s.uniforms),
                        defines: {
                            USE_AOMAP: !1,
                            LIGHTMAP_ENABLED: !1,
                            SKINNED: !1,
                            USE_EMISSIVEMAP: void 0 !== e.emissiveMap,
                            USE_REFLECTIONMASK: void 0 !== e.reflectionMask,
                            USE_PAINTMASK: void 0 !== e.paintMask,
                            USE_EMISSIVECOLOR: void 0 !== e.emissiveColor,
                            TRANSPARENT_MODE: !1
                        }
                    }, e), a.call(this, e), this.type = "rim", this.onPropertyChange("paintMask", function(e) {
                        e && (this.uniforms.paintMask.value = e)
                    }), this.onPropertyChange("envMapOffset", function(e) {
                        this.uniforms.envMapOffset.value = e
                    }), this.paintMask = e.paintMask || null, this.uniforms.flipWorldPos.value = "left" === e.carSide ? 1 : -1
                };
            s.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                lightMap: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                pointLightColor: {
                    type: "fv",
                    value: []
                },
                pointLightPosition: {
                    type: "fv",
                    value: []
                },
                pointLightDistance: {
                    type: "fv1",
                    value: []
                },
                directionalLightDirection: {
                    type: "fv",
                    value: []
                },
                directionalLightColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightDirection: {
                    type: "fv",
                    value: []
                },
                hemisphereLightSkyColor: {
                    type: "fv",
                    value: []
                },
                hemisphereLightGroundColor: {
                    type: "fv",
                    value: []
                },
                spotLightColor: {
                    type: "fv",
                    value: []
                },
                spotLightPosition: {
                    type: "fv",
                    value: []
                },
                spotLightDirection: {
                    type: "fv",
                    value: []
                },
                spotLightDistance: {
                    type: "fv1",
                    value: []
                },
                spotLightAngleCos: {
                    type: "fv1",
                    value: []
                },
                spotLightExponent: {
                    type: "fv1",
                    value: []
                },
                spotLightDecay: {
                    type: "fv1",
                    value: []
                },
                lightVariance: {
                    type: "f",
                    value: 0
                },
                envMap: {
                    type: "t",
                    value: null
                },
                flipEnvMap: {
                    type: "f",
                    value: -1
                },
                reflectivity: {
                    type: "f",
                    value: .15
                },
                refractionRatio: {
                    type: "f",
                    value: .98
                },
                normalMap: {
                    type: "t",
                    value: null
                },
                normalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                emissiveMap: {
                    type: "t",
                    value: null
                },
                emissiveColor: {
                    type: "c",
                    value: null
                },
                emissiveIntensity: {
                    type: "f",
                    value: 1
                },
                reflectionMask: {
                    type: "t",
                    value: null
                },
                paintMask: {
                    type: "t",
                    value: null
                },
                envMapOffset: {
                    type: "f",
                    value: 0
                },
                flipWorldPos: {
                    type: "f",
                    value: 1
                }
            }, s.inherit(a, {
                clone: function(e) {
                    var t = e || new s;
                    return o.prototype.clone.call(this, e), t.map = this.map, t.envMap = this.envMap, t.transparent = this.transparent, t.emissive = this.emissive, t.fog = this.fog, t.color = this.color, t.specular = this.specular, t.shininess = this.shininess, t.reflectivity = this.reflectivity, t
                }
            }), t.exports = s
        }, {
            35: 35,
            38: 38
        }
    ],
    40: [
        function(e, t, n) {
            var i = "varying vec3 vWorldPos;\n\n#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 offsetRepeat;\n#endif\n\nvoid main() {\n  #ifdef USE_MAP\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n  #endif\n\n  vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
                r = "varying vec3 vWorldPos;\nuniform vec3 glowPosition;\nuniform vec3 baseColor;\nuniform vec3 glowColor;\nuniform vec3 bgColor;\nuniform float gradientHeight;\nuniform float brightness;\n\n#ifdef USE_MAP\n  varying vec2 vUv;\n\n  uniform sampler2D map;\n#endif\n\nuniform vec3 fogColor;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main() {\n  gl_FragColor = vec4(diffuse * brightness, opacity);\n\n  #ifdef USE_MAP\n    gl_FragColor = gl_FragColor * texture2D(map, vUv);\n  #endif\n\n  #ifdef ALPHATEST\n    if ( gl_FragColor.a < ALPHATEST ) discard;\n  #endif\n\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);\n\n  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);\n\n  // vertical gradient\n  float m = 1.0 - (smoothstep(0.0, gradientHeight, vWorldPos.y));\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, baseColor, m * brightness);\n\n  // white light\n  float d = distance(vWorldPos, glowPosition);\n  m = 1.0 - (smoothstep(10.0, 15.0, d));\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, glowColor, m * brightness);\n\n  // gray gradient\n  m = smoothstep(5.0, 20.0, vWorldPos.z - (vWorldPos.x * 0.3));\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, baseColor, m * brightness);\n\n  // fade to bgColor\n  m = smoothstep(23.0, 25.0, vWorldPos.z - (vWorldPos.x * 0.45));\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, bgColor, m * brightness);\n\n  // fade to white\n  m = smoothstep(30.0, 35.0, abs(vWorldPos.x));\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, bgColor, m * brightness);\n\n}",
                o = e("30"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms)
                    }, e), o.call(this, e), this.onPropertyChange("glowPosition", function(e) {
                        this.uniforms.glowPosition.value = e
                    }), this.onPropertyChange("baseColor", function(e) {
                        this.uniforms.baseColor.value = e
                    }), this.onPropertyChange("glowColor", function(e) {
                        this.uniforms.glowColor.value = e
                    }), this.onPropertyChange("bgColor", function(e) {
                        this.uniforms.bgColor.value = e
                    }), this.onPropertyChange("gradientHeight", function(e) {
                        this.uniforms.gradientHeight.value = e
                    }), this.onPropertyChange("brightness", function(e) {
                        this.uniforms.brightness.value = e
                    }), this.bgColor = new THREE.Color(void 0 !== e.bgColor ? e.bgColor : 15658734), this.baseColor = new THREE.Color(void 0 !== e.baseColor ? e.baseColor : 16777215), this.glowColor = new THREE.Color(void 0 !== e.glowColor ? e.glowColor : 16777215), this.gradientHeight = void 0 !== e.gradientHeight ? e.gradientHeight : 5, this.glowPosition = e.glowPosition || new THREE.Vector3(5, 5, 5), this.brightness = e.brightness || 1
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                envMap: {
                    type: "t",
                    value: null
                },
                combine: {
                    type: "t",
                    value: 0
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                baseColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                bgColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                glowColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                gradientHeight: {
                    type: "f",
                    value: 5
                },
                glowPosition: {
                    type: "v3",
                    value: new THREE.Vector3(5, 5, 5)
                },
                brightness: {
                    type: "f",
                    value: 1
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.map = this.map, t.transparent = this.transparent, t
                }
            }), t.exports = a
        }, {
            30: 30
        }
    ],
    41: [
        function(e, t, n) {
            var i = "#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 offsetRepeat;\n#endif\n\nuniform float cameraDistance;\n\nvoid main() {\n  #ifdef USE_MAP\n    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n  #endif\n\n  float scale = 1.0 + (0.5 * (1.0 - smoothstep(3.0, 9.0, cameraDistance)));\n\n  gl_Position = vec4(position.x * scale, position.y * scale, 0.0, 1.0);\n}",
                r = "#ifdef USE_MAP\n  varying vec2 vUv;\n\n  uniform sampler2D map;\n#endif\n\nuniform vec3 fogColor;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float fogNear;\nuniform float fogFar;\n\nvoid main() {\n  gl_FragColor = vec4(diffuse, opacity);\n\n  #ifdef USE_MAP\n    gl_FragColor = gl_FragColor * texture2D(map, vUv);\n  #endif\n\n  #ifdef ALPHATEST\n    if ( gl_FragColor.a < ALPHATEST ) discard;\n  #endif\n\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\n  float fogFactor = clamp((depth - fogNear) / (fogFar - fogNear), 0.0, 1.0);\n\n  gl_FragColor = mix(gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor);\n}",
                o = e("30"),
                a = function(e) {
                    e = _.extend({
                        vertexShader: i,
                        fragmentShader: r,
                        uniforms: THREE.UniformsUtils.clone(a.uniforms)
                    }, e), o.call(this, e)
                };
            a.uniforms = {
                diffuse: {
                    type: "c",
                    value: new THREE.Color(15658734)
                },
                opacity: {
                    type: "f",
                    value: 1
                },
                map: {
                    type: "t",
                    value: null
                },
                offsetRepeat: {
                    type: "v4",
                    value: new THREE.Vector4(0, 0, 1, 1)
                },
                envMap: {
                    type: "t",
                    value: null
                },
                combine: {
                    type: "t",
                    value: 0
                },
                fogNear: {
                    type: "f",
                    value: 1
                },
                fogFar: {
                    type: "f",
                    value: 2e3
                },
                fogColor: {
                    type: "c",
                    value: new THREE.Color(16777215)
                },
                cameraDistance: {
                    type: "f",
                    value: 8
                }
            }, a.inherit(o, {
                clone: function(e) {
                    var t = e || new a;
                    return Material.prototype.clone.call(this, e), t.map = this.map, t.transparent = this.transparent, t
                }
            }), t.exports = a
        }, {
            30: 30
        }
    ],
    42: [
        function(e, t, n) {
            var i = e("21"),
                r = e("14"),
                o = function(e) {
                    THREE.Object3D.call(this);
                    var t = i.getMeshData(e.animation).geometry,
                        n = i.parseBones(t, !0),
                        o = this.animation = new r({
                            node: n,
                            data: t.animation,
                            sequences: e.sequences
                        });
                    if (this.add(n), e.debug) {
                        var a = [];
                        n.traverse(function(e) {
                            a.push(e)
                        }), a.forEach(function(e) {
                            e.add(i.createDebugCube(.02))
                        })
                    }
                    o.loop = e.loop || !1, o.play(0), o.update(0), o.stop(), o.started = !1
                };
            o.inherit(THREE.Object3D, {
                addToBone: function(e, t) {
                    var n = this.getObjectByName(t);
                    if (!n) throw Error("Bone not found:" + t);
                    n.add(e)
                },
                removeFromBone: function(e, t) {
                    var n = this.getObjectByName(t);
                    if (!n) throw Error("Bone not found:" + t);
                    n.remove(e)
                },
                animate: function(e) {
                    if (this.animation.isPlaying) return this.animation._deferred;
                    var t = this.animation._deferred = new $.Deferred;
                    return this.animation.timeScale = e ? -1 : 1, this.animation.play(e ? this.getAnimationDuration() : 0), t.promise()
                },
                getAnimationDuration: function() {
                    return this.animation.data.length
                },
                update: function(e) {
                    this.animation.update(e.delta), this.animation.started && !this.animation.isPlaying && (this.dispatchEvent({
                        type: "stop"
                    }), this.animation._deferred && this.animation._deferred.resolve())
                }
            }), t.exports = o
        }, {
            14: 14,
            21: 21
        }
    ],
    43: [
        function(e, t, n) {
            var i = function(e) {
                e = _.extend({
                    fov: 30,
                    aspectRatio: window.innerWidth / window.innerHeight,
                    near: 1,
                    far: 1e4
                }, e), THREE.PerspectiveCamera.call(this, e.fov, e.aspectRatio, e.near, e.far), this.name = e.name, this.direction = new THREE.Vector3
            };
            i.inherit(THREE.PerspectiveCamera, {
                lookAt: function(e) {
                    THREE.PerspectiveCamera.prototype.lookAt.call(this, e), this.target = e
                },
                setAspectRatio: function(e) {
                    this.aspect = e, this.updateProjectionMatrix()
                },
                updateMatrixWorld: function(e) {
                    THREE.PerspectiveCamera.prototype.updateMatrixWorld.call(this, e), this.updateDirection()
                },
                updateDirection: function() {
                    var e = this.localToWorld(new THREE.Vector3(0, 0, -1)),
                        t = (new THREE.Vector3).setFromMatrixPosition(this.matrixWorld);
                    this.direction.subVectors(e, t).normalize()
                }
            }), t.exports = i
        }, {}
    ],
    44: [
        function(e, t, n) {
            var i = e("21"),
                r = e("17"),
                o = e("55"),
                a = (e("57"), e("53")),
                s = (e("43"), e("42"), e("60")),
                l = e("49"),
                c = (e("34"), e("31")),
                h = e("38"),
                u = e("32"),
                f = function() {
                    THREE.Object3D.call(this), this.cubeMapLightSoft = i.getTextureCube("car/envmap/light/", ["posx-blurry.jpg", "negx-blurry.jpg", "posy-blurry.jpg", "negy-blurry.jpg", "posz-blurry.jpg", "negz-blurry.jpg"]), this.cubeMapLightSharp = i.getTextureCube("car/envmap/light/", ["posx.jpg", "negx.jpg", "posy.jpg", "negy.jpg", "posz.jpg", "negz.jpg"]), this.cubeMapDarkSoft = i.getTextureCube("car/envmap/dark/", ["posx-blurry.jpg", "negx-blurry.jpg", "posy-blurry.jpg", "negy-blurry.jpg", "posz-blurry.jpg", "negz-blurry.jpg"]), this.cubeMapDarkSharp = i.getTextureCube("car/envmap/dark", ["posx.jpg", "negx.jpg", "posy.jpg", "negy.jpg", "posz.jpg", "negz.jpg"]), this.cubeMapInterior = i.getTextureCube("car/envmap/interior", ["posx.jpg", "negx.jpg", "posy.jpg", "negy.jpg", "posz.jpg", "negz.jpg"]);
                    var e = i.getTexture("car/shadow/car-shadow.png"),
                        t = i.getTexture("car/exterior/JFC_Body.png"),
                        n = i.getTexture("car/normalmap/JFC_Body_NM.png"),
                        o = i.getTexture("car/exterior/JFC_Body_EM.png"),
                        a = i.getTexture("car/exterior/JFC_Ext_Carrosserie_Mask.png"),
                        s = i.getTexture("car/exterior/JFC_Body_Mask.png"),
                        l = i.getTexture("car/exterior/frontplate.png"),
                        h = i.getTexture("car/exterior/rearplate.png");
                    this.hotspots = [], this.materials = {
                        body: new c({
                            map: t,
                            color: r[2],
                            color2: r[3],
                            envMap: this.cubeMapLightSoft,
                            combine: THREE.MixOperation,
                            reflectivity: .15,
                            shininess: 30,
                            specular: 3355443,
                            normalMap: n,
                            emissiveIntensity: .75,
                            emissiveMap: o,
                            emissiveColor: 16728128,
                            paintMask: a,
                            reflectionMask: s,
                            envMapOffset: 0,
                            transparent: !1,
                            flipN: !1
                        }),
                        bodyFlip: new c({
                            map: t,
                            color: r[2],
                            color2: r[3],
                            envMap: this.cubeMapLightSoft,
                            combine: THREE.MixOperation,
                            reflectivity: .15,
                            shininess: 30,
                            specular: 3355443,
                            normalMap: n,
                            emissiveIntensity: .75,
                            emissiveMap: o,
                            emissiveColor: 16728128,
                            paintMask: a,
                            reflectionMask: s,
                            envMapOffset: 0,
                            transparent: !1,
                            flipN: !0
                        }),
                        glass: new u({
                            color: 0,
                            map: t,
                            envMap: this.cubeMapLightSharp,
                            transparent: !0,
                            combine: THREE.AddOperation,
                            reflectivity: .35,
                            envMapOffset: 0,
                            side: THREE.FrontSide,
                            opacity: 1
                        }),
                        shadow: new THREE.MeshBasicMaterial({
                            color: 16777215,
                            map: e,
                            transparent: !0,
                            opacity: 1,
                            depthWrite: !1
                        }),
                        rearlight: new c({
                            map: t,
                            color: r[2],
                            color2: r[3],
                            envMap: this.cubeMapLightSharp,
                            combine: THREE.AddOperation,
                            reflectivity: .3,
                            emissiveIntensity: .75,
                            emissiveMap: o,
                            emissiveColor: 16728128,
                            envMapOffset: 0
                        }),
                        frontPlate: new THREE.MeshBasicMaterial({
                            transparent: !0,
                            map: l
                        }),
                        rearPlate: new THREE.MeshBasicMaterial({
                            transparent: !0,
                            map: h
                        }),
                        debug: new THREE.MeshBasicMaterial({
                            color: 16711935
                        })
                    }, this.initBody(), this.initExterior(), this.initInterior(), this.initDoor(), this.initWheels(), this.initShadow(), this.initFlares(), this.initPlates(), this.tweens = {
                        lights: new TWEEN.Tween,
                        shadowOpacity: new TWEEN.Tween,
                        emissive: new TWEEN.Tween,
                        wheelsColor: new TWEEN.Tween,
                        colorChange: new TWEEN.Tween,
                        glassOpacity: new TWEEN.Tween
                    }, this.rolling = !1, this.speed = 0
                };
            f.inherit(THREE.Object3D, {
                initBody: function() {
                    this.body = new THREE.Object3D, this.body.rotation.x = -Math.PI / 2, this.add(this.body)
                },
                initExterior: function() {
                    this.exterior = new o("exterior"), this.exterior.castShadow = !0, this.exterior.receiveShadow = !0, this.body.add(this.exterior), this.exterior.setMaterial("JFC_Body", this.materials.body), this.exterior.setMaterial("JFC_Body_Flip", this.materials.bodyFlip), this.exterior.setMaterial("JFC_Others", this.materials.body), this.exterior.setMaterial("JFC_Glass", this.materials.glass), this.exterior.setMaterial("JFC_Optic_Back", this.materials.rearlight), this.exterior.geometry.computeBoundingBox();
                    var e = this.exterior.geometry.boundingBox,
                        t = e.max.y + Math.abs(e.min.y) + .05;
                    this.materials.body.carLength = t, this.exterior.renderOrder = 1
                },
                initPlates: function() {
                    this.frontPlate = new THREE.Mesh(new THREE.PlaneBufferGeometry(.5, .5, 1, 1), this.materials.frontPlate), this.frontPlate.position.set(0, .32, 2.45), this.add(this.frontPlate), this.rearPlate = new THREE.Mesh(new THREE.PlaneBufferGeometry(.55, .55, 1, 1), this.materials.rearPlate), this.rearPlate.rotation.x = 1.1 * Math.PI, this.rearPlate.rotation.z = Math.PI, this.rearPlate.position.set(0, .485, -2.34), this.add(this.rearPlate)
                },
                initInterior: function() {
                    var e = i.getTexture("car/interior/JFC_Int_Front.jpg"),
                        t = i.getTexture("car/interior/JFC_Int_Back.jpg"),
                        n = i.getTexture("car/normalmap/JFC_Int_Front_NM.png"),
                        a = i.getTexture("car/normalmap/JFC_Int_Back_NM.png"),
                        s = i.getTexture("car/interior/JFC_Int_Front_EM.png"),
                        l = i.getTexture("car/interior/JFC_Int_Back_SM.png"),
                        u = i.getTexture("car/interior/JFC_Int_Back_EM.png"),
                        f = i.getTexture("car/interior/JFC_Int_Front_Mask.png"),
                        d = i.getTexture("car/interior/JFC_Int_Back_Mask.png"),
                        p = i.getTexture("car/interior/JFC_Int_Carrosserie_Mask.png");
                    this.materials.interiorFront = new c({
                        map: e,
                        color: r[2],
                        color2: r[3],
                        normalMap: n,
                        emissiveMap: s,
                        emissiveColor: 1700,
                        emissiveIntensity: 1,
                        shininess: 20,
                        reflectionMask: f,
                        envMap: this.cubeMapInterior,
                        envMapOffset: 0,
                        combine: THREE.MixOperation,
                        reflectivity: .15,
                        paintMask: p,
                        transparent: !0
                    }), this.materials.interiorBack = new h({
                        map: t,
                        color: 16777215,
                        normalMap: a,
                        specularMap: l,
                        reflectionMask: d,
                        shininess: 0,
                        reflectivity: 0,
                        emissiveMap: u,
                        emissiveIntensity: 1,
                        emissiveColor: 1700
                    }), this.interior = new o("interior"), this.exterior.add(this.interior), this.interior.renderOrder = 0, this.interior.setMaterial("JFC_Int_Front", this.materials.interiorFront), this.interior.setMaterial("JFC_Int_Back", this.materials.interiorBack)
                },
                initDoor: function() {
                    this.door = new l({
                        materials: this.materials
                    }), this.body.add(this.door)
                },
                initWheels: function() {
                    var e = .83,
                        t = .17,
                        n = 1.42,
                        i = 1.47,
                        r = new s({
                            envMap: this.cubeMapLightSharp,
                            carSide: "right"
                        });
                    r.position.set(-e, t, n);
                    var o = new s({
                        envMap: this.cubeMapLightSharp,
                        carSide: "left"
                    });
                    o.position.set(e, t, n), o.rotation.y = Math.PI;
                    var a = new s({
                        envMap: this.cubeMapLightSharp,
                        carSide: "right"
                    });
                    a.position.set(-e, t, -i);
                    var l = new s({
                        envMap: this.cubeMapLightSharp,
                        carSide: "left"
                    });
                    l.position.set(e, t, -i), l.rotation.y = Math.PI, this.wheels = [r, o, a, l], this.wheels.forEach(function(e) {
                        this.add(e)
                    }, this)
                },
                setSpeed: function(e) {
                    this.speed = e, this.wheels.forEach(function(t) {
                        t.speed = e
                    })
                },
                raise: function() {
                    this.boneStructure.animation.playSequence("in")
                },
                lower: function() {
                    this.boneStructure.animation.playSequence("out")
                },
                startRolling: function() {
                    this.rolling = !0, this.wheels.forEach(function(e) {
                        e.rotating = !0
                    })
                },
                stopRolling: function() {
                    this.rolling = !1, this.wheels.forEach(function(e) {
                        e.rotating = !1
                    })
                },
                toggleRolling: function() {
                    this.rolling = !this.rolling, this.rolling ? this.startRolling() : this.stopRolling()
                },
                openWheels: function() {
                    this.wheels.forEach(function(e) {
                        e.open()
                    })
                },
                closeWheels: function() {
                    this.wheels.forEach(function(e) {
                        e.close()
                    })
                },
                changeRim: function(e) {
                    this.wheels.forEach(function(t) {
                        t.changeRim(e)
                    })
                },
                initShadow: function() {
                    var e = new THREE.Mesh(new THREE.PlaneGeometry(6, 6, 1, 1), this.materials.shadow);
                    e.rotation.x = -Math.PI / 2, e.position.y -= .2, this.add(e), this.shadow = e
                },
                addHotspot: function(e) {
                    var t = new a(e);
                    this.add(t), this.hotspots.push(t), this.dispatchEvent({
                        type: "hotspot",
                        hotspot: t
                    })
                },
                initFlares: function() {
                    var e = new THREE.Object3D,
                        t = new THREE.SpriteMaterial({
                            map: i.getTexture("car/flare.png"),
                            blending: THREE.AdditiveBlending,
                            depthTest: !1,
                            transparent: !0,
                            opacity: 0
                        }),
                        n = 2,
                        r = new THREE.Sprite(t.clone());
                    r.position.set(.75, .65, 1.95), r.scale.set(n, n, n), r.orientation = new THREE.Vector3(.75, 0, 1), this.leftFlare = r, e.add(r);
                    var o = new THREE.Sprite(t.clone());
                    o.position.set(-.75, .65, 1.95), o.scale.set(n, n, n), o.orientation = new THREE.Vector3(-.75, 0, 1), this.rightFlare = o, e.add(o), this.lightsEnabled = !1, e.rotation.x = Math.PI / 2, this.body.add(e), this.flares = [r, o]
                },
                enableHeadlights: function() {
                    this.leftFlare.material.opacity = .9, this.rightFlare.material.opacity = .9, this.lightsEnabled = !0
                },
                disableHeadlights: function() {
                    this.leftFlare.material.opacity = 0, this.rightFlare.material.opacity = 0, this.lightsEnabled = !1
                },
                updateFlares: function(e) {
                    this.flares.forEach(function(t) {
                        this.updateFlare(t, e)
                    }, this)
                },
                updateFlare: function() {
                    var e = (new THREE.Vector3, new THREE.Vector3),
                        t = (new THREE.Vector3, new THREE.Vector3, new THREE.Vector3),
                        n = TWEEN.Easing.Quartic.Out,
                        i = 1.5;
                    return function(r, o) {
                        if (this.lightsEnabled) {
                            e.setFromMatrixPosition(o.matrixWorld), t.subVectors(e, r.position).normalize();
                            var a = r.orientation.dot(t),
                                s = THREE.Math.smoothstep(a, 0, 1),
                                l = THREE.Math.mapLinear(n(s), 0, 1, 0, i),
                                c = THREE.Math.mapLinear(l, 0, 2, 0, .9);
                            r.scale.set(l, l, l), r.material.opacity = c
                        }
                    }
                }(),
                updateHotspots: function(e) {
                    this.hotspots && this.hotspots.length > 0 && this.hotspots.forEach(function(t) {
                        t.update(e)
                    })
                },
                updateDoorAnimation: function(e) {
                    this.door.update(e)
                },
                updateWheelsAnimation: function(e) {
                    this.wheels.forEach(function(t) {
                        t.update(e)
                    })
                },
                animateDoor: function(e) {
                    return this.door.animate(e)
                },
                setColor: function(e) {
                    this.materials.body.color2.setHex(r[e]), this.materials.bodyFlip.color2.setHex(r[e]), this.materials.interiorFront.color = new THREE.Color(r[e]), i.tween(750, TWEEN.Easing.Sinusoidal.InOut).onUpdate(function(e) {
                        this.materials.body.colorTransition = e, this.materials.bodyFlip.colorTransition = e
                    }.bind(this)).onComplete(function() {
                        var e = this.materials.body.color;
                        this.materials.body.color = this.materials.body.color2, this.materials.bodyFlip.color = this.materials.bodyFlip.color2, this.materials.body.color2 = e, this.materials.bodyFlip.color2 = e, this.materials.body.colorTransition = 0, this.materials.bodyFlip.colorTransition = 0
                    }.bind(this))
                },
                setMode: function(e, t) {
                    "day" === e && (this.disableHeadlights(), this.materials.body.envMap = this.cubeMapLightSoft, this.materials.bodyFlip.envMap = this.cubeMapLightSoft, this.materials.glass.envMap = this.cubeMapLightSharp, this.materials.rearlight.emissiveIntensity = .75, this.materials.rearlight.envMap = this.cubeMapLightSharp, this.wheels.forEach(function(e) {
                        e.setEnvMap(this.cubeMapLightSharp)
                    }, this)), "night" === e && (this.enableHeadlights(), this.materials.body.envMap = this.cubeMapDarkSoft, this.materials.bodyFlip.envMap = this.cubeMapDarkSoft, this.materials.glass.envMap = this.cubeMapDarkSharp, this.materials.rearlight.emissiveIntensity = .85, this.materials.rearlight.envMap = this.cubeMapDarkSharp, this.wheels.forEach(function(e) {
                        e.setEnvMap(this.cubeMapDarkSharp)
                    }, this)), this.materials.body.needsUpdate = !0, this.materials.bodyFlip.needsUpdate = !0, this.materials.glass.needsUpdate = !0, this.materials.rearlight.needsUpdate = !0
                },
                setGlassOpacity: function(e) {
                    this.tweens.glassOpacity.reset(this.materials.glass).to({
                        opacity: e
                    }, 1500).easing(TWEEN.Easing.Linear.None).start()
                },
                flipGlassSide: function() {
                    this.materials.glass.side === THREE.FrontSide ? this.materials.glass.side = THREE.DoubleSide : this.materials.glass.side = THREE.FrontSide, this.materials.glass.needsUpdate = !0
                },
                enableTransparentMode: function() {
                    this.materials.body.transparent = !0, this.materials.body.transparentMode = !0, this.materials.bodyFlip.transparent = !0, this.materials.bodyFlip.transparentMode = !0, this.materials.glass.transparentMode = !0
                },
                disableTransparentMode: function() {
                    this.materials.body.transparent = !1, this.materials.body.transparentMode = !1, this.materials.bodyFlip.transparent = !1, this.materials.bodyFlip.transparentMode = !1, this.materials.glass.transparentMode = !1
                },
                update: function(e, t) {
                    this.updateFlares(t), this.updateHotspots(t), this.updateDoorAnimation(e), this.updateWheelsAnimation(e)
                }
            }), t.exports = f
        }, {
            17: 17,
            21: 21,
            31: 31,
            32: 32,
            34: 34,
            38: 38,
            42: 42,
            43: 43,
            49: 49,
            53: 53,
            55: 55,
            57: 57,
            60: 60
        }
    ],
    45: [
        function(e, t, n) {
            var i = e("21"),
                r = e("43"),
                o = function(e) {
                    THREE.Object3D.call(this);
                    var t = this.cinematicCamera = new r({
                            name: e.name,
                            near: .001,
                            far: 100
                        }),
                        n = i.getMeshData(e.animation).geometry,
                        o = i.parseBones(n, !0);
                    this.add(t), this.add(o), e.helper && this.add(new THREE.CameraHelper(t)), this.camera = t, this.bone = o.getObjectByName(e.boneName), this.animation = new THREE.Animation(o, n.animation), this.animation.loop = void 0 !== e.loop ? e.loop : !0, this.animation.duration = this.animation.data.length, this.reverse = !1, this.enabled = !1, this.started = !1, this.camera.matrixAutoUpdate = !1, this.camera.matrix = this.bone.matrixWorld
                };
            o.inherit(THREE.Object3D, {
                update: function(e) {
                    this.enabled ? (this.started || this.animation.isPlaying || (this.animation.timeScale = this.reverse ? -1 : 1, this.animation.play(this.reverse ? this.animation.duration : 0), this.started = !0), this.animation.update(e.delta), this.updateMatrixWorld(!0), this.camera.updateMatrixWorld(!0), this.started && !this.animation.isPlaying && (this.animation.currentTime = 0, this.dispatchEvent({
                        type: "stop"
                    }))) : this.animation.isPlaying && this.animation.stop()
                },
                getInitialState: function(e) {
                    var t = {
                            position: new THREE.Vector3,
                            target: new THREE.Vector3
                        },
                        n = this.enabled,
                        i = this.started,
                        r = this.animation.isPlaying;
                    return this.enabled = !0, this.started = !1, this.reverse = e, this.animation.isPlaying = !1, this.update({
                        delta: 0
                    }), t.position.setFromMatrixPosition(this.camera.matrixWorld), t.target.set(0, 0, -t.position.length()), this.camera.localToWorld(t.target), this.enabled = n, this.started = i, this.animation.isPlaying = r, t
                },
                toggle: function() {
                    this.enabled = !this.enabled
                }
            }), t.exports = o
        }, {
            21: 21,
            43: 43
        }
    ],
    46: [
        function(e, t, n) {
            var i = e("21"),
                r = e("43"),
                o = [
                    [5, 97],
                    [105, 245],
                    [255, 450],
                    [455, 585],
                    [590, 785],
                    [800, 870],
                    [875, 1130],
                    [1135, 1225]
                ],
                a = function(e) {
                    THREE.Object3D.call(this);
                    var t = this.cinematicCamera = new r({
                            name: e.name,
                            near: .001,
                            far: 100
                        }),
                        n = i.getMeshData(e.animation).geometry,
                        o = i.parseBones(n, !0);
                    this.add(t), this.add(o), e.helper && this.add(new THREE.CameraHelper(t)), this.camera = t, this.bone = o.getObjectByName(e.boneName), this.animation = new THREE.Animation(o, n.animation), this.animation.loop = void 0 !== e.loop ? e.loop : !0, this.animation.duration = this.animation.data.length, this.enabled = !1, this.started = !1, this.camera.matrixAutoUpdate = !1, this.camera.matrix = this.bone.matrixWorld, this.initSequences()
                };
            a.inherit(THREE.Object3D, {
                initSequences: function() {
                    this.sequences = o.map(function(e) {
                        var t = {};
                        return t.start = e[0] / this.animation.data.fps, t.end = e[1] / this.animation.data.fps, t.duration = t.end - t.start, t
                    }, this), this.currentSequence = 0
                },
                nextSequence: function() {
                    return this.currentSequence += 1, this.currentSequence === this.sequences.length && (this.currentSequence = 0), this.sequences[this.currentSequence]
                },
                update: function(e) {
                    var t = this.sequences[this.currentSequence];
                    if (this.enabled) {
                        this.started || this.animation.isPlaying || (this.animation.play(t.start), this.started = !0);
                        var n = this.animation.currentTime - t.end;
                        n > 0 && (t = this.nextSequence(), this.animation.currentTime = t.start, this.animation.reset()), this.animation.update(e.delta), this.updateMatrixWorld(!0), this.camera.updateMatrixWorld(!0)
                    } else this.animation.isPlaying && this.animation.stop()
                },
                toggle: function() {
                    this.enabled = !this.enabled
                }
            }), t.exports = a
        }, {
            21: 21,
            43: 43
        }
    ],
    47: [
        function(e, t, n) {
            var i = e("44"),
                r = e("52"),
                o = (e("55"), e("21")),
                a = (e("36"), e("17")),
                s = 7.5,
                l = function(e) {
                    i.call(this, e);
                    var t = this.headlights = new r({
                        envMap: this.cubeMapLightSharp
                    });
                    this.body.add(t), this.initFrontGlow(), o.delay(5e3, function() {
                        this.headlights.innerMaterial.emissiveIntensity = 1, this.showFrontGlow()
                    }, this)
                };
            l.inherit(i, {
                initFrontGlow: function() {
                    this.frontGlowMaterial = new THREE.MeshBasicMaterial({
                        map: o.getTexture("env/c-glow.png"),
                        transparent: !0,
                        color: 16777215,
                        depthTest: !1,
                        side: THREE.DoubleSide
                    }), this.frontGlow = new THREE.Object3D, this.add(this.frontGlow), this.frontGlow.visible = !1;
                    var e = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1, 1, 1), this.frontGlowMaterial);
                    e.position.set(.69, .65, 2.25), e.scale.multiplyScalar(.34), this.frontGlow.add(e);
                    var t = e.clone();
                    t.position.set(-.69, .65, 2.25), t.scale.x *= -1, this.frontGlow.add(t)
                },
                showFrontGlow: function() {
                    this.frontGlow.visible = !0
                },
                hideFrontGlow: function() {
                    this.frontGlow.visible = !1
                },
                enableHeadlights: function() {
                    i.prototype.enableHeadlights.call(this), this.headlights.enable()
                },
                disableHeadlights: function() {
                    i.prototype.disableHeadlights.call(this), this.headlights.disable()
                },
                setMode: function(e) {
                    i.prototype.setMode.call(this, e), "day" === e ? (this.headlights.setEnvMap(this.cubeMapLightSharp), this.materials.body.emissiveIntensity = .75, this.materials.interiorFront.emissiveIntensity = 1, this.materials.interiorBack.emissiveIntensity = 1) : "night" === e && this.headlights.setEnvMap(this.cubeMapDarkSharp), "night" === e && (this.headlights.innerMaterial.emissiveMap = this.headlights.emissiveMap2), "pitchblack" === e && (this.materials.body.envMap = null, this.materials.glass.envMap = null, this.wheels.forEach(function(e) {
                        e.setEnvMap(null)
                    }, this), this.headlights.innerMaterial.emissiveIntensity = 0, this.headlights.innerMaterial.envMap = null, this.materials.body.emissiveIntensity = 0, this.materials.interiorFront.emissiveIntensity = 0, this.materials.interiorBack.emissiveIntensity = 0)
                },
                setColor: function(e) {
                    this.materials.body.color2.setHex(a[e]), this.materials.bodyFlip.color2.setHex(a[e]), this.particlesMaterial.color = new THREE.Color(a[e]), this.materials.interiorFront.color = new THREE.Color(a[e]), o.delay(500, function() {
                        o.tween(1500, TWEEN.Easing.Linear.None).onUpdate(function(e) {
                            this.materials.body.colorTransition = e, this.materials.bodyFlip.colorTransition = e
                        }.bind(this)).onComplete(function() {
                            var e = this.materials.body.color;
                            this.materials.body.color = this.materials.body.color2, this.materials.bodyFlip.color = this.materials.bodyFlip.color2, this.materials.body.color2 = e, this.materials.bodyFlip.color2 = e, this.materials.body.colorTransition = 0, this.materials.bodyFlip.colorTransition = 0
                        }.bind(this))
                    }, this), o.tween(2e3, TWEEN.Easing.Linear.None).onUpdate(function(e) {
                        this.particlesMaterial.worldZ = (1 - e) * s - s / 2
                    }.bind(this))
                }
            }), t.exports = l
        }, {
            17: 17,
            21: 21,
            36: 36,
            44: 44,
            52: 52,
            55: 55
        }
    ],
    48: [
        function(e, t, n) {
            var i = e("56"),
                r = e("21"),
                o = e("16"),
                a = e("47"),
                s = (e("55"), e("58")),
                l = e("59"),
                c = e("54"),
                h = function() {
                    i.call(this, {
                        car: new a
                    }), this.skyColor = new THREE.Color(16777215), this.skyColor1 = new THREE.Color(16777215), this.skyColor2 = new THREE.Color(14475489), this.initTunnel(), this.initVignetting(), this.initLensFlare(), this.initCarHotspots(), this.wheelEditMode = !1, this.lights.forEach(function(e) {
                        e.updateMatrixWorld(!0)
                    }), this.refreshCustomMaterials(), this.initRearGlow(), this.controls.distance = 10, this.setMode("pitchblack")
                };
            h.inherit(i, {
                playIntro: function() {
                    this.introMode = !0, r.delay(1e3, function() {
                        this.fadeInRearGlow(), this.rotateRearGlow(), this.zoomCamera()
                    }, this), r.delay(7e3, function() {
                        this.fadeInGlow(), this.setMode("day"), this.fadeOutRearGlow(), this.car.hideFrontGlow(), o.spotLight()
                    }, this), r.delay(8e3, function() {
                        this.rotateCamera().done(function() {
                            this.introMode = !1
                        }.bind(this))
                    }, this), this.introPlayed = !0
                },
                initRearGlow: function() {
                    var e = r.getTexture("env/rearglow.png"),
                        t = new THREE.PlaneBufferGeometry(5.5, 5.5, 1, 1),
                        n = new THREE.MeshBasicMaterial({
                            map: e,
                            transparent: !0,
                            opacity: 0
                        });
                    this.rearGlow = new THREE.Mesh(t, n), this.rearGlow.position.set(0, .5, -2), this.add(this.rearGlow), this.tweens.rearGlow = new TWEEN.Tween
                },
                zoomCamera: function() {
                    this.tweens.cameraDistance = new TWEEN.Tween, this.tweens.cameraDistance.reset(this.controls).to({
                        distance: 8
                    }, 7e3).start()
                },
                rotateCamera: function() {
                    var e = new $.Deferred;
                    return this.tweens.cameraRotation = new TWEEN.Tween, this.tweens.cameraRotation.reset(this.controlsRotation).to({
                        x: Math.PI / 3,
                        y: Math.PI / 2.25
                    }, 1500).easing(TWEEN.Easing.Quartic.InOut).onUpdate(function() {
                        this.controls.setRotation(this.controlsRotation)
                    }.bind(this)).onComplete(function() {
                        this.controls.autoRotate = !0, this.showHotspots("exterior"), this.dispatchEvent({
                            type: "showHud"
                        }), e.resolve()
                    }.bind(this)).start(), e.promise()
                },
                fadeInGlow: function() {
                    this.tweens.glowIntensity = new TWEEN.Tween, this.tweens.glowIntensity.reset(this).to({
                        glowIntensity: 1
                    }, 1e3).easing(TWEEN.Easing.Quadratic.InOut).start()
                },
                rotateRearGlow: function() {
                    this.tweens.rearGlowRotation = new TWEEN.Tween, this.tweens.rearGlowRotation.reset(this.rearGlow.rotation).to({
                        z: .15
                    }, 5e3).start()
                },
                fadeInRearGlow: function() {
                    this.tweens.rearGlow.reset(this.rearGlow.material).to({
                        opacity: .8
                    }, 1e3).easing(TWEEN.Easing.Quadratic.InOut).start()
                },
                fadeOutRearGlow: function() {
                    this.tweens.rearGlow.reset(this.rearGlow.material).to({
                        opacity: 0
                    }, 1e3).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                        this.remove(this.rearGlow)
                    }.bind(this)).start()
                },
                initGlow: function() {
                    i.prototype.initGlow.call(this), this.glowIntensity = 0
                },
                initTunnel: function() {
                    this.tunnel = new s({
                        skyColor: this.skyColor
                    }), this.add(this.tunnel)
                },
                initVignetting: function() {
                    this.vignetting = new l, this.add(this.vignetting)
                },
                initLensFlare: function() {
                    var e = THREE.ImageUtils.loadTexture("textures/lensflare/Halo_Star_Blur.png"),
                        t = THREE.ImageUtils.loadTexture("textures/lensflare/lensflare3_alpha.png"),
                        n = THREE.ImageUtils.loadTexture("textures/lensflare/Flare_Pentagone.png");
                    this.lensFlare = new c(e, t, n), this.lensFlare.register(this), this.lensFlare.position.set(-14, 3.5, -12), this.add(this.lensFlare)
                },
                initControls: function() {
                    i.prototype.initControls.call(this), this.controlsRotation = new THREE.Vector2(Math.PI / 2, Math.PI / 2.15), this.exteriorControls.setRotation(this.controlsRotation)
                },
                initCarHotspots: function() {
                    this.car.addHotspot({
                        name: "door",
                        group: "exterior",
                        position: new THREE.Vector3(.95, .75, 0),
                        orientation: new THREE.Vector3(1, 0, 0),
                        maxSize: .12
                    }), this.hideHotspots(), this.showHotspots("exterior")
                },
                setupEvents: function() {
                    i.prototype.setupEvents.call(this), this.objectPicker.addEventListener("pick", function(e) {
                        var t = e.object;
                        "color" === t.name && this.showColorPicker(), "rim" === t.name && (this.car.openWheels(), this.showRimPicker())
                    }.bind(this))
                },
                setMode: function(e, t) {
                    i.prototype.setMode.call(this, e, t);
                    var n = 350,
                        o = TWEEN.Easing.Quadratic.InOut,
                        a = new THREE.Color(16777215),
                        s = new THREE.Color(0),
                        l = new THREE.Color(14475489);
                    "day" === e ? (r.tween(n, o).onUpdate(function(e) {
                        this.skyColor1.lerp(a, e), this.skyColor2.lerp(l, e)
                    }.bind(this)), this.lensFlare.show(), this.glow.visible = !1) : "night" === e && (r.tween(n, o).onUpdate(function(e) {
                        this.skyColor1.lerp(s, e), this.skyColor2.lerp(s, e)
                    }.bind(this)), this.lensFlare.hide(), this.glow.visible = !0), this.tunnel.setMode(e, t)
                },
                showColorPicker: function() {
                    this.dispatchEvent({
                        type: "showColorPicker"
                    })
                },
                showRimPicker: function() {
                    this.dispatchEvent({
                        type: "showRimPicker"
                    })
                },
                setCarColor: function(e) {
                    this.car.setColor(e)
                },
                startCar: function() {
                    i.prototype.startCar.call(this), this.vignetting.fadeOut(), o.startCar()
                },
                stopCar: function() {
                    i.prototype.stopCar.call(this), this.vignetting.fadeIn(), o.stopCar()
                },
                enterCar: function() {
                    i.prototype.enterCar.call(this), r.delay(4300, function() {
                        o.enterCar()
                    }, this)
                },
                exitCar: function() {
                    i.prototype.exitCar.call(this), r.delay(1e3, function() {
                        o.exitCar()
                    }, this)
                },
                updateSkyColor: function() {
                    var e = (new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3),
                        t = new THREE.Vector3,
                        n = 0;
                    return function(i) {
                        e.setFromMatrixPosition(i.matrixWorld), t.copy(e).normalize().negate(), n = 1 - Math.abs(t.x), this.skyColor.copy(this.skyColor1).lerp(this.skyColor2, n)
                    }
                }(),
                updateLensFlare: function() {
                    var e = this.controls.rotation.x,
                        t = this.controls.rotation.y,
                        n = .48;
                    n > e ? this.lensFlare.scaleFactor = THREE.Math.smoothstep(e, .12, n) : this.lensFlare.scaleFactor = 1 - THREE.Math.smoothstep(e, n, .6), this.lensFlare.scaleFactor *= 1 - THREE.Math.smoothstep(t, 1.53, 1.57), !this.autoCamera.enabled && this.exteriorView || (this.lensFlare.scaleFactor = 0)
                },
                update: function(e) {
                    i.prototype.update.call(this, e), this.vignetting && this.vignetting.update(this.exteriorControls.distance), this.updateSkyColor(this.camera), this.tunnel && this.tunnel.update(this.skyColor), this.ground && this.ground.updateSkyColor(this.skyColor), this.lensFlare && this.updateLensFlare()
                },
                render: function(e, t) {
                    i.prototype.render.call(this, e, t), this.introPlayed || this.playIntro()
                }
            }), t.exports = h
        }, {
            16: 16,
            21: 21,
            47: 47,
            54: 54,
            55: 55,
            56: 56,
            58: 58,
            59: 59
        }
    ],
    49: [
        function(e, t, n) {
            var i = e("55"),
                r = e("42"),
                o = function(e) {
                    r.call(this, {
                        animation: "door",
                        loop: !1,
                        debug: !1
                    });
                    var t = new i("door", function(e) {
                        var t = e.geometry;
                        t.skinIndices = [], t.skinWeights = []
                    });
                    t.setMaterial("JFC_Body", e.materials.body), t.setMaterial("JFC_Body_Flip", e.materials.bodyFlip), t.setMaterial("JFC_Glass", e.materials.glass), t.setMaterial("JFC_Others", e.materials.body), t.setMaterial("JFC_Int_Front", e.materials.interiorFront), t.setMaterial("JFC_Int_Back", e.materials.interiorBack), this.rotation.x = Math.PI / 2, this.addToBone(t, "Bone_01")
                };
            o.inherit(r, {}), t.exports = o
        }, {
            42: 42,
            55: 55
        }
    ],
    50: [
        function(e, t, n) {
            var i = function(e) {
                e = _.extend({
                    size: 100,
                    step: 10,
                    color: 0,
                    opacity: .2
                }, e);
                for (var t = new THREE.Geometry, n = e.size, i = -n; n >= i; i += e.step) t.vertices.push(new THREE.Vector3(-n, 0, i)), t.vertices.push(new THREE.Vector3(n, 0, i)), t.vertices.push(new THREE.Vector3(i, 0, -n)), t.vertices.push(new THREE.Vector3(i, 0, n));
                var r = new THREE.LineBasicMaterial({
                    color: e.color,
                    opacity: e.opacity
                });
                THREE.Line.call(this, t, r), this.type = THREE.LinePieces
            };
            i.inherit(THREE.Line), t.exports = i
        }, {}
    ],
    51: [
        function(e, t, n) {
            var i = e("21"),
                r = (e("55"), e("33")),
                o = function() {
                    THREE.Object3D.call(this);
                    var e = 10,
                        t = i.getTexture("env/TARMAC2.jpg");
                    t.wrapS = t.wrapT = THREE.RepeatWrapping, t.repeat.set(e, e), t.anisotropy = 16;
                    var n = i.getTexture("env/ground-lightmap.png"),
                        o = new THREE.PlaneGeometry(70, 70, 20, 20);
                    this.dayDiffuse = new THREE.Color(15658734), this.nightDiffuse = new THREE.Color(0), o.faceVertexUvs[1] = o.faceVertexUvs[0];
                    var a = new r({
                        color: 13421772,
                        map: t,
                        lightMap: n,
                        lightMapOpacity: 0,
                        colorStep1: new THREE.Color(15724525),
                        colorStep2: new THREE.Color(13553099),
                        colorStep3: new THREE.Color(14674410),
                        lightIntensity: 1
                    });
                    this.map = t, this.mesh = new THREE.Mesh(o, a), this.mesh.rotation.x = -Math.PI / 2, this.position.y -= .22, this.add(this.mesh), this.tweens = {
                        intensity: new TWEEN.Tween,
                        color: new TWEEN.Tween
                    }, this.moving = !1, this.speed = 0
                };
            o.inherit(THREE.Object3D, {
                update: function(e) {
                    this.mesh.material.update(e, this.map.offset, this.map.repeat), this.moving && (this.map.offset.y -= this.speed * e.delta)
                },
                updateSkyColor: function(e) {
                    this.mesh.material.colorStep3 = e
                },
                setMode: function(e, t) {
                    var n = void 0 !== t ? t : 350;
                    this.progress = 0, "day" == e && (this.mesh.material.color = this.dayDiffuse, this.tweens.intensity.reset(this.mesh.material).to({
                        lightIntensity: 1,
                        lightMapOpacity: 0
                    }, n).onUpdate(function(e) {
                        this.mesh.material.colorStep1.lerp(new THREE.Color(14342616), e), this.mesh.material.colorStep2.lerp(new THREE.Color(13553099), e), this.mesh.material.colorStep3.lerp(new THREE.Color(14475489), e)
                    }.bind(this)).easing(TWEEN.Easing.Quadratic.InOut).start(), this.tweens.color.reset(this).to({
                        progress: 1
                    }, n).easing(TWEEN.Easing.Quadratic.In).onUpdate(function(e) {
                        this.mesh.material.color.lerp(this.dayDiffuse, e)
                    }.bind(this)).start()), "night" == e && (this.tweens.intensity.reset(this.mesh.material).to({
                        lightIntensity: 0,
                        lightMapOpacity: 1
                    }, n).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function(e) {
                        this.mesh.material.colorStep1.lerp(new THREE.Color(0), e), this.mesh.material.colorStep2.lerp(new THREE.Color(0), e), this.mesh.material.colorStep3.lerp(new THREE.Color(0), e)
                    }.bind(this)).start(), this.tweens.color.reset(this).to({
                        progress: 1
                    }, n).easing(TWEEN.Easing.Quadratic.In).onUpdate(function(e) {
                        this.mesh.material.color.lerp(this.dayDiffuse, e)
                    }.bind(this)).start()), "pitchblack" == e && (this.mesh.material.color = this.nightDiffuse, this.mesh.material.colorStep1 = new THREE.Color(0), this.mesh.material.colorStep2 = new THREE.Color(0), this.mesh.material.colorStep3 = new THREE.Color(0))
                }
            }), t.exports = o
        }, {
            21: 21,
            33: 33,
            55: 55
        }
    ],
    52: [
        function(e, t, n) {
            var i = e("21"),
                r = e("55"),
                o = e("38"),
                a = function(e) {
                    THREE.Object3D.call(this), this.envMap = e.envMap, this.mesh = new r("headlights"), this.add(this.mesh);
                    var t = i.getTexture("car/headlights/JFC_Optic.png"),
                        n = i.getTexture("car/headlights/JFC_Optic_NM.png"),
                        a = i.getTexture("car/headlights/JFC_Optic_EM.png"),
                        s = i.getTexture("car/headlights/JFC_Optic_EM_2.png"),
                        l = i.getTexture("car/headlights/JFC_Optic_SM.png"),
                        c = i.getTexture("car/headlights/JFC_Optic_Mask.png"),
                        h = new o({
                            color: 16777215,
                            map: t,
                            normalMap: n,
                            emissiveMap: a,
                            emissiveIntensity: 2,
                            combine: THREE.MixOperation,
                            specularMap: l,
                            reflectionMask: c,
                            envMap: this.envMap
                        }),
                        u = new THREE.MeshLambertMaterial({
                            color: 16777215,
                            envMap: this.envMap,
                            transparent: !0,
                            combine: THREE.AddOperation,
                            reflectivity: 1,
                            opacity: .15
                        });
                    this.innerMaterial = h, this.glassMaterial = u, this.emissiveMap = a, this.emissiveMap2 = s, this.mesh.setMaterial("JFC_Optic", h), this.mesh.setMaterial("JFC_Glass_Optic", u)
                };
            a.inherit(THREE.Object3D, {
                setEnvMap: function(e) {
                    this.innerMaterial.envMap = e, this.glassMaterial.envMap = e
                },
                enable: function() {
                    this.innerMaterial.emissiveIntensity = 1, this.innerMaterial.emissiveMap = this.emissiveMap2
                },
                disable: function() {
                    this.innerMaterial.emissiveIntensity = 1, this.innerMaterial.emissiveMap = this.emissiveMap
                }
            }), t.exports = a
        }, {
            21: 21,
            38: 38,
            55: 55
        }
    ],
    53: [
        function(e, t, n) {
            var i = e("21"),
                r = function(e) {
                    THREE.Sprite.call(this, new THREE.SpriteMaterial({
                        depthTest: !1,
                        transparent: !0,
                        opacity: .9,
                        map: i.getTexture("car/hotspot.png")
                    })), this.name = e.name, this.group = e.group, this.position.copy(e.position), this.orientation = e.orientation, this.minDistance = e.minDistance || 9, this.maxSize = void 0 !== e.maxSize ? e.maxSize : 1, this.fadeDuration = 200, this.tweens = {
                        fade: new TWEEN.Tween
                    }
                };
            r.inherit(THREE.Sprite, {
                update: function() {
                    var e = new THREE.Vector3,
                        t = TWEEN.Easing.Quartic.Out;
                    return function(n) {
                        e.subVectors(n.position, this.position).normalize();
                        var i = THREE.Math.clamp(this.orientation.dot(e), 0, 1),
                            r = this.maxSize * t(i);
                        this.scale.set(r, r, r)
                    }
                }(),
                fadeIn: function() {
                    this.material.opacity = 0, this.tweens.fade.reset(this.material).to({
                        opacity: .9
                    }, this.fadeDuration).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                        this.pickable = !0
                    }.bind(this)).start()
                },
                fadeOut: function() {
                    this.tweens.fade.reset(this.material).to({
                        opacity: 0
                    }, this.fadeDuration).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                        this.pickable = !1
                    }.bind(this)).start()
                }
            }), t.exports = r
        }, {
            21: 21
        }
    ],
    54: [
        function(e, t, n) {
            var i = function(e, t, n) {
                THREE.Object3D.call(this), this.lensFlares = [];
                var i = 600 * window.devicePixelRatio,
                    r = 0,
                    o = THREE.AdditiveBlending,
                    a = new THREE.Color(16775582);
                this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, this.add(e, i, r, o, a, .35), this.add(t, 200, .4), this.add(t, 150, .5), this.add(n, 50, .65), this.add(n, 160, .75), this.add(n, 350, .9), this.scaleFactor = 1
            };
            i.prototype = Object.create(THREE.Object3D.prototype), i.prototype.constructor = i, i.prototype.add = function(e, t, n, i, r, o) {
                void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === o && (o = .8), void 0 === r && (r = new THREE.Color(16777215)), void 0 === i && (i = THREE.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
                    texture: e,
                    size: t,
                    distance: n,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 1,
                    opacity: o,
                    color: r,
                    blending: i
                })
            }, i.prototype.update = function() {
                var e, t, n = this.lensFlares.length,
                    i = 2 * -this.positionScreen.x,
                    r = 2 * -this.positionScreen.y;
                for (e = 0; n > e; e++) t = this.lensFlares[e], t.x = this.positionScreen.x + i * t.distance, t.y = this.positionScreen.y + r * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
            }, i.prototype.register = function(e) {
                e.__webglLensFlares || (e.__webglLensFlares = []), e.__webglLensFlares.push(this)
            }, i.prototype.unregister = function(e) {
                var t = e.__webglLensFlares.indexOf(this); - 1 !== t && e.__webglLensFlares.splice(t, 1)
            }, i.prototype.show = function() {
                this.lensFlares.forEach(function(e) {
                    e.previousOpacity && (e.opacity = e.previousOpacity)
                })
            }, i.prototype.hide = function() {
                this.lensFlares.forEach(function(e) {
                    e.previousOpacity || (e.previousOpacity = e.opacity), e.opacity = 0
                })
            }, t.exports = i
        }, {}
    ],
    55: [
        function(e, t, n) {
            var i = e("21"),
                r = function(e, t) {
                    var n = i.getMeshData(e);
                    t && t(n), THREE.Mesh.call(this, n.geometry, n.material.clone())
                };
            r.inherit(THREE.Mesh, {
                getMaterial: function(e) {
                    for (var t = 0; t < this.material.materials.length; t++) {
                        var n = this.material.materials[t];
                        if (n.name === e) return n
                    }
                },
                setMaterial: function(e, t) {
                    if (this.material.materials)
                        for (var n = 0; n < this.material.materials.length; n++) {
                            var i = this.material.materials[n];
                            if (i.name === e) {
                                this.material.materials[n] = t, t.name = e;
                                break
                            }
                        } else this.material = t, this.material.name = e
                }
            }), t.exports = r
        }, {
            21: 21
        }
    ],
    56: [
        function(e, t, n) {
            var i = e("21"),
                r = e("19"),
                o = e("18"),
                a = e("16"),
                s = e("43"),
                l = e("45"),
                c = e("46"),
                h = e("50"),
                u = (e("44"), e("51")),
                f = (e("42"), function(e) {
                    THREE.Scene.call(this), this.objects = [], this.materials = [], this.exteriorView = !0, this.carSpeed = 0, this.tweens = {
                        acceleration: new TWEEN.Tween,
                        fov: new TWEEN.Tween
                    }, this.initCamera(), this.initAutoCamera(), this.initPicker(), this.initLights(), this.initGround(), this.initControls(), this.initCar(e.car), this.initTransitionCamera(), this.initInteriorCamera(), this.initOrbitStates(), this.initGlow(), this.setupEvents()
                });
            f.inherit(THREE.Scene, {
                setRendererSize: function(e, t) {
                    this.rendererWidth = e, this.rendererHeight = t
                },
                initCamera: function() {
                    this.orbitCamera = new s({
                        name: "orbit",
                        near: .001
                    }), this.orbitCamera.position.set(5, 5, 5), this.orbitCamera.lookAt(new THREE.Vector3(0, 2, 0)), this.camera = this.orbitCamera
                },
                initLights: function() {
                    this.lights = [];
                    var e = 15790831,
                        t = 1118481;
                    this.hemisphereLight = new THREE.HemisphereLight(e, t, .8), this.lights.push(this.hemisphereLight), this.add(this.hemisphereLight), this.hemisphereLight.position.set(0, 10, 0), this.spot = new THREE.SpotLight(16777215, 1), this.spot.position.set(0, 8, 0), this.spot.target.position.set(0, 0, 0), this.lights.push(this.spot), this.add(this.spot)
                },
                setGroundColor: function(e) {
                    var t = new THREE.Color(e);
                    i.tween(1500, TWEEN.Easing.Linear.None).onUpdate(function(e) {
                        this.hemisphereLight.groundColor.lerp(t, e), this.refreshCustomMaterials()
                    }.bind(this))
                },
                initCar: function(e) {
                    this.car = e, this.objects.push(e), this.add(this.car), this.car.addEventListener("hotspot", function(e) {
                        this.objectPicker.add(e.hotspot)
                    }.bind(this))
                },
                initGround: function() {
                    var e = new u;
                    this.ground = e, this.materials.push(e.material), this.objects.push(e), this.add(e)
                },
                initGlow: function() {
                    var e = i.getTexture("env/glow.png"),
                        t = new THREE.SpriteMaterial({
                            color: 16777215,
                            map: e,
                            transparent: !0,
                            depthTest: !1
                        });
                    this.glow = new THREE.Sprite(t), this.glow.position.set(0, 10, 0), this.glow.scale.set(10, 25, 10), this.add(this.glow), this.glowIntensity = 1
                },
                initOrbitStates: function() {
                    this.orbitStates = {
                        "default": {
                            position: new THREE.Vector3(4, 2, 6),
                            target: new THREE.Vector3(0, .5, 0)
                        },
                        enter: this.transitionCamera.getInitialState(),
                        exit: this.transitionCamera.getInitialState(!0)
                    }
                },
                refreshCustomMaterials: function() {
                    THREE.customMaterials.forEach(function(e) {
                        e.refreshLightUniforms(this.lights)
                    }, this)
                },
                orbitToState: function(e, t, n) {
                    var i = this.orbitStates[e],
                        r = n && n.easing,
                        o = n && n.mute,
                        s = this.controls.orbitTo(i.position, t, r);
                    return this.controls.lookAt(i.target, t, r), o || a.moveCamera(), s
                },
                updateGlow: function() {
                    var e = new THREE.Vector3,
                        t = new THREE.Vector3,
                        n = new THREE.Vector3,
                        i = new THREE.Vector3,
                        r = new THREE.Vector3;
                    TWEEN.Easing.Linear.None;
                    return function(o) {
                        if (this.glow && this.glow.visible) {
                            var a = this.localToWorld(e.set(0, -1, 0));
                            i.subVectors(a, n).normalize(), n.setFromMatrixPosition(this.matrix), t.setFromMatrixPosition(this.camera.matrixWorld), r.subVectors(t, n).normalize();
                            var s = t.distanceTo(this.glow.position),
                                l = i.dot(r),
                                c = THREE.Math.mapLinear(l, -1, 0, 0, 1),
                                h = THREE.Math.clamp(THREE.Math.mapLinear(s, 3, 10, 0, 1), 0, 1);
                            this.glow.scale.set(10 * h, 25 * h, 10 * h), this.glow.material.opacity = c * this.glowIntensity
                        }
                    }
                }(),
                initControls: function() {
                    this.exteriorControls = new r({
                        camera: this.camera,
                        origin: new THREE.Vector3(0, .5, 0),
                        clampY: Math.PI / 2
                    }), this.exteriorControls.setRotation(new THREE.Vector2(0, Math.PI / 4)), this.exteriorControls.setTargetRotation(new THREE.Vector2(Math.PI / 3, Math.PI / 2.2)), this.controls = this.exteriorControls
                },
                initHelpers: function() {
                    this.helpers = [];
                    var e = new h;
                    this.add(e), this.helpers.push(e), _.each(this.lights, _.bind(function(e) {
                        var t = new THREE.PointLightHelper(e, 5);
                        t.material.color.setHex(0), this.add(t), this.helpers.push(t)
                    }, this));
                    var t = new THREE.AxisHelper(20);
                    t.position.y += .05, this.add(t), this.helpers.push(t)
                },
                initPicker: function() {
                    this.objectPicker = new o({
                        camera: this.camera
                    })
                },
                initAutoCamera: function() {
                    this.autoCamera = new c({
                        name: "auto",
                        animation: "camera_auto",
                        boneName: "Camera_Bone_01",
                        helper: !1
                    }), this.add(this.autoCamera)
                },
                initTransitionCamera: function() {
                    this.transitionCamera = new l({
                        name: "transition",
                        animation: "camera_transition",
                        boneName: "Camera_Bone_01",
                        loop: !1,
                        helper: !1
                    }), this.add(this.transitionCamera), this.transitionCamera.addEventListener("stop", function(e) {
                        this.transitionCamera.enabled = !1, this.resetInteriorCamera(0), this.enteringCar && (this.enteringCar = !1), this.exitingCar && (this.exteriorView = !0, this.orbitToState("enter", 0), setTimeout(function() {
                            this.orbitToState("default", 1700, {
                                easing: TWEEN.Easing.Sinusoidal.Out
                            }).done(function() {
                                this.showHotspots("exterior"), this.exitingCar = !1
                            }.bind(this))
                        }.bind(this), 10))
                    }.bind(this))
                },
                initInteriorCamera: function() {
                    var e = this.interiorCamera = new s({
                        name: "interior",
                        near: .001,
                        fov: 45
                    });
                    this.add(e), this.interiorControls = new r({
                        camera: e,
                        distance: .01,
                        damp: 2,
                        zoom: !1,
                        reverse: !0,
                        fixedDistance: !0
                    })
                },
                resetInteriorCamera: function(e) {
                    return this.interiorControls.distance = .01, this.interiorControls.origin.copy(this.orbitStates.exit.position), this.interiorControls.orbitTo(this.orbitStates.exit.target, e)
                },
                updateCamera: function(e) {
                    this.autoCamera.enabled ? (this.autoCamera.update(e), this.camera = this.autoCamera.camera) : this.transitionCamera && this.transitionCamera.enabled ? (this.transitionCamera.update(e), this.camera = this.transitionCamera.camera) : this.exteriorView || this.transitionCamera.enabled ? this.camera = this.orbitCamera : this.camera = this.interiorCamera, this.objectPicker.camera = this.camera
                },
                updateControls: function(e) {
                    if (this.controls) {
                        if (this.autoOrbit) return void(this.controls.enabled = !1);
                        this.interiorControls && (this.interiorControls.enabled = !1), this.exteriorControls.enabled = !1, this.camera === this.interiorCamera ? this.controls = this.interiorControls : this.controls = this.exteriorControls, this.controls.enabled = !(this.autoCamera.enabled || this.transitionCamera.enabled || this.multisenseMode || this.introMode), this.controls.update(e)
                    }
                },
                toggleHelpers: function() {
                    _.each(this.helpers, function(e) {
                        e.visible = !e.visible
                    })
                },
                setAspectRatio: function(e) {
                    this.orbitCamera.setAspectRatio(e), this.interiorCamera.setAspectRatio(e), this.transitionCamera.camera.setAspectRatio(e), this.autoCamera.camera.setAspectRatio(e)
                },
                setupEvents: function() {
                    this.objectPicker.addEventListener("pick", function(e) {
                        var t = e.object;
                        "door" === t.name && (this.toggleView(), this.dispatchEvent({
                            type: "showInterior"
                        }))
                    }.bind(this))
                },
                hideHotspots: function(e) {
                    this.car.hotspots.forEach(function(t) {
                        e && t.group !== e || t.fadeOut()
                    }, this)
                },
                showHotspots: function(e) {
                    this.car.hotspots.forEach(function(t) {
                        e && t.group !== e || t.fadeIn()
                    }, this)
                },
                setMode: function(e, t) {
                    this.mode = e, "day" === this.mode && (this.ground.setMode(e, t), this.car.setMode(e, t), this.hemisphereLight.intensity = .8, this.spot.intensity = 1), "night" === this.mode && (this.ground.setMode(e, t), this.car.setMode(e, t), this.hemisphereLight.intensity = .5, this.spot.intensity = .5), "pitchblack" === this.mode && (this.ground.setMode(e, t), this.car.setMode(e, t), this.hemisphereLight.intensity = 0, this.spot.intensity = 0), this.dispatchEvent({
                        type: "changeMode",
                        mode: e
                    }), this.refreshCustomMaterials()
                },
                toggleLights: function() {
                    "day" === this.mode ? this.setMode("night") : this.setMode("day")
                },
                enterCar: function() {
                    this.enteringCar = !0, this.dispatchEvent({
                        type: "showInterior"
                    }), this.hideHotspots("exterior"), this.orbitToState("enter", 1e3, {
                        easing: TWEEN.Easing.Linear.None
                    }).done(function() {
                        this.exteriorView = !1, this.car.flipGlassSide(), this.transitionCamera.started = !1, this.transitionCamera.enabled = !0, this.transitionCamera.reverse = !1, this.tweenFov()
                    }.bind(this)), i.delay(200, function() {
                        this.car.animateDoor().done(function() {
                            this.showHotspots("interior")
                        }.bind(this))
                    }, this), i.delay(1e3, function() {
                        a.openDoor()
                    }), i.delay(2e3, function() {
                        this.car.setGlassOpacity(.25), this.setGroundColor(6710886), this.car.exterior.renderOrder = 0, this.car.interior.renderOrder = 1
                    }, this)
                },
                exitCar: function() {
                    this.exitingCar = !0, this.dispatchEvent({
                        type: "hideInterior"
                    }), this.resetInteriorCamera(1e3).done(function() {
                        a.openDoor(), this.transitionCamera.started = !1, this.transitionCamera.enabled = !0, this.transitionCamera.reverse = !0, this.tweenFov(), this.hideHotspots("interior"), this.car.animateDoor(!0).done(function() {
                            this.car.flipGlassSide()
                        }.bind(this))
                    }.bind(this)), i.delay(2e3, function() {
                        this.car.setGlassOpacity(1), this.setGroundColor(1118481), this.car.exterior.renderOrder = 1, this.car.interior.renderOrder = 0
                    }, this)
                },
                toggleCameraMode: function() {
                    this.autoCamera.toggle()
                },
                toggleView: function() {
                    this.enteringCar || this.exitingCar || (this.exteriorView ? this.enterCar() : this.exitCar())
                },
                tweenFov: function() {
                    this.tweens.fov.reset(this.transitionCamera.camera).to({
                        fov: this.transitionCamera.reverse ? this.orbitCamera.fov : this.interiorCamera.fov
                    }, 3e3).easing(TWEEN.Easing.Linear.None).onUpdate(function() {
                        this.transitionCamera.camera.updateProjectionMatrix()
                    }.bind(this)).start()
                },
                startCar: function() {
                    this.ground.moving = !0, this.car.startRolling(), this.tweens.acceleration.reset(this).to({
                        carSpeed: 20
                    }, 750).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function() {
                        this.ground.speed = this.carSpeed / 4, this.car.setSpeed(this.carSpeed)
                    }.bind(this)).start()
                },
                stopCar: function() {
                    this.tweens.acceleration.reset(this).to({
                        carSpeed: 0
                    }, 1e3).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function() {
                        this.ground.speed = this.carSpeed / 4, this.car.setSpeed(this.carSpeed)
                    }).onComplete(function() {
                        this.ground.moving = !1, this.car.stopRolling()
                    }.bind(this)).start()
                },
                toggleCarMoving: function() {
                    this.carSpeed > 0 ? this.stopCar() : this.startCar()
                },
                update: function(e) {
                    this.objectPicker && this.objectPicker.update(e), this.objects.forEach(function(t) {
                        t.update(e, this.camera)
                    }, this), this.updateCamera(e), this.updateGlow(), this.updateControls(e)
                },
                render: function(e, t) {
                    this.camera && e.render(this, this.camera)
                }
            }), t.exports = f
        }, {
            16: 16,
            18: 18,
            19: 19,
            21: 21,
            42: 42,
            43: 43,
            44: 44,
            45: 45,
            46: 46,
            50: 50,
            51: 51
        }
    ],
    57: [
        function(e, t, n) {
            var i = e("21"),
                r = function(e) {
                    var t = i.getMeshData(e);
                    THREE.SkinnedMesh.call(this, t.geometry, t.material), this.material.skinning = !0
                };
            r.inherit(THREE.SkinnedMesh, {
                getMaterial: function(e) {
                    for (var t = 0; t < this.material.materials.length; t++) {
                        var n = this.material.materials[t];
                        if (n.name === e) return n
                    }
                },
                setMaterial: function(e, t) {
                    for (var n = 0; n < this.material.materials.length; n++) {
                        var i = this.material.materials[n];
                        if (i.name === e) {
                            this.material.materials[n] = t, t.name = e;
                            break
                        }
                    }
                }
            }), t.exports = r
        }, {
            21: 21
        }
    ],
    58: [
        function(e, t, n) {
            var i = e("21"),
                r = e("55"),
                o = e("40"),
                a = function(e) {
                    THREE.Object3D.call(this), this.mapDiffuseDay = i.getTexture("env/pattern.png"), this.mapDiffuseDay.wrapS = this.mapDiffuseDay.wrapT = THREE.RepeatWrapping, this.mapDiffuseDay.repeat.set(35, 35), this.mapDiffuseNight = i.getTexture("env/pattern_night.png"), this.mapDiffuseNight.wrapS = this.mapDiffuseNight.wrapT = THREE.RepeatWrapping, this.mapDiffuseNight.repeat.set(35, 35), this.diffuseDay = new THREE.Color(16777215), this.diffuseNight = new THREE.Color(0), this.baseColorDay = new THREE.Color(14342616), this.baseColorNight = new THREE.Color(0), this.glowColorDay = new THREE.Color(16777215), this.glowColorNight = new THREE.Color(0), this.bgColorDay = e.skyColor;
                    var t = new o({
                        map: this.mapDiffuseDay,
                        color: 16777215,
                        baseColor: this.baseColorDay.getHex(),
                        bgColor: this.bgColorDay.getHex(),
                        glowColor: this.glowColorDay,
                        gradientHeight: 6,
                        glowPosition: new THREE.Vector3(-30, 5, -15)
                    });
                    this.mesh = new r("tunnel"), this.mesh.setMaterial("Config_Tunnel", t), this.add(this.mesh), this.tweens = {
                        brightness: new TWEEN.Tween
                    }
                };
            a.inherit(THREE.Object3D, {
                setMode: function(e, t) {
                    var n = void 0 !== t ? t : 350,
                        r = TWEEN.Easing.Quadratic.InOut;
                    "day" === e ? (this.mesh.material.map = this.mapDiffuseDay, this.mesh.material.color.setHex(16777215), this.mesh.material.needsUpdate = !0, i.tween(n, r).onUpdate(function(e) {
                        this.mesh.material.baseColor.lerp(this.baseColorDay, e), this.mesh.material.glowColor.lerp(this.glowColorDay, e)
                    }.bind(this))) : "night" === e ? (this.mesh.material.map = this.mapDiffuseNight, this.mesh.material.color.setHex(16777215), this.mesh.material.needsUpdate = !0, i.tween(n, r).onUpdate(function(e) {
                        this.mesh.material.baseColor.lerp(this.baseColorNight, e), this.mesh.material.glowColor.lerp(this.glowColorNight, e)
                    }.bind(this))) : "pitchblack" === e && (this.mesh.material.map = null, this.mesh.material.color.setHex(0), this.mesh.material.baseColor.copy(this.baseColorNight), this.mesh.material.glowColor.copy(this.glowColorNight))
                },
                update: function(e) {
                    this.mesh.material.bgColor = e
                }
            }), t.exports = a
        }, {
            21: 21,
            40: 40,
            55: 55
        }
    ],
    59: [
        function(e, t, n) {
            var i = e("21"),
                r = e("41"),
                o = function() {
                    var e = i.getTexture("env/vignetting.png"),
                        t = new THREE.PlaneGeometry(1, 1, 1),
                        n = new r({
                            map: e,
                            transparent: !0,
                            depthWrite: !1
                        });
                    t.vertices[0].set(-1, 1, 0), t.vertices[1].set(1, 1, 0), t.vertices[2].set(-1, -1, 0), t.vertices[3].set(1, -1, 0), t.verticesNeedUpdate = !0, THREE.Mesh.call(this, t, n), this.material = n, this.tweens = {
                        opacity: new TWEEN.Tween
                    }
                };
            o.inherit(THREE.Mesh, {
                update: function(e) {
                    this.material.uniforms.cameraDistance.value = e
                },
                fadeIn: function() {
                    this.tweens.opacity.reset(this.material).to({
                        opacity: 1
                    }, 1e3).start()
                },
                fadeOut: function() {
                    this.tweens.opacity.reset(this.material).to({
                        opacity: 0
                    }, 1e3).start()
                }
            }), t.exports = o
        }, {
            21: 21,
            41: 41
        }
    ],
    60: [
        function(e, t, n) {
            var i = e("21"),
                r = e("55"),
                o = (e("42"), e("31")),
                a = e("39"),
                s = function(e) {
                    THREE.Object3D.call(this), this.initModels(e.envMap, e.carSide), this.initBones(), this.initShadow(), this.initCover(), this.tire.add(this.models.tire), this.rim.add(this.currentRim), this.screw.add(this.models.screw), this.logo.add(this.models.logo), this.rotating = !1, this.speed = 0, this.tweens = {
                        coverOpacity: new TWEEN.Tween
                    }
                };
            s.inherit(THREE.Object3D, {
                initModels: function(e, t) {
                    var n = i.getTexture("car/wheels/rim/JFC_Rim_01.jpg"),
                        s = i.getTexture("car/wheels/rim/JFC_Rim_01_Mask.png"),
                        l = i.getTexture("car/wheels/rim/JFC_Rim_01_NM.png"),
                        c = i.getTexture("car/wheels/int/JFC_Rim_Int.jpg"),
                        h = (i.getTexture("car/wheels/int/JFC_Rim_Int_Mask.png"), i.getTexture("car/wheels/int/JFC_Rim_Int_NM.png")),
                        u = i.getTexture("car/wheels/tire/JFC_Tire.jpg"),
                        f = i.getTexture("car/wheels/tire/JFC_Tire_NM.png");
                    this.materials = {
                        rim: new o({
                            map: n,
                            color: 16777215,
                            normalMap: l,
                            shininess: 100,
                            reflectivity: .15,
                            reflectionMask: s,
                            envMap: e
                        }),
                        tire: new THREE.MeshPhongMaterial({
                            map: u,
                            color: 16777215,
                            shininess: 10,
                            normalMap: f
                        }),
                        rimInt: new a({
                            color: 16777215,
                            map: c,
                            normalMap: h,
                            shininess: 10,
                            specular: 5592405,
                            carSide: t
                        }),
                        cover: new THREE.MeshBasicMaterial({
                            color: 0,
                            transparent: !0
                        })
                    }, this.models = {
                        tire: new r("tire"),
                        rim: new r("rim"),
                        screw: new r("screw"),
                        logo: new r("logo")
                    }, this.models.rim.setMaterial("JFC_Rim_01", this.materials.rim), this.models.rim.setMaterial("JFC_Rim_Int", this.materials.rimInt), this.models.tire.material = this.materials.tire, this.models.screw.material = this.materials.rim, this.models.logo.material = this.materials.rim, this.currentRim = this.models.rim
                },
                initCover: function() {
                    var e = .3,
                        t = new THREE.CylinderGeometry(e, e, .01, 24, 1);
                    this.cover = new THREE.Mesh(t, this.materials.cover), this.cover.rotation.z = Math.PI / 2, this.cover.position.x += .11, this.cover.renderOrder = 1, this.add(this.cover)
                },
                initShadow: function() {
                    var e = i.getTexture("car/shadow/JFC_Ground_Wheel_AO.png");
                    this.shadow = new THREE.Mesh(new THREE.PlaneBufferGeometry(.9, 1.5, 1, 1), new THREE.MeshBasicMaterial({
                        map: e,
                        transparent: !0
                    })), this.shadow.position.y -= .38, this.shadow.rotation.x = -Math.PI / 2, this.shadow.renderDepth = 10;
                    var t = new THREE.Gyroscope;
                    t.add(this.shadow), this.models.tire.add(t)
                },
                setEnvMap: function(e) {
                    this.materials.rim.envMap = e, this.materials.rim.needsUpdate = !0
                },
                initBones: function() {
                    this.tire = new THREE.Object3D, this.tire.position.fromArray([-.0019662, 295318e-9, 750068e-10]), this.add(this.tire), this.rim = new THREE.Object3D, this.rim.position.fromArray([.00420342, -.00411721, .00410991]), this.add(this.rim), this.screw = new THREE.Object3D, this.screw.position.fromArray([-.0659582, 732697e-9, .00550807]), this.add(this.screw), this.logo = new THREE.Object3D, this.logo.position.fromArray([-.0861295, -474085e-10, -349638e-10]), this.logo.rotation.x = Math.PI / 2, this.add(this.logo)
                },
                update: function(e) {
                    this.rotating && (this.rotation.x += this.speed * e.delta)
                }
            }), t.exports = s
        }, {
            21: 21,
            31: 31,
            39: 39,
            42: 42,
            55: 55
        }
    ],
    61: [
        function(e, t, n) {
            var i = function(e) {
                    function t(e, t) {
                        var i = n.createProgram(),
                            r = n.createShader(n.FRAGMENT_SHADER),
                            o = n.createShader(n.VERTEX_SHADER),
                            a = "precision " + t + " float;\n";
                        return n.shaderSource(r, a + e.fragmentShader), n.shaderSource(o, a + e.vertexShader), n.compileShader(r), n.compileShader(o), n.attachShader(i, r), n.attachShader(i, o), n.linkProgram(i), i
                    }
                    var n, i, o, a = {};
                    this.init = function(e) {
                        n = e.context, i = e, o = e.getPrecision(), a.vertices = new Float32Array(16), a.faces = new Uint16Array(6);
                        var s = 0;
                        a.vertices[s++] = -1, a.vertices[s++] = -1, a.vertices[s++] = 0, a.vertices[s++] = 0, a.vertices[s++] = 1, a.vertices[s++] = -1, a.vertices[s++] = 1, a.vertices[s++] = 0, a.vertices[s++] = 1, a.vertices[s++] = 1, a.vertices[s++] = 1, a.vertices[s++] = 1, a.vertices[s++] = -1, a.vertices[s++] = 1, a.vertices[s++] = 0, a.vertices[s++] = 1, s = 0, a.faces[s++] = 0, a.faces[s++] = 1, a.faces[s++] = 2, a.faces[s++] = 0, a.faces[s++] = 2, a.faces[s++] = 3, a.vertexBuffer = n.createBuffer(), a.elementBuffer = n.createBuffer(), n.bindBuffer(n.ARRAY_BUFFER, a.vertexBuffer), n.bufferData(n.ARRAY_BUFFER, a.vertices, n.STATIC_DRAW), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, a.elementBuffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, a.faces, n.STATIC_DRAW), n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0 ? (a.hasVertexTexture = !1, a.program = t(r, o)) : (a.hasVertexTexture = !0, a.program = t(r, o)), a.attributes = {}, a.uniforms = {}, a.attributes.vertex = n.getAttribLocation(a.program, "position"), a.attributes.uv = n.getAttribLocation(a.program, "uv"), a.uniforms.map = n.getUniformLocation(a.program, "map"), a.uniforms.opacity = n.getUniformLocation(a.program, "opacity"), a.uniforms.color = n.getUniformLocation(a.program, "color"), a.uniforms.scale = n.getUniformLocation(a.program, "scale"), a.uniforms.rotation = n.getUniformLocation(a.program, "rotation"), a.uniforms.screenPosition = n.getUniformLocation(a.program, "screenPosition")
                    }, this.render = function(e, t, r, o) {
                        if (e.__webglLensFlares) {
                            var s = e.__webglLensFlares,
                                l = s.length;
                            if (l) {
                                var c = new THREE.Vector3,
                                    h = o / r,
                                    u = .5 * r,
                                    f = .5 * o,
                                    d = 16 / o,
                                    p = new THREE.Vector2(d * h, d),
                                    m = new THREE.Vector3(1, 1, 0),
                                    v = new THREE.Vector2(1, 1),
                                    g = a.uniforms,
                                    y = a.attributes;
                                n.useProgram(a.program), n.enableVertexAttribArray(a.attributes.vertex), n.enableVertexAttribArray(a.attributes.uv), n.uniform1i(g.map, 1), n.bindBuffer(n.ARRAY_BUFFER, a.vertexBuffer), n.vertexAttribPointer(y.vertex, 2, n.FLOAT, !1, 16, 0), n.vertexAttribPointer(y.uv, 2, n.FLOAT, !1, 16, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, a.elementBuffer), n.disable(n.CULL_FACE), n.depthMask(!1);
                                var x, w, _, b, E;
                                for (x = 0; l > x; x++)
                                    if (d = 16 / o, p.set(d * h, d), b = s[x], c.set(b.matrixWorld.elements[12], b.matrixWorld.elements[13], b.matrixWorld.elements[14]), c.applyMatrix4(t.matrixWorldInverse), c.applyProjection(t.projectionMatrix), m.copy(c), v.x = m.x * u + u, v.y = m.y * f + f, a.hasVertexTexture || v.x > 0 && v.x < r && v.y > 0 && v.y < o)
                                        for (b.positionScreen.copy(m), b.update(), n.enable(n.BLEND), w = 0, _ = b.lensFlares.length; _ > w; w++) E = b.lensFlares[w], E.opacity > .001 && E.scale > .001 && (m.x = E.x, m.y = E.y, m.z = E.z, d = E.size * E.scale / o, p.x = d * h, p.y = d, p.multiplyScalar(b.scaleFactor), n.uniform3f(g.screenPosition, m.x, m.y, m.z), n.uniform2f(g.scale, p.x, p.y), n.uniform1f(g.rotation, E.rotation), n.uniform1f(g.opacity, E.opacity), n.uniform3f(g.color, E.color.r, E.color.g, E.color.b), i.state.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), i.setTexture(E.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0));
                                n.enable(n.CULL_FACE), n.enable(n.DEPTH_TEST), n.depthMask(!0)
                            }
                        }
                    }, this.init(e)
                },
                r = {
                    vertexShader: ["uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["precision mediump float;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "float visibility = 1.0;", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}"].join("\n")
                };
            t.exports = i
        }, {}
    ],
    62: [
        function(e, t, n) {
            var i = e("66"),
                r = i.extend({
                    template: "about.html",
                    events: {
                        "tap .js-exit": "exit"
                    },
                    initialize: function() {},
                    show: function() {
                        this._container.addClass("visible")
                    },
                    hide: function() {
                        this._container.removeClass("visible")
                    },
                    exit: function(e) {
                        var t = 350;
                        this._container.addClass("fadeout"), setTimeout(function() {
                            this._container.removeClass("visible fadeout"), this.trigger("resume")
                        }.bind(this), t), this.trigger("hidden")
                    }
                });
            t.exports = r
        }, {
            66: 66
        }
    ],
    63: [
        function(e, t, n) {
            var i = (e("21"), e("66")),
                r = e("9"),
                o = i.extend({
                    template: "hud.html",
                    events: {
                        "tap .js-lights-toggle": "toggleLights",
                        "tap .js-sound-toggle": "toggleSound",
                        "tap .js-camera-toggle": "toggleStartStop",
                        "tap .js-view-toggle": "toggleView",
                        "tap .js-about-toggle": "showAbout"
                    },
                    initialize: function() {
                        this.$lightsButton = $(".js-lights-toggle"), this.$soundButton = $(".js-sound-toggle"), this.$cameraButton = $(".js-camera-toggle"), this.$viewButton = $(".js-view-toggle"), this.$compare = this.$(".js-compare"), this.savedCarCount = 0, this.carStarted = !1, (!r.AUDIO || r.AUDIO && window.isMobile) && setTimeout(function() {
                            this.toggleSound()
                        }.bind(this), 100)
                    },
                    stopPropagation: function(e) {
                        e.stopPropagation()
                    },
                    show: function() {
                        this._container.addClass("visible")
                    },
                    hide: function() {
                        this._container.removeClass("visible")
                    },
                    toggleLights: function() {
                        this.$lightsButton.toggleClass("disabled"), this.$el.toggleClass("night"), this.trigger("toggleLights")
                    },
                    toggleSound: function(e) {
                        e && e.stopPropagation(), this.$soundButton.toggleClass("disabled"), this.trigger("toggleSound")
                    },
                    toggleStartStop: function() {
                        this.$cameraButton.toggleClass("disabled"), this.trigger("toggleStartStop"), this.carStarted ? (this.carStarted = !1, this.$el.removeClass("driving"), this.trigger("stopCar")) : (this.carStarted = !0, this.$el.addClass("driving"), this.trigger("startCar"))
                    },
                    toggleView: function() {
                        this.$viewButton.toggleClass("disabled"), this.trigger("toggleView")
                    },
                    fadeOut: function() {
                        this._container.addClass("fadeout")
                    },
                    fadeIn: function() {
                        this._container.removeClass("fadeout")
                    },
                    showAbout: function() {
                        this.trigger("showAbout")
                    }
                });
            t.exports = o
        }, {
            21: 21,
            66: 66,
            9: 9
        }
    ],
    64: [
        function(e, t, n) {
            var i = e("66"),
                r = i.extend({
                    template: "interior.html",
                    events: {
                        "tap .js-exit": "onExit"
                    },
                    initialize: function() {},
                    show: function() {
                        this._container.addClass("visible")
                    },
                    hide: function() {
                        this._container.removeClass("visible")
                    },
                    onExit: function(e) {
                        this.trigger("toggleView")
                    }
                });
            t.exports = r
        }, {
            66: 66
        }
    ],
    65: [
        function(e, t, n) {
            var i = e("21"),
                r = e("66"),
                o = e("63"),
                a = e("64"),
                s = e("62"),
                l = r.extend({
                    template: "main.html",
                    events: {
                        tap: "onTap"
                    },
                    views: {
                        hud: {
                            ".js-hud-container": o
                        },
                        interior: {
                            ".js-interior-container": a
                        },
                        about: {
                            ".js-about-container": s
                        }
                    },
                    initialize: function(e) {
                        this.setupEvents(), this.views.hud.hide()
                    },
                    setupEvents: function() {
                        this.views.hud.on("startCar", this.onStartCar, this), this.views.hud.on("stopCar", this.onStopCar, this), this.views.hud.on("showAbout", this.showAbout, this), this.views.about.on("hidden", this.onHideAbout, this)
                    },
                    showHud: function() {
                        this.views.hud.show()
                    },
                    onTap: function() {},
                    onMove: function() {},
                    onMoveEnd: function() {},
                    onStartCar: function() {},
                    onStopCar: function() {},
                    showConfigurator: function() {
                        this.trigger("showConfigurator")
                    },
                    showInterior: function() {
                        this.views.hud.$el.addClass("interior"), i.delay(5500, function() {
                            this.views.interior.show()
                        }.bind(this))
                    },
                    hideInterior: function() {
                        this.views.interior.hide(), i.delay(6500, function() {
                            this.views.hud.$el.removeClass("interior")
                        }.bind(this))
                    },
                    showAbout: function() {
                        this.trigger("pause"), this.views.hud.hide(), this.views.about.show()
                    },
                    onHideAbout: function() {
                        this.views.hud.show()
                    }
                });
            t.exports = l
        }, {
            21: 21,
            62: 62,
            63: 63,
            64: 64,
            66: 66
        }
    ],
    66: [
        function(e, t, n) {
            var i = e("2"),
                r = e("6"),
                o = i.View.extend({
                    constructor: function(e) {
                        e || (e = {}), this.cid = _.uniqueId("view"), _.extend(this, _.pick(e, a)), this._ensureElement(), this.delegateEvents(), this._options = e, this._container = e.container, this._context = e.context, this._views = this.views, this.views = {}, this.template && (this._renderTemplate(e.context), this._insert()), this._initSubViews(e), this.initialize.apply(this, arguments)
                    },
                    _forEachSubView: function(e) {
                        _.each(this._views, function(t, n) {
                            var i = _.keys(t)[0],
                                r = t[i],
                                o = this.$(i);
                            if (!n || !r) throw "`views` is not declared correctly";
                            if (0 == o.length) throw "Selector of sub-view container is invalid";
                            e.call(this, n, r, o)
                        }, this)
                    },
                    _initSubViews: function(e) {
                        this._forEachSubView(function(t, n, i) {
                            var r = _.clone(e);
                            r.container = i, this.addSubView(t, new n(r))
                        })
                    },
                    addSubView: function(e, t) {
                        return this.views[e] = t, t.on("all", function() {
                            this.trigger.apply(this, arguments)
                        }, this), void 0 === t._context && (t._context = this._context), t
                    },
                    _renderTemplate: function(e) {
                        var t = $(r.render(this.template, e));
                        this.setElement(t)
                    },
                    _insert: function() {
                        this._container && this._container.append(this.$el)
                    },
                    _renderSubViews: function(e) {
                        this._forEachSubView(function(t, n, i) {
                            this.views[t]._container = i, this.views[t].render(e)
                        }, this)
                    },
                    render: function(e) {
                        return e = e || this._context, this.$el && this.$el.remove(), this.dispose(), this._renderTemplate(e), this._insert(), this._renderSubViews(e), this.initialize(this._options), this
                    },
                    dispose: function() {},
                    show: function() {
                        return this.$el.show(), this._container.scrollTop(1), this
                    },
                    hide: function() {
                        return this.$el.hide(), this
                    },
                    isVisible: function() {
                        return this.$el.is(":visible")
                    }
                }),
                a = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
            t.exports = o
        }, {
            2: 2,
            6: 6
        }
    ]
}, {}, [1]);